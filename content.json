[{"title":"Hello World","path":"posts/undefined.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"2021C.S.N夏令营VUE班级讲义","path":"posts/d28d.html","text":"一、课程安排1.学前基础html、css、javascript、ajax 2.开发工具2.1 下载安装Vscode 前端VUE项目，原先的开发工具是HBuilderX（上手快捷，使用方便），但是随着项目规模的增大，随之而来的是维护和管理成本的不可控（手下码农或者是实习生随性而发的编写格式，代码习惯，维护起来简直就是地狱！！！）。这个问题目前看来最优解就是引入ESLINT，参考其他大厂前端编码规范，制定一套符合自己的前端编码规范（并硬性地要求开发在编程时严格准守这套规范，甚至是不符合规范就无法正常启动项目的程度）。无奈HBuilder引入eslint问题多多，最终放弃。之前刚学习vue的时候使用vscode感觉他eslint插件就很符合现在的情况，一点小格式错误就直接报错了，给初学者的我都整蒙了，一气之下直接关了eslint。所以现在重回VScode，整理一套搭建前端开发环境的流程，供大家参考学习。 下载地址：https://code.visualstudio.com/Download# 按照自己实际情况选择下载安装包（一般是Windows System Installer 64bit） 以及在选择附加任务的时候，建议选中“添加到PATH（重启后生效）”。 2.2 插件安装 点击左侧倒数第二个Extensions按钮，进入插件市场，安装如图所示插件： Chinese (Simplified) Language Pack for Visual Studio CodeESLintGitLens — Git superchargedVeturPrettier - Code formatter第一个中文语言包可选，第二个ESLint代码校验插件，第三个git管理工具，第四个vue开发插件，第五个代码格式化插件 2.3 环境校验 打开内置控制台，分步输入以下指令，检查环境是否已安装。node -v （检查node是否已安装）npm -v （检查npm 是否已安装）vue （检查vue是否已安装） 3.课程安排 二、Vue简介1. 官网https://cn.vuejs.org/ Vue.js（读音 &#x2F;vjuː&#x2F;, 类似于 view） 是一套构建用户界面的渐进式框架。 Vue 只关注视图层， 采用自底向上增量开发的设计。 Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 2.作者尤雨溪，前端框架Vue.js的作者，HTML5版Clear的打造人，独立开源开发者。曾就职于Google Creative Labs和Meteor Development Group。由于工作中大量接触开源的JavaScript项目，最后自己也走上了开源之路，现全职开发和维护Vue.js。 三、Node安装Windows 上安装 Node.jsNode.js 安装包及源码下载地址为：https://nodejs.org/en/download/。 检测PATH环境变量是否配置了Node.js，点击开始&#x3D;》运行&#x3D;》输入”cmd” &#x3D;&gt; 输入命令”path”，输出如下结果： 12345PATH=C:\\oraclexe\\app\\oracle\\product\\10.2.0\\server\\bin;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;c:\\python32\\python;C:\\MinGW\\bin;C:\\Program Files\\GTK2-Runtime\\lib;C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin;C:\\Program Files\\nodejs\\;C:\\Users\\rg\\AppData\\Roaming\\npm 我们可以看到环境变量中已经包含了C:\\Program Files\\nodejs\\ 检查Node.js版本 node –version 用处参考： https://www.runoob.com/vue2/vue-install.html 四、Vue安装1、独立版本我们可以在 Vue.js 的官网上直接下载 vue.min.js 并用 script 标签引入。 https://vuejs.org/js/vue.min.js 2、使用 CDN 方法以下推荐国外比较稳定的两个 CDN，国内还没发现哪一家比较好，目前还是建议下载到本地。 Staticfile CDN（国内） : https://cdn.staticfile.org/vue/2.2.2/vue.min.js unpkg：https://unpkg.com/vue/dist/vue.js, 会保持和 npm 发布的最新的版本一致。 cdnjs : https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js 3、NPM 方法npm: nodejs 下的包管理器。 webpack: 它主要用途是通过CommonJS 的语法把所有浏览器端需要发布的静态资源作相应的准备，比如资源的合并和打包。 vue-cli: 用户生成Vue工程模板。（帮你快速开始一个vue的项目，也就是给你一套vue的结构，包含基础的依赖库，只需要npm install 就可以安装。 npm配置模块路径、cache路径 先配置npm的全局模块的存放路径以及cache的路径 具体方法：在NodeJs下建立”node_global”及”node_cache”两个文件夹。如下图 然后运行以下2条命令 1npm config set prefix &quot;D:\\program files\\nodejs\\node_global&quot; 1npm config set cache &quot;D:\\program files\\nodejs\\node_cache&quot; 输入命令配置镜像站 1npm config set registry=http://registry.npm.taobao.org 输入命令显示所有配置信息 1npm config list 检查一下镜像站行不行命令 1npm info vue 注意，此时，默认的模块D:\\program files\\nodejs\\node_modules目录 将会改变为D:\\program files\\nodejs\\node_global\\node_modules 目录， 如果直接运行npm install等命令会报错的。 我们需要做1件事情：增加环境变量NODE_PATH 内容是：D:\\program files\\nodejs\\node_global\\node_modules， 注意，一下操作需要重新打开CMD让上面的环境变量生效 参考：https://www.php.cn/js-tutorial-414607.html 全局安装 vue-cli1npm install --global vue-cli 创建一个基于 webpack 模板的新项目路径！ 1vue init webpack my-project Vue build &#x3D;&#x3D;&gt; 打包方式，回车即可； Install vue-router &#x3D;&#x3D;&gt; 是否要安装 vue-router，项目中肯定要使用到 所以Y 回车； Use ESLint to lint your code &#x3D;&#x3D;&gt; 是否需要 js 语法检测 目前我们不需要 所以 n 回车； Set up unit tests &#x3D;&#x3D;&gt; 是否安装 单元测试工具 目前我们不需要 所以 n 回车； Setup e2e tests with Nightwatch &#x3D;&#x3D;&gt; 是否需要 端到端测试工具 目前我们不需要 所以 n 回车； 安装依赖1cd my-projectnpm i 启动项目1npm run dev ctrl c结束 参考： https://www.cnblogs.com/hellman/p/10985377.html 五、vue项目目录讲解 1、build：构建脚本目录 1）build.js &#x3D;&#x3D;&gt; 生产环境构建脚本；&#96;&#96; 2）check-versions.js &#x3D;&#x3D;&gt; 检查npm，node.js版本； 3）utils.js &#x3D;&#x3D;&gt; 构建相关工具方法； 4）vue-loader.conf.js &#x3D;&#x3D;&gt; 配置了css加载器以及编译css之后自动添加前缀； 5）webpack.base.conf.js &#x3D;&#x3D;&gt; webpack基本配置； 6）webpack.dev.conf.js &#x3D;&#x3D;&gt; webpack开发环境配置； 7）webpack.prod.conf.js &#x3D;&#x3D;&gt; webpack生产环境配置； 2、config：项目配置 1）dev.env.js &#x3D;&#x3D;&gt; 开发环境变量； 2）index.js &#x3D;&#x3D;&gt; 项目配置文件； 3）prod.env.js &#x3D;&#x3D;&gt; 生产环境变量； 3、node_modules：npm 加载的项目依赖模块 4、src：这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件： 1）assets：资源目录，放置一些图片或者公共js、公共css。这里的资源会被webpack构建； 2）components：组件目录，我们写的组件就放在这个目录里面； 3）router：前端路由，我们需要配置的路由路径写在index.js里面； 4）App.vue：根组件； 5）main.js：入口js文件； 5、static：静态资源目录，如图片、字体等。不会被webpack构建 6、index.html：首页入口文件，可以添加一些 meta 信息等 7、package.json：npm包配置文件，定义了项目的npm脚本，依赖包等信息&#96;&#96; 8、README.md：项目的说明文档，markdown 格式 9、.xxxx文件：这些是一些配置文件，包括语法配置，git配置等 router&#x2F;index.js1//引入Vueimport Vue from &#x27;vue&#x27;; //引入vue-router import Router from &#x27;vue-router&#x27;;//引入根目录下的HelloWorld.vue组件import HelloWorld from &#x27;@/components/HelloWorld&#x27;;//Vue全局使用RouterVue.use(Router);export default new Router(&#123; //配置路由，这里是个数组 routes: [ &#123; //每一个链接都是一个对象 path: &#x27;/&#x27;, //链接路径 name: &#x27;HelloWorld&#x27;, //路由名称，可以在router-link和router.push中使用，就相当于这个组件了 component: HelloWorld //对应的组件模板 &#125; ]&#125;); 六、开始我们的第一个vue项目1.使用vscode，新建.vue文件，自动生成vue文件代码块模板文件 –&gt; 首选项 –&gt; 用户代码片段 –&gt; 输入vue，选择vue.json –&gt;复制下面代码内容并保存 无vue.json 的选vue-html 1&#123; &quot;Print to console&quot;: &#123; &quot;prefix&quot;: &quot;Vue模板&quot;, &quot;body&quot;: [ &quot;&lt;template&gt;&quot;, &quot;\\t&lt;div&gt;\\n&quot;, &quot;\\t&lt;/div&gt;&quot;, &quot;&lt;/template&gt;\\n&quot;, &quot;&lt;script&gt;&quot;, &quot;\\texport default &#123;&quot;, &quot;\\t\\tprops: &#123;\\n&quot;, &quot;\\t\\t&#125;,&quot;, &quot;\\t\\tcomponents: &#123;\\n&quot;, &quot;\\t\\t&#125;,&quot;, &quot;\\t\\tdata()&#123;&quot;, &quot;\\t\\t\\treturn &#123;\\n\\t\\t\\t\\t$0&quot;, &quot;\\t\\t\\t&#125;&quot;, &quot;\\t\\t&#125;,&quot;, &quot;\\t\\tmethods: &#123;\\n&quot;, &quot;\\t\\t&#125;&quot;, &quot;\\t&#125;&quot;, &quot;&lt;/script&gt;\\n&quot;, &quot;&lt;style lang=\\&quot;scss\\&quot;&gt;\\n&quot;, &quot;&lt;/style&gt;&quot; ], &quot;description&quot;: &quot;Vue模板&quot; &#125;&#125; 添加配置，让vscode允许自定义的代码片段提示出来文件 –&gt; 首选项 –&gt; 设置 —&gt; 添加这2项 1“editor.snippetSuggestions”: “top”,“editor.formatOnPaste”: true 测试是否添加成功测试方法： 新建vue后缀文件，在空白文件内输入vue会出现提示，利用上下箭头选择第二个”vue模板“按下回车，如下面第二张就OK了 1、在components目录下新建一个views目录，里面写我们的vue组件 1）开始我们的第一个组件： a：在views目录下新建First.vue b：在router目录下的index.js里面配置路由路径 预定报错 1npm install less@3.12.2 less-loader@4.1.0 --save-dev 2.自动打开浏览器 1）打开config &#x3D;&#x3D;&gt; index.js 2）module.exports配置中找到autoOpenBrowser，默认设置的是false 3）将autoOpenBrowser改为true 为了避免端口冲突，也可以修改port，打开目录同上 作业1：去除链接中的# 一、vue项目携带一个#会对开发造成一定的影响： 1、微信三方登录回调地址，有#号时，接收不到code参数 2、微信H5支付的回调地址，不允许有# 3、App分享，处理特殊字符时，可能会对#进行编译 4、有点影响美观 现在网站大多有三方登录，支付等功能，存在#，项目开发就存在很大的障碍。话不多说，开始去掉#吧。 1http://localhost:8081/#/first 1mode: &#x27;history&#x27;, 七、使用路由搭建单页应用新建一个Second.vue组件 路由跳转： 1&lt;router-link to=&quot;/second&quot;&gt;去第二个页面&lt;/router-link&gt; 1&lt;template&gt; &lt;div&gt; &lt;h1&gt;kif&lt;/h1&gt; &lt;topView text=&quot;注册&quot; @message=&quot;getmessage&quot;&gt;&lt;/topView&gt; &lt;p&gt;&lt;router-link to=&quot;/second&quot;&gt;去第二个页面&lt;/router-link&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import topView from &#x27;../components/mod/topView&#x27;export default &#123; props: &#123;&#125;, components: &#123; topView &#125;, data() &#123; return &#123; &#125;; &#125;, methods: &#123; getmessage(val) &#123; console.log(val) &#125; &#125;,&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 八、用less写样式什么是LESS？LESS是一个CSS预处理器，可以为网站启用可自定义，可管理和可重用的样式表。 LESS是一种动态样式表语言，扩展了CSS的功能。 LESS也是跨浏览器友好。 CSS预处理器是一种脚本语言，可扩展CSS并将其编译为常规CSS语法，以便可以通过Web浏览器读取。 它提供诸如变量，函数， mixins 和操作等功能，可以构建动态CSS。 https://less.bootcss.com/#%E6%A6%82%E8%A7%88 安装less依赖：1npm install less less-loader --save 安装成功之后，可在package.json中看到，多增加了2个模块： 在main.js 1import less from &#x27;less&#x27;Vue.use(less) 编写less 1&lt;style lang=&quot;less&quot; rel=&quot;stylesheet/less&quot; scoped&gt;&lt;/style&gt; 报错： 解决：https://blog.csdn.net/qq_44617099/article/details/114973132 原因 less-loader版本过高解决办法 卸载原来的less和less-loader 1npm uninstall less-loader npm uninstall less 1npm install less@3.12.2 less-loader@4.1.0 --save-dev 1.多层嵌套1&lt;div id=&quot;mainView&quot;&gt; &lt;h1&gt;kif&lt;/h1&gt; &lt;topView text=&quot;注册&quot; @message=&quot;getmessage&quot;&gt;&lt;/topView&gt; &lt;div class=&quot;firstView&quot;&gt; View1 &lt;div class=&quot;secondView&quot;&gt; view2 &lt;/div&gt; &lt;/div&gt;&lt;style lang=&quot;less&quot; rel=&quot;stylesheet/less&quot; scoped&gt;#mainView&#123; height: 200px; width: 200px; background-color: antiquewhite; .firstView&#123; height: 100px; width: 100px; background-color: aqua; .secondView &#123; width: 50px; height: 50px; background-color: aliceblue; &#125; &#125;&#125; 2.less中变量的使用在less，允许我们使用以变量的形式来定义，定义方式：@k:v; 使用方式：@k; 1&lt;style lang=&quot;less&quot; rel=&quot;stylesheet/less&quot; scoped&gt;@mycolor : #FFCA28;#mainView&#123; height: 200px; width: 200px; background-color: antiquewhite; .firstView&#123; height: 100px; width: 100px; background-color: aqua; .secondView &#123; width: 50px; height: 50px; background-color: @mycolor; &#125; &#125;&#125;&lt;/style&gt; 3.字符串拼接变量使用方式；1&lt;style lang=&quot;less&quot; rel=&quot;stylesheet/less&quot; scoped&gt;@mycolor : #FFCA28;@static :&#x27;../assets/&#x27;;#mainView&#123; height: 200px; width: 200px; background-color: antiquewhite; .firstView&#123; height: 100px; width: 100px; background: url(&quot;@&#123;static&#125;bac.png&quot;); .secondView &#123; width: 50px; height: 50px; background-color: @mycolor; &#125; &#125;&#125;&lt;/style&gt; 注意：路径需要用””包裹，@{img}这种凡是把变量引进来才能生效； 4.混合 &#x3D; 函数1&lt;div class=&quot;box1&quot;&gt;我是box1&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;我是box2&lt;/div&gt; &lt;style lang=&quot;less&quot;&gt;//定义一个函数；.test(@color:red,@size:14px)&#123; background: @color; font-size:@size;&#125;.box1&#123;// 不传参，使用默认的； .test()&#125;.box2&#123;// 给函数传参； .test(@color:green,@size:30px)&#125;&lt;/style&gt; 参考： https://www.jianshu.com/p/779ed2c368a3 九、Vue.js 模板语法Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。 Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。 结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。 1.插值文本数据绑定最常见的形式就是使用 &#123;&#123;...&#125;&#125; （双大括号）的文本插值 Html使用 v-html 指令用于输出 html 代码： 属性HTML 属性中的值应使用 v-bind 指令。 以下实例判断 use 的值，如果为 true 使用 class1 类的样式，否则不使用该类： 表达式Vue.js 都提供了完全的 JavaScript 表达式支持。 2.指令指令是带有 v- 前缀的特殊属性。 指令用于在表达式的值改变时，将某些行为应用到 DOM 上。 v-ifv-model在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定： v-model 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。 按钮的事件我们可以使用 v-on 监听事件，并对用户的输入进行响应。 以下实例在用户点击按钮后对字符串进行反转操作： 3.缩写v-bind 缩写Vue.js 为两个最为常用的指令提供了特别的缩写： 1&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt; v-on 缩写1&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt; 十、Vue.js 条件语句1.条件判断v-if1&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt; &lt;div v-if=&quot;ok&quot;&gt; &lt;p&gt;哈哈哈，打字辛苦啊！！！&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; seen: true, ok: true &#125;&#125;)&lt;/script&gt; v-else可以用 v-else 指令给 v-if 添加一个 “else” 块： 1&lt;div v-if=&quot;Math.random()&gt;0.5&quot;&gt; &lt;p&gt;fasf111111111&lt;/p&gt; &lt;/div&gt; &lt;div v-else&gt; &lt;p&gt;qwerq3433333333333&lt;/p&gt; &lt;/div&gt; v-show我们也可以使用 v-show 指令来根据条件展示元素： 1&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; 十一.Vue.js 循环语句v-forv-for 指令需要以 site in sites 形式的特殊语法， sites 是源数据数组并且 site 是数组元素迭代的别名。 v-for 可以绑定数据到数组来渲染一个列表： 1&lt;div v-for=&quot;item in arr&quot;&gt; &lt;p&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt;&lt;/div&gt; &lt;script&gt;import axios from &quot;axios&quot;;export default &#123; props: &#123;&#125;, components: &#123;&#125;, data() &#123; return &#123; arr:[ &#x27;12&#x27;, &#x27;123&#x27;, &#x27;1234&#x27;, &#x27;12345&#x27; ] &#125;; &#125;, methods: &#123; &#125;,&#125;;&lt;/script&gt; 1&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(value, key, index) in object&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; object:&#123; name:&quot;kif2&quot;, age:12, sex:&quot;man&quot;, class:7 &#125; &#125;&#125;)&lt;/script&gt; 你也可以提供第二个的参数为键名,第三个参数为索引. 十二、Vue.js 计算属性计算属性关键词: computed。 计算属性在处理一些复杂逻辑时是很有用的。 1&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&lt;h2&gt;&#123;&#123;remessage&#125;&#125;&lt;/h2&gt; &lt;script&gt;import axios from &quot;axios&quot;;export default &#123; props: &#123;&#125;, components: &#123;&#125;, data() &#123; return &#123; message: &quot;kif is cool&quot;, &#125;; &#125;, computed: &#123; remessage:function () &#123; return this.message.split(&quot; &quot;).reverse().join(&quot; &quot;) &#125; &#125;, methods: &#123; &#125;,&#125;;&lt;/script&gt; 中声明了一个计算属性 remessage 。 提供的函数将用作属性 vm.remessage 的 getter 。 vm.remessage 依赖于 vm.message，在 vm.message 发生改变时，vm.remessage 也会更新。 computed vs methods我们可以使用 methods 来替代 computed，效果上两个都是一样的，但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。 可以说使用 computed 性能会更好，但是如果你不希望缓存，你可以使用 methods 属性。 十三、Vue.js 监听属性Vue.js 监听属性 watch我们可以通过 watch 来响应数据的变化。 以下实例通过使用 watch 实现计数器： 1&lt;p style = &quot;font-size:25px;&quot;&gt;计数器: &#123;&#123; counter &#125;&#125;&lt;/p&gt; &lt;button @click = &quot;counter++&quot; style = &quot;font-size:25px;&quot;&gt;点我&lt;/button&gt; &lt;script&gt;import axios from &quot;axios&quot;;export default &#123; props: &#123;&#125;, components: &#123;&#125;, data() &#123; return &#123; counter:10, &#125;; &#125;, watch:&#123; counter:function (newValue,oldValue) &#123; console.log(&quot;新值:&quot;+newValue+&quot;-----旧值&quot;+oldValue) &#125; &#125;, methods: &#123; &#125;,&#125;;&lt;/script&gt; 十四、Vue.js 表单v-model指令在表单控件元素上创建双向数据绑定。 1&lt;p&gt;input 元素：&lt;/p&gt; &lt;input v-model=&quot;message&quot; placeholder=&quot;编辑我……&quot;&gt; &lt;p&gt;消息是: &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p&gt;textarea 元素：&lt;/p&gt; &lt;p style=&quot;white-space: pre&quot;&gt;&#123;&#123; message2 &#125;&#125;&lt;/p&gt; &lt;textarea v-model=&quot;message2&quot; placeholder=&quot;多行文本输入……&quot;&gt;&lt;/textarea&gt; &lt;script&gt;new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;kif is cool&quot;, message2:&quot;C.S.N&quot;, &#125;&#125;)&lt;/script&gt; 案例一：图片轮播1&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;img :src=&quot;imgArr[index].src&quot; style=&quot;width: 200px&quot; /&gt; &lt;a @click=&quot;shang()&quot;&gt;上一张&lt;/a&gt; &lt;a @click=&quot;next()&quot;&gt;下一张&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &quot;axios&quot;;export default &#123; props: &#123;&#125;, components: &#123;&#125;, data() &#123; return &#123; imgArr: [ &#123; src: &quot;https://gitee.com/wkkif/PicGoimg/raw/master/img/20210626155050.jpg&quot;, id: 0, &#125;, &#123; src: &quot;https://gitee.com/wkkif/PicGoimg/raw/master/img/20210613163532.jpg&quot;, id: 1, &#125;, &#123; src: &quot;https://gitee.com/wkkif/PicGoimg/raw/master/img/20210505221033.jpg&quot;, id: 2, &#125;, &#123; src: &quot;https://gitee.com/wkkif/PicGoimg/raw/master/img/20210505221026.jpg&quot;, id: 3, &#125;, ], index: 0, &#125;; &#125;, watch: &#123; &#125;, computed: &#123; &#125;, methods: &#123; next: function () &#123; if (this.index == 3) &#123; this.index = 0; &#125; else &#123; this.index++; &#125; &#125;, shang: function () &#123; if (this.index == 0) &#123; this.index = 3; &#125; else &#123; this.index--; &#125; &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 作业2：自动播放轮播图十五、父子组件1）创建子组件在components目录下新建mod文件夹，用于存放一下可以复用的子组件。比如新建一个topView.vue组件 2）在父组件中引入子组件 引入： 1import topView from &#x27;../components/mod/topView&#x27; 注册：在&lt;script&gt;&lt;/script&gt;标签内的 name代码块后面加上 1components: &#123;topView &#125; 使用：在&lt;template&gt;&lt;/template&gt;内加上 1&lt;topView&gt;&lt;/topView&gt; 效果： 3）父子组件通信 子组件： 父组件： 十六、项目实战一、项目概述1.学习目标 2.项目结构 3.项目概述 4.功能 5.开发模式 6.前端技术栈 二、项目创建2.2.1创建一个基于 webpack 模板的新项目路径！ 1vue init webpack my-project Vue build &#x3D;&#x3D;&gt; 打包方式，回车即可； Install vue-router &#x3D;&#x3D;&gt; 是否要安装 vue-router，项目中肯定要使用到 所以Y 回车； Use ESLint to lint your code &#x3D;&#x3D;&gt; 是否需要 js 语法检测 目前我们不需要 所以 n 回车； Set up unit tests &#x3D;&#x3D;&gt; 是否安装 单元测试工具 目前我们不需要 所以 n 回车； Setup e2e tests with Nightwatch &#x3D;&#x3D;&gt; 是否需要 端到端测试工具 目前我们不需要 所以 n 回车； 2.2.2安装依赖1cd my-projectnpm i 2.2.3启动项目1npm run dev ctrl c结束 参考： https://www.cnblogs.com/hellman/p/10985377.html 2.3 ElementUIhttps://element.eleme.cn/#/zh-CN 2.3.1 npm 安装推荐使用 npm 的方式安装，它能更好地和 webpack 打包工具配合使用。 1npm i element-ui -S 2.3.2 引入Element引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。 在 main.js 中写入以下内容： 1import Vue from &#x27;vue&#x27;;import ElementUI from &#x27;element-ui&#x27;;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;import App from &#x27;./App.vue&#x27;;Vue.use(ElementUI);new Vue(&#123; el: &#x27;#app&#x27;, render: h =&gt; h(App)&#125;); 以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。 2.3.3 全局配置在引入 Element 时，可以传入一个全局配置对象。该对象目前支持 size 与 zIndex 字段。size 用于改变组件的默认尺寸，zIndex 设置弹框的初始 z-index（默认值：2000）。按照引入 Element 的方式，具体操作如下： 完整引入 Element： 1import Vue from &#x27;vue&#x27;;import Element from &#x27;element-ui&#x27;;Vue.use(Element, &#123; size: &#x27;small&#x27;, zIndex: 3000 &#125;); 2.4 Axios Axios是一个基于promise的HTTP库（类似于jQuery的Ajax，用于HTTP请求） 2.4.1 使用 npm:1npm install axios 2.4.2.使用 cdn:1&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 2.5、用less写样式2.5.1什么是LESS？LESS是一个CSS预处理器，可以为网站启用可自定义，可管理和可重用的样式表。 LESS是一种动态样式表语言，扩展了CSS的功能。 LESS也是跨浏览器友好。 CSS预处理器是一种脚本语言，可扩展CSS并将其编译为常规CSS语法，以便可以通过Web浏览器读取。 它提供诸如变量，函数， mixins 和操作等功能，可以构建动态CSS。 https://less.bootcss.com/#%E6%A6%82%E8%A7%88 2.5.2安装less依赖：1npm install less less-loader --save 安装成功之后，可在package.json中看到，多增加了2个模块： 在main.js 1import less from &#x27;less&#x27;Vue.use(less) 编写less 1&lt;style lang=&quot;less&quot; rel=&quot;stylesheet/less&quot; scoped&gt;&lt;/style&gt; 报错： 解决：https://blog.csdn.net/qq_44617099/article/details/114973132 原因 less-loader版本过高解决办法 卸载原来的less和less-loader 1npm uninstall less-loader npm uninstall less 1npm install less@3.12.2 less-loader@4.1.0 --save-dev 2.5.3.多层嵌套1&lt;div id=&quot;mainView&quot;&gt; &lt;h1&gt;kif&lt;/h1&gt; &lt;topView text=&quot;注册&quot; @message=&quot;getmessage&quot;&gt;&lt;/topView&gt; &lt;div class=&quot;firstView&quot;&gt; View1 &lt;div class=&quot;secondView&quot;&gt; view2 &lt;/div&gt; &lt;/div&gt;&lt;style lang=&quot;less&quot; rel=&quot;stylesheet/less&quot; scoped&gt;#mainView&#123; height: 200px; width: 200px; background-color: antiquewhite; .firstView&#123; height: 100px; width: 100px; background-color: aqua; .secondView &#123; width: 50px; height: 50px; background-color: aliceblue; &#125; &#125;&#125; 三、后端接口电商管理后台 API 接口文档 3.1. API V1 接口说明 接口基准地址：http://timemeetyou.com:8889/api/private/v1/ 服务端已开启 CORS 跨域支持 API V1 认证统一使用 Token 认证 需要授权的 API ，必须在请求头中使用 Authorization 字段提供 token 令牌 使用 HTTP Status Code 标识状态 数据返回格式统一使用 JSON 3.1.1. 支持的请求方法 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。 3.1.2. 通用返回状态说明 状态码 含义 说明 200 OK 请求成功 201 CREATED 创建成功 204 DELETED 删除成功 400 BAD REQUEST 请求的地址不存在或者包含不支持的参数 401 UNAUTHORIZED 未授权 403 FORBIDDEN 被禁止访问 404 NOT FOUND 请求的资源不存在 422 Unprocesable entity [POST&#x2F;PUT&#x2F;PATCH] 当创建一个对象时，发生一个验证错误 500 INTERNAL SERVER ERROR 内部错误 3.1.3 postman测试Postman： 1&#123; &quot;data&quot;: &#123; &quot;id&quot;: 500, &quot;rid&quot;: 0, &quot;username&quot;: &quot;admin&quot;, &quot;mobile&quot;: &quot;13113344444&quot;, &quot;email&quot;: &quot;arthur.cao@icloud.com&quot;, &quot;token&quot;: &quot;Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOjUwMCwicmlkIjowLCJpYXQiOjE2MjU2NTA0NTEsImV4cCI6MTYyNTczNjg1MX0.T0d5W_HNtLsOtSlz5eD5kGHHIGvCMQ4YFN4Ye7oa7FU&quot; &#125;, &quot;meta&quot;: &#123; &quot;msg&quot;: &quot;登录成功&quot;, &quot;status&quot;: 200 &#125;&#125; 四、登录4.1.登录业务流程①在登录页面输入用户名和密码②调用后台接口进行验证③通过验证之后，根据后台的响应状态跳转到项目主页 4.2.登录业务的相关技术点●http是无状态的 ●通过cookie在客户端记录状态 ●通过session在服务器端记录状态 ●通过token方式维持状态（跨域时） 4.3 token 4.4 实现登录功能4.4.1 布局 4.4.2 创建页面1&lt;template&gt; &lt;div&gt; &lt;div class=&quot;login_box&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; &#125;, components: &#123; &#125;, data()&#123; return &#123; &#125; &#125;, methods: &#123; &#125; &#125;&lt;/script&gt;&lt;style&gt;.login_box&#123; width: 450px; height: 300px; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); background-color: aquamarine;&#125;&lt;/style&gt; 1.logo1&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;login_box&quot;&gt; &lt;div class=&quot;avatar_box&quot;&gt; &lt;img src=&quot;../assets/logo.png&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; props: &#123;&#125;, components: &#123;&#125;, data() &#123; return &#123;&#125;; &#125;, methods: &#123;&#125;,&#125;;&lt;/script&gt;&lt;style lang=&quot;less&quot; rel=&quot;stylesheet/less&quot; scoped&gt; .main &#123; .login_box &#123; background-color: white; width: 450px; height: 300px; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); &#125; .avatar_box &#123; height: 130px; width: 130px; border: 1px solid #eee; background-color: white; border-radius: 50%; padding: 10px; position: absolute; left: 50%; transform: translate(-50%,-50%); img &#123; height: 100%; width: 100%; border-radius: 50%; background-color: #eee; &#125; &#125;&#125; &lt;/style&gt; 2.输入框1&lt;el-form :model=&quot;from&quot; label-width=&quot;80px&quot; class=&quot;loginFrom&quot;&gt; &lt;el-form-item label=&quot;用户名&quot;&gt; &lt;el-input prefix-icon=&quot;el-icon-user&quot; v-model=&quot;from.username&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot;&gt; &lt;el-input prefix-icon=&quot;el-icon-help&quot; v-model=&quot;from.password&quot; show-password &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item class=&quot;btn&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;login()&quot;&gt;登录&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot;&gt;注册&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; 3.数据绑定1&lt;el-form :model=&quot;from&quot; label-width=&quot;80px&quot; class=&quot;loginFrom&quot;&gt; &lt;el-form-item label=&quot;用户名&quot;&gt; &lt;el-input prefix-icon=&quot;el-icon-user&quot; v-model=&quot;from.username&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot;&gt; &lt;el-input prefix-icon=&quot;el-icon-help&quot; v-model=&quot;from.password&quot; show-password &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item class=&quot;btn&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;login()&quot;&gt;登录&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot;&gt;注册&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; data() &#123; return &#123; from: &#123; username: &quot;&quot;, password: &quot;&quot;, &#125;, &#125;; &#125;, 4.验证规则from： 1&lt;el-form :rules=&quot;loginRule&quot;&gt; item: 1&lt;el-form-item prop=&quot;password&quot;&gt; data: 1loginRule:&#123; password:[ &#123; min: 3, max: 5, message: &#x27;长度在 3 到 5 个字符&#x27;, trigger: &#x27;blur&#x27; &#125; ] &#125; 5.登陆预验证from： 1&lt;el-form ref=&quot;loginFromref&quot;&gt; method: 1login: function () &#123; var flag; this.$refs.loginFromref.validate((valid) =&gt; &#123; flag = valid; &#125;); if (flag) &#123; var username = this.from.username; var password = this.from.password; console.log(username); &#125; &#125;, 6.axios(1) 1axios.post(&quot;http://timemeetyou.com:8889/api/private/v1/login&quot;, this.from).then((res) =&gt; &#123; console.log(&quot;数据：&quot;, res); &#125;); (2).全局设置 main.js 1import axios from &quot;axios&quot;axios.defaults.baseURL = &quot;http://timemeetyou.com:8889/api/private/v1/&quot;; // 关键步骤–填写后台请求统一的地址axios.defaults.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded&#x27;; //设置全局数据发送格式Vue.config.productionTip = false;Vue.prototype.$axios = axios; vue: 1this.$axios .post(&quot;login&quot;, this.from) .then((res) =&gt; &#123; console.log(res.data); if (res.data.meta.status == 200) &#123; this.$router.push(&#123; path: &quot;/index&quot; &#125;); this.$message(&#123; message: &quot;恭喜你，这是一条成功消息&quot;, type: &quot;success&quot;, &#125;); &#125; else &#123; if(res.data.meta.status==400) &#123; this.$message.error(&#x27;密码错误&#x27;); &#125; &#125; &#125;) .catch((err) =&gt; console.log(err)); 4.4.3 token 1.将登录成功之后的token,保存到客户端的sessionStorage 中 1window.sessionStorage.setItem(&quot;token&quot;,res.data.data.token) 1.1 项目中出了登录之外的其他API接口，必须在登录之后才能访问 1.2 token 只应在当前网站打开期间生效，所以将token保存在sessionStorage 中 2.通过编程式导航跳转到后台主页，路由地址是&#x2F;index 4.5 实现导航守卫如果用户没有登录，但是直接通过URL访问特定页面，需要重新导航到登录页面。 修改router router: 1const router= new Router(&#123; routes: [ &#123; path: &#x27;/&#x27;, name: &#x27;login&#x27;, component: login &#125;, &#123; path: &#x27;/index&#x27;, name: &#x27;index&#x27;, component: index &#125;, ]&#125;) // 挂载router.beforeEach((to,from,next)=&gt;&#123; // to将要访问的路径 // from 代表从哪个路径跳转而来 // next是一个函数，表示放行 // next()放行 next(&#x27; /login&#x27;)强制跳转 if(to.path===&#x27;/&#x27;) return next() const tokenStr = window.sessionStorage.getItem(&quot;token&quot;) if(!tokenStr) return (&quot;/&quot;) next()&#125;)export default router 4.5 退出登录4.5.1 退出功能实现原理基于token的方式实现退出比较简单，只需要销毁本地的token即可。这样，后续的请求就不会携带token，必须重新登录生成一个新的token之后才可以访问页面。 1//清空tokenwindow.sessionStorage.clear ()//跳转到登录页this.$router.push(&#x27;/&#x27;) 五、主页5.1 布局 1&lt;el-container&gt; &lt;el-header&gt;Header&lt;/el-header&gt; &lt;el-container&gt; &lt;el-aside width=&quot;200px&quot;&gt;Aside&lt;/el-aside&gt; &lt;el-main&gt;Main&lt;/el-main&gt; &lt;/el-container&gt;&lt;/el-container&gt; 5.2 csshttps://uigradients.com/#PiggyPink 1.三块颜色2.撑满全屏 .index-container { height: 100%; } 5.3 header1&lt;el-header class=&quot;index-header&quot;&gt; &lt;div class=&quot;hea&quot;&gt; &lt;img class=&quot;logo&quot; src=&quot;../assets/logo.png&quot; /&gt; &lt;span class=&quot;shopname&quot;&gt;河东小卖部&lt;/span&gt; &lt;/div&gt; &lt;el-button @click=&quot;loginout()&quot; class=&quot;loginout&quot;&gt;退出&lt;/el-button&gt; &lt;/el-header&gt; 1.el-header &#123; background-color: #202124; display: flex; justify-content: space-between; padding-left: 0; align-items: center; color: white;&#125;.el-aside &#123; background-color: #20385E;&#125;.logo &#123; width: 60px;&#125;.shopname &#123; top: 9px; margin-left: 20px;&#125;.hea &#123; text-align: center;&#125; 5.4 aside 1&lt;el-menu default-active=&quot;2&quot; class=&quot;el-menu-vertical-demo&quot; @open=&quot;handleOpen&quot; @close=&quot;handleClose&quot; background-color=&quot;#545c64&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#ffd04b&quot; &gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt; &lt;span&gt;导航一&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot;&gt;选项2&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;el-submenu index=&quot;2&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt; &lt;span&gt;导航二&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item index=&quot;2-1&quot;&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;2-2&quot;&gt;选项2&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;el-submenu index=&quot;3&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt; &lt;span&gt;导航三&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item index=&quot;3-1&quot;&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;3-2&quot;&gt;选项2&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; 5.5 获取菜单数据5.5.1 Axios添加Authorization需要授权的 API ，必须在请求头中使用 Authorization 字段提供 token 令牌 通过axios请求拦截器添加token,保证拥有获取数据的权限。 main.js 1axios.interceptors.request.use(config=&gt; &#123; console.log(config) config.headers.Authorization = window.sessionStorage.getItem(&#x27;token&#x27;) return config; &#125;) 5.5.2 api获取数据 请求路径：menus 请求方法：get 响应数据 1&#123; &quot;data&quot;: &#123; &quot;id&quot;: 101, &quot;authName&quot;: &quot;商品管理&quot;, &quot;path&quot;: null, &quot;children&quot;: [ &#123; &quot;id&quot;: 104, &quot;authName&quot;: &quot;商品列表&quot;, &quot;path&quot;: null, &quot;children&quot;: [] &#125; ] &#125; &quot;meta&quot;: &#123; &quot;msg&quot;: &quot;获取菜单列表成功&quot;, &quot;status&quot;: 200 &#125;&#125; 生命周期函数 1created（） &#123;&#125;, data： 1data() &#123; return &#123; menu: [], &#125;; &#125;, created： 1created() &#123; this.getmenuData(); &#125;, methods： 1// 获取左侧菜单数据 getmenuData() &#123; this.$axios .get(&quot;menus&quot;) .then((res) =&gt; &#123; // if(rea.data) console.log(res.data.meta.status); if (res.data.meta.status == 200) &#123; this.menu = res.data.data; console.log(this.menu); &#125; &#125;) .catch((err) =&gt; console.log(err)); &#125;, 5.5.3 渲染到页面1&lt;el-submenu v-for=&quot;item in menu&quot; :key=&quot;item.id+&#x27;&#x27;&quot; :index=&quot;item.id&quot;&gt; :index&#x3D;”item.id” ：表示动态数据 :key+’’ 因为index泵为数字，所以+‘’转换为字符 1&lt;el-menu background-color=&quot;#545c64&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#ffd04b&quot; @open=&quot;handleOpen&quot; @close=&quot;handleClose&quot; unique-opened :collapse=&quot;isCollapse&quot; &gt; &lt;el-submenu :index=&quot;item.id + &#x27;&#x27;&quot; v-for=&quot;item in menu&quot; :key=&quot;item.id&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123; item.authName &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item v-for=&quot;item2 in item.children&quot; :index=&quot;item2.id + &#x27;&#x27;&quot; :key=&quot;item2.id&quot; &gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123; item2.authName &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; 六、首页路由重定向6.1 定义组件welcome 6.2 在index中设置作为子页面 1&#123; path: &#x27;/index&#x27;, name: &#x27;index&#x27;, component: index, redirect:&#x27;/welcome&#x27;, //打开时重定向到welcome children:[ &#123; path:&#x27;/welcome&#x27;, components:welcome &#125; ] //子路由 &#125;, 6.3 在index相应区域通过下面标签引入 1&lt;router-view&gt;&lt;/router-view&gt; 出错点：1Cannot read property &#x27;$createElement&#x27; of undefined 其实就是路由配置里的component，要记住是component，不是components,就这么简单 1&#123; path: &#x27;/index&#x27;, component: index, redirect:&#x27;/welcome&#x27;, children:[ &#123; path:&#x27;/welcome&#x27;, component:welcome &#125; ] &#125;, 七、侧边栏路由链接7.1 router属性 点击后会跳转到相应index的地方 但是以ID跳转不合适，所以改为以path为依据 同时前面加上斜线，即 1:index=&quot;&#x27;/&#x27;+item.path&quot; 注意是二级菜单 八、用户管理模块8.1 用户列表 8.1.1 新建users界面 8.1.2 index.js导入1import users from &#x27;@/components/users/users&#x27;&#123; path: &#x27;/index&#x27;, component: index, redirect:&#x27;/welcome&#x27;, children:[ &#123; path:&#x27;/welcome&#x27;, component:welcome &#125;, &#123; path:&#x27;/users&#x27;, component:users &#125; ] &#125;, 注意：path要和上面:index的一致 8.2 绘制用户列表8.2.1 头部面包屑 1&lt;el-breadcrumb separator-class=&quot;el-icon-arrow-right&quot;&gt; &lt;el-breadcrumb-item :to=&quot;&#123; path: &#x27;/&#x27; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;用户管理&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;用户列表&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; 8.2.2 面板 8.2.3 搜索框1&lt;div class=&quot;search&quot;&gt; &lt;div style=&quot;margin-top: 15px&quot;&gt; &lt;el-input placeholder=&quot;请输入内容&quot; v-model=&quot;input3&quot; class=&quot;input-with-select&quot; &gt; &lt;el-button slot=&quot;append&quot; icon=&quot;el-icon-search&quot;&gt;&lt;/el-button&gt; &lt;/el-input&gt; &lt;/div&gt; &lt;/div&gt; 布局 1&lt;el-row&gt; &lt;el-col :span=&quot;7&quot;&gt; &lt;div style=&quot;margin-top: 15px&quot;&gt; &lt;el-input placeholder=&quot;请输入内容&quot; v-model=&quot;input3&quot; class=&quot;input-with-select&quot; &gt; &lt;el-button slot=&quot;append&quot; icon=&quot;el-icon-search&quot;&gt;&lt;/el-button&gt; &lt;/el-input&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;4&quot;&gt;&lt;/el-col&gt; &lt;/el-row&gt; ：span每行元素宽总的是24"},{"title":"vue部分高级特性","path":"posts/4e3b.html","text":"概述文章将讲述指令、混入、高阶组件、函数式组件、@hook、异步组件等内容。如果文中有不当的地方欢迎指正哦！特性以及部分原理自定义指令（directive）除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。有时候我们想对dom进行操作的时候，就可以使用自定义指令，比如设置标题样式并且让标题一直固定在页面上方，可以使用全局注册或者局部注册。然后你可以在模板中任何元素上使用新的 v-title property。 12345678910111213141516171819202122232425262728293031323334353637383940414243//全局注册&lt;div id=&quot;app&quot;&gt; &lt;div v-title&gt;hello world&lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.directive(&#x27;title&#x27;, &#123; inserted: function (el) &#123; console.log(el) el.style.position = &#x27;fixed&#x27; el.style.top = &#x27;50px&#x27; el.style.left = &#x27;48%&#x27; el.style.color = &#x27;#409EFF&#x27; &#125; &#125;) new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;hello!&#x27; &#125; &#125;)&lt;/script&gt;&lt;style&gt; #app&#123; height: 1000px &#125; &lt;/style&gt;//局部注册 new Vue(&#123; el: &#x27;#app&#x27;, directives: &#123; title: &#123; inserted: function (el) &#123; console.log(el) el.style.position = &#x27;fixed&#x27; el.style.top = &#x27;50px&#x27; el.style.left = &#x27;48%&#x27; el.style.color = &#x27;#409EFF&#x27; &#125; &#125; &#125; &#125;) irective钩子函数参数指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM。 binding：一个对象，包含以下 property： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive&#x3D;”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive&#x3D;”1 + 1” 中，表达式为 “1 + 1”。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 我们打印下函数传入的参数，其实简单来说就是el就是绑定dom元素，binging指令：后所携带的具体内容，VNode就当还未生成的节点好了。 1234567891011&lt;div v-title:arr=&quot;message&quot;&gt;hello world&lt;/div&gt;Vue.directive(&#x27;title&#x27;, &#123; inserted: function (el, binding, vnode) &#123; console.log(el, binding, vnode) el.style.position = &#x27;fixed&#x27; el.style.top = &#x27;50px&#x27; el.style.left = &#x27;48%&#x27; el.style.color = &#x27;#409EFF&#x27; &#125; &#125;)复制代码 钩子函数一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用 unbind：只调用一次，指令与元素解绑时调用。 我们可以测试下钩子函数的调用时机： 1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;txt&quot; v-title:data=&quot;sum&quot;&gt;value: &#123;&#123;sum&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; sum: 0 &#125;, directives: &#123; title: &#123; bind: (el, bind) =&gt; &#123; console.log(bind.value, &#x27;a&#x27;) &#125;,// 第一次绑定元素时调用 inserted: (el, bind) =&gt; &#123; console.log(bind.value, &#x27;b&#x27;) &#125;,// 当被绑定的元素插入到 DOM 中时…… update: (el, bind) =&gt; &#123; console.log(bind.value, &#x27;c&#x27;) &#125;,// 所在组件VNode发生更新时调用 componentUpdated: (el, bind) =&gt; &#123; console.log(bind.value, &#x27;d&#x27;) &#125;, // 指令所在组件的 VNode 及其子 VNode 全部更新后调用 unbind: (el, bind) =&gt; &#123; console.log(bind.value, &#x27;e&#x27;) &#125; // 只调用一次，指令与元素解绑时调用 &#125; &#125;, mounted() &#123; console.log(this.sum, &#x27;???&#x27;) let timer = setInterval(() =&gt; &#123; this.sum++ &#125;, 200) setTimeout(() =&gt; &#123; clearInterval(timer) &#125;, 3000) &#125; &#125;)&lt;/script&gt; 指令大致原理在页面渲染的过程中，分别有创建(create)、激活(avtivate)、更新(update)、移除(remove)、销毁(destroy)，在这些过程中，框架在每个时段都会调用相应的钩子函数，这些hooks中一部分的函数就包含了我们的指令。源码部分我了解的不多，给大家推荐一篇vue指令原理相关博文www.cnblogs.com/gerry2019/p… 混入官方是这样定义的：混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。其实就是vue实例的一个复用。实用场景：公共组件或者功能，例如获取用户白名单、菜单返回、公共基础table。 值得注意的点： 当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。比如，数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时以组件数据优先。 同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 1234567891011121314151617181920212223var mixin = &#123; data: function () &#123; return &#123; message: &#x27;hello&#x27;, foo: &#x27;abc&#x27; &#125; &#125;&#125;new Vue(&#123; mixins: [mixin], data: function () &#123; return &#123; message: &#x27;goodbye&#x27;, bar: &#x27;def&#x27; &#125; &#125;, created: function () &#123; console.log(this.$data) // =&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125; &#125;&#125;)复制代码 高阶组件一个函数接受一个组件为参数，返回一个包装后的组件。其实在vue中，组件可以当做一个函数，那从本质上来说，高阶组件就是高阶函数（JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数） 高阶函数举例一个最简单的高阶函数计算次方 12345 function pow(x, y, f)&#123; return f(x, y); &#125; pow(3, 3, Math.pow)复制代码 在es6中也有很多高阶函数，如map、reduce、filter。 高阶组件的例子1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id=&quot;app&quot;&gt; &lt;hoc&gt;&lt;/hoc&gt;&lt;/div&gt;&lt;script&gt; const view = &#123; template: `&lt;span&gt; &lt;span&gt;test hoc ...&lt;/span&gt; &lt;/span&gt;`, props: [&quot;result&quot;, &quot;loading&quot;], &#125;; const test = (wrapped, txt = &#x27;hello&#x27;) =&gt; &#123; return &#123; render(h) &#123; const args = &#123; props: &#123; result: this.result, loading: this.loading, &#125;, &#125;; const wrapper = h(&quot;div&quot;, [ h(wrapped, args), &#x27;loading&#x27; ]); return wrapper &#125; &#125; &#125; const hoc = test(view, &#x27;hui&#x27;) console.log(hoc); new Vue(&#123; el: &#x27;#app&#x27;, components: &#123; hoc &#125;, data: &#123; sum: 0 &#125; &#125;)&lt;/script&gt;复制代码 值得注意的点 高阶组件(HOC)应该是无副作用的纯函数，且不应该修改原组件,就是组件是一个新的组件，不会对原组件做修改。 高阶组件(HOC)不关心你传递的数据(props)是什么，并且被包装组件(WrappedComponent)不关心数据来源 高阶组件(HOC)接收到的 props 应该透传给被包装组件(WrappedComponent) 在高阶组件中渲染函数向子组件中传递作用域插槽时候要注意上下文 动态组件 异步组件 递归组件动态组件可以在同组件之间进行动态切换， 动态切换可以通过 Vue 的 元素加一个特殊的 is attribute 来实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Dynamic Components Example&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vue&quot;&gt;&lt;/script&gt; &lt;style&gt; .tab-button &#123; padding: 6px 10px; border-top-left-radius: 3px; border-top-right-radius: 3px; border: 1px solid #ccc; cursor: pointer; background: #f0f0f0; margin-bottom: -1px; margin-right: -1px; &#125; .tab-button:hover &#123; background: #e0e0e0; &#125; .tab-button.active &#123; background: #e0e0e0; &#125; .tab &#123; border: 1px solid #ccc; padding: 10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;dynamic-component-demo&quot; class=&quot;demo&quot;&gt; &lt;button v-for=&quot;tab in tabs&quot; v-bind:key=&quot;tab&quot; v-bind:class=&quot;[&#x27;tab-button&#x27;, &#123; active: currentTab === tab &#125;]&quot; v-on:click=&quot;currentTab = tab&quot; &gt; &#123;&#123; tab &#125;&#125; &lt;/button&gt; &lt;component v-bind:is=&quot;currentTabComponent&quot; class=&quot;tab&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&quot;tab-home&quot;, &#123; template: &quot;&lt;div&gt;Home component&lt;/div&gt;&quot; &#125;); Vue.component(&quot;tab-posts&quot;, &#123; template: &quot;&lt;div&gt;Posts component&lt;/div&gt;&quot; &#125;); Vue.component(&quot;tab-archive&quot;, &#123; template: &quot;&lt;div&gt;Archive component&lt;/div&gt;&quot; &#125;); new Vue(&#123; el: &quot;#dynamic-component-demo&quot;, data: &#123; currentTab: &quot;Home&quot;, tabs: [&quot;Home&quot;, &quot;Posts&quot;, &quot;Archive&quot;] &#125;, computed: &#123; currentTabComponent: function() &#123; return &quot;tab-&quot; + this.currentTab.toLowerCase(); &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;复制代码 异步组件在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。 123456789Vue.component(&#x27;async-example&#x27;, function (resolve, reject) &#123; setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: &#x27;&lt;div&gt;I am async!&lt;/div&gt;&#x27; &#125;) &#125;, 1000)&#125;)复制代码 在vue-cli中在使用异步组件 12const first =()=&gt;import(/* webpackChunkName: &quot;group-foo&quot; */ &quot;../components/first.vue&quot;);复制代码 vue中部分钩子函数(@hook)Vue 实例同时在其事件接口中提供了其它的方法。我们可以： 通过 $on(eventName, eventHandler) 侦听一个事件 通过 $once(eventName, eventHandler) 一次性侦听一个事件 通过 $off(eventName, eventHandler) 停止侦听一个事件 你通常不会用到这些，但是当你需要在一个组件实例上手动侦听事件时，它们是派得上用场的。它们也可以用于代码组织工具。例如，你可能经常看到这种集成一个第三方库的模式。官网提供一个案例：在不使用beforeDestroy钩子清picker 123456789101112131415161718192021222324//案例一mounted: function () &#123; var picker = new Pikaday(&#123; field: this.$refs.input, format: &#x27;YYYY-MM-DD&#x27; &#125;) this.$once(&#x27;hook:beforeDestroy&#x27;, function () &#123; picker.destroy() &#125;)&#125;//案例二//在父组件在子组件渲染阶段做一些操作&lt;child @hook:mounted=&quot;handle&quot; @hook:beforeUpdated=&quot;xxx&quot; @hook:updated=&quot;xxx&quot;/&gt;method () &#123; handle() &#123; // do something... &#125;&#125;,复制代码 在vue生命周期中周期都有对应的钩子函数 插件插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种： 添加全局方法或者 property。如：vue-custom-element 添加全局资源：指令&#x2F;过滤器&#x2F;过渡等。如 vue-touch 通过全局混入来添加一些组件选项。如 vue-router 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router 自定义插件 12345678910111213141516171819202122232425262728MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或 property Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive(&#x27;my-directive&#x27;, &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) // 3. 注入组件选项 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125;复制代码 作者：仅九链接：https://juejin.cn/post/6985035199432097823"},{"title":"标准分类的IP地址","path":"posts/afd3.html","text":"一、标准分类的IP地址 每台计算机都要有IP地址，有了IP地址才能互相通信，计算机之间只能互相认识IP地址。IP地址可以理解为计算机的×××号。 （一）二进制和十进制数转换(★记住) 11111111→128＋64＋32＋16＋8＋4＋2＋1＝240＋15＝255 举例： 10100000→128＋32＝160 反过来160＝128＋32→10100000 10011000→128＋16＋8＝152 01000100→64＋4＝68 （二）IP地址的表示 IPv4地址采用32位的二进制数表示，表示形式为： ... (其中*表示1个二进制位，共4组，每组8位二进制数) 比如：11000000.10101000.00000101.00010111 写成十进制数就是：X.X.X.X（其中X表示0—255之间的一个十进制数），比如： 192.168.5.23、218.85.157.99、218.85.152.99 是正确的IP地址。 156.56.45、256.45.345.34、56.0.0.1.7 是错误的IP地址。 （三）IP地址的分类(记住) IP地址分为A类、B类、C类、D类、E类，规定如下： A类：网络位8位，主机位24位，网络前导位为0，即： 0*******...******** 即1.0.0.0—127.255.255.255 网络位00000000不可用，网络位01111111(127)表示回送地址，指本地机。 B类：网络位16位，主机位16位，网络前导位为10，即： 10******...******** 即128.0.0.0—191.255.255.255 C类：网络位24位，主机位8位，前导位为110，即： 110*****...******** 即192.0.0.0—223.255.255.255 D类：组播地址，前导位为1110，即： 1110****...******** 即224.0.0.0—239.255.255.255 E类：保留地址，前导位为11110，即： 11110***...******** 即240.0.0.0—247.255.255.255 其中A类、B类、C类IP地址可供普通用户使用。 （四）私有IP地址(记住) IP地址分为公有IP地址和私有IP地址(也称外部IP地址和内部IP地址，或称全局IP地址和专用IP地址)，在互联网中，公有IP地址可以被外网访问，私有IP地址仅用于内部网络使用，不能被外网访问。私有IP地址如下： A类：10.0.0.0—10.255.255.255 B类：172.16.0.0—172.31.255.255 C类：192.168.0.0—192.168.255.255 （五）IP地址的相关规定(记住) 1.网络地址、主机地址、广播地址 IP地址由“网络位+主机位”组成。 网络地址：主机位全0 主机地址：网络位全0 直接广播地址：主机位全1 举例：IP地址 201.161.20.18 的网络地址是201.161.20.0，主机地址是0.0.0.18，直接广播地址为201.161.20.255。 2.可用的IP地址 主机位不可全0或全1（全0是网络地址，全1是广播地址） 在一个网段内，最小的可用IP地址是“网络地址+1”，最大的可用IP地址是“广播地址-1”。 举例：192.168.1.0～192.168.1.255网段中，可用的IP地址是：192.168.1.1～192.168.1.254 受限广播地址(或称为“有限广播地址”) 32位全1的IP地址(255.255.255.255)表示受限广播地址。 受限广播地址和直接广播地址的区别，举例：255.255.255.255和192.168.5.255。 交换机转发广播，路由器不转发广播。 二、子网掩码 子网掩码用来区别网络位和主机位，用1表示网络位，用0表示主机位。比如： A类IP地址的掩码：11111111.00000000.00000000.00000000 写成十进制 255.0.0.0 也可以用&#x2F;8来表示，表示前8位是网络位，比如：10.3.3.3&#x2F;8 B类IP地址的掩码：11111111.11111111.00000000.00000000 写成十进制 255.255.0.0 也可以用&#x2F;16来表示，表示前16位是网络位，比如：172.16.7.6&#x2F;16 C类IP地址的掩码：11111111.11111111.11111111.00000000 写成十进制 255.255.255.0 也可以用&#x2F;24来表示，表示前24位是网络位，比如：192.168.5.8&#x2F;24 子网掩码为255.255.255.255表示本网段只有1个IP地址，举例：电信运营商动态分配给用户的IP地址110.80.191.243和子网掩码255.255.255.255。 三、划分子网的三级网络结构 将一个大的网络划分成几个较小的子网，变成“网络位+子网位+主机位”的三级结构。 （一）子网掩码的计算(★记住) 10000000→128 (借1位) 11000000→128＋64＝192 (借2位) 11100000→128＋64＋32＝224 (借3位) 11110000→128＋64＋32＋16＝240 (借4位) 11111000→128＋64＋32＋16＋8＝248 (借5位) 11111100→128＋64＋32＋16＋8＋4＝252 (借6位) 11111110→128＋64＋32＋16＋8＋4＋2＝254 (借7位) 11111111→128＋64＋32＋16＋8＋4＋2＋1＝255 (借8位) （二）子网划分计算 向主机位借1位可以划分成2个子网，借2位划分成4个子网，借3位划分成8个子网，如下： 28＝256，27＝128，26＝64，25＝32，24＝16，23＝8，22＝4，21＝2 （三）举例 举例1：172.17.0.3&#x2F;19子网掩码是多少 (借3位) 子网掩码11111111.11111111.11100000.00000000 即255.255.224.0 举例2：192.168.6.7&#x2F;26子网掩码是多少 (借2位) 子网掩码11111111.11111111.11111111.11000000 即255.255.255.192 举例3：IP地址172.16.37.95，子网掩码为255.255.224.0，写出网络地址、主机地址和广播地址。 解答：224表示借3位，172.16.37.95→172.16.00100101.95； 网络地址：172.16.00100000.0→172.16.32.0 (主机位全0) 主机地址：0.0.00000101.95→0.0.5.95 (网络位全0) 广播地址：172.16.00111111.255→172.16.63.255 (主机位全1) 练习：写出以下IP地址的网络地址、主机地址和广播地址 172.16.99.8&#x2F;255.255.240.0 (提示：172.16.01100011.8) 192.168.3.72&#x2F;255.255.255.192 (提示：192.168.3.01001000) 10.33.4.5&#x2F;255.248.0.0 (提示：10.00100001.4.5) 192.168.56.24&#x2F;255.255.255.224 172.17.189.98&#x2F;255.255.252.0 11.254.255.220&#x2F;255.128.0.0 四、考题(记住方法) IP地址为126.150.28.57，子网掩码为255.240.0.0，那么地址类别是（），网络地址是（），直接广播地址是（），受限广播地址是（），主机地址是（），子网内的第一个可用IP地址是（），子网内的最后一个可用IP地址是（） 解答： 126.150.28.57&#x2F;255.240.0.0→126.10010110.28.57 地址类别是：A类 网络地址是：126.144.0.0 (主机位全0) 直接广播地址是：126.159.255.255 (主机位全1) 受限广播地址是：255.255.255.255 主机地址是：0.6.28.57 (网络位全0) 子网内的第一个可用IP地址是：126.144.0.1 (网络地址+1) 子网内的最后一个可用IP地址是：126.159.255.254 (广播地址-1)"},{"title":"计算机网络--重传时间计算","path":"posts/9a9f.html","text":"我们都知道，TCP发送方在规定时间内没有收到确认就要重传已发送的报文段（里面有一个超时计数器），这个逻辑很简单，但是这个超时计数器的值每次都是不一样的，也就是说：重传时间的选择是不一样的，它是如何确定的呢？？？ TCP下层是互联网环境，发送的报文段可能只经过一个高速率的局域网，也可能经过多个低速率的网络，并且每个IP数据报所选择的路由还可能不同。如果把超时重传时间设置太短，就会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传时间设置的太长，那么网络空闲时间会增大，极大的降低了网络的效率 到底应该设置为多大呢？？？？ TCP采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间RTT。TCP保留了RTT的一个加权平均往返时间RTTs（这又成为平滑的往返时间，S表示Smoothed。因为进行的是加权平均，因此获得的结果更加平滑，也就是让我们计算出的结果更加合理）。每回的第一次测量到RTT样本时，RTTs值就取为所测量到的RTT样本值，但以后每次测量到一个新的RTT样本，就按下面的公式重新计算一次RTTs： 在上式中：（阿尔法 的值介于0到1，若很接近0，则表示旧的RTTs值和新的RTTs值相比变化不大，也就是说，新的RTT样本不太影响RTTs; 若很接近1，则表明新的RTTs值，受当前采集的RTT样本影响较大，跟上次的RTTs差距大） RFC 2988：推荐的阿尔法值为1&#x2F;8,也就是0.125 （这种方式得出的值更为平滑） 显然：超时计数器设置的超时重传时间RTO（Retransmission Time-Out）应略大于上面计算的结果。同样的： RFC 2988：建议使用下面的公式计算RTO： RTTd是RTT的偏差的加权平均值，与RTTs和新的RTT样本之差有关。RFC 2988建议这样计算RTTd。当第一次测量时，RTTd值取为RTT样本值的一半。在以后的测量中，则使用下式计算加权平均RTTd： 这里的（贝塔）是一个小于1的系数，它的推荐值是1&#x2F;4，即就是0。125 好了，通过上面这些东西：我们就可以求出超时计数器所要设置的时间问题了，但是，但是，但是，新的问题也来了？？？？ 发送一个报文段，设定的重传时间到了，还没有收到确认。于是重传报文段，经过一段时间后：收到了确认报文段。 现在的问题是：如何判定此报文段是对先发送的报文段的确认，还是对后来重传的报文段的确认？？？由于重传的报文段和原来的报文段完全一样，所以源主机在接受到确认后，无法做出正确的判断，而正确的判断对确定加权平均RTTs的值关系很大。 1，若收到的是对重传报文段的确认，但却被源主机当作是对原来报文段的确认，则计算出的RTTs和超时重传时间RTO就会偏大。若后面再发送的报文段又是经过重传后才收到的确认报文段，则RTO这个时间会越来越长。直接影响效率 2，若收到的是对原来的报文段的确认，但被当作是对重传报文段的确认，则由此计算出的RTTs和RTO都会偏小，这样就会导致过多的重传，使的RTO越来越小 根据以上所说：Karn提出了一个算法：在计算加权平均RTTs时，只要报文段重传了，就不采用其往返时间样本。这样得出的加权平均RTTs和RTO就相对比较准确了。 但是，但是，要是出现这样的情况呢？？：报文段的时延突然增大了很多。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据Karn算法，不考虑重传的报文段的往返时间样本。这样：超时重传时间就无法更新。 因此：要对Karn算法进行修正：方法是：报文段每重传一次，就把超时冲传时间RTO增大一些。典型的做法是：取新的重传时间为2倍的旧的重传时间。当不再发生报文段的重传时，才根据上面给出公式计算超时重传时间。。。。 转自;https://blog.csdn.net/msdnwolaile/article/details/51227491"},{"title":"后端框架学习-Django","path":"posts/9108.html","text":"基本介绍Django 是一个由 Python 编写的一个开放源代码的 Web 应用框架。 使用 Django，只要很少的代码，Python 的程序开发人员就可以轻松地完成一个正式网站所需要的大部分内容，并进一步开发出全功能的 Web 服务 Django 本身基于 MVC 模型，即 Model（模型）+ View（视图）+ Controller（控制器）设计模式，MVC 模式使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。 MVC 优势： 低耦合 开发快捷 部署方便 可重用性高 维护成本低 … Python 加 Django 是快速开发、设计、部署网站的最佳组合。 特点 强大的数据库功能 自带强大的后台功能 优雅的网址 MVC 与 MTV模型MVC 模型MVC 模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 MVC 以一种插件式的、松耦合的方式连接在一起。 模型（M）- 编写程序应有的功能，负责业务对象与数据库的映射(ORM)。 视图（V）- 图形界面，负责与用户的交互(页面)。 控制器（C）- 负责转发请求，对请求进行处理。 简易图： 用户操作流程图： MTV 模型Django 的 MTV 模式本质上和 MVC 是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django 的 MTV 分别是指： M 表示模型（Model）：编写程序应有的功能，负责业务对象与数据库的映射(ORM)。 T 表示模板 (Template)：负责如何把页面(html)展示给用户。 V 表示视图（View）：负责业务逻辑，并在适当时候调用 Model和 Template。 除了以上三层之外，还需要一个 URL 分发器，它的作用是将一个个 URL 的页面请求分发给不同的 View 处理，View 再调用相应的 Model 和 Template，MTV 的响应模式如下所示： 简易图： 用户操作流程图： 解析： 用户通过浏览器向我们的服务器发起一个请求(request)，这个请求会去访问视图函数： a.如果不涉及到数据调用，那么这个时候视图函数直接返回一个模板也就是一个网页给用户。 b.如果涉及到数据调用，那么视图函数调用模型，模型去数据库查找数据，然后逐级返回。 视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。 创建项目使用命令行创建项目1django-admin startproject 项目名称 使用 Pycharm 创建项目 1file ---&gt; new project ---- 选择Django ---&gt; 配置路径和项目名称 ---&gt; 配置环境(默认用系统环境) ----&gt; 点击create(完成创建) 项目目录介绍 1234567|---mysite # 项目的/目录 |---mysite # 项目目录 |---__init__.py |---settings.py # 配置文件 |---urls.py # 路由系统 ===&gt; url与视图的对应关系 |---wsgi.py # runserver命令就使用wsgiref模块做简单的web server |---manage.py # 管理文件 创建应用 使用命令行模式创建应用 在 Terminal 中输入 python manage.py startapp 应用名: 使用 Pycharm 创建应用 注意：使用命令行创建的应用，一定要在 settings.py–&gt;INSTALLED_APPS 中加入你的应用名字进行注册, 使用Pycharm创建的应用则不用。 认识应用结构 运行项目 使用命令行运行项目： 12python3 manage.py runserver manage.py runserver 80 # 指定端口 注意：要在 manage.py 同级目录执行命令。 Pycharm 启动项目 点击右上角的绿色的三角按钮。 如需更改配置信息，请下拉选择 edit configurations，进行配置。 配置完以上信息之后，直接按 Ctrl+shift+F10 运行一下 manage.py 文件。 出现如下结果，表示配置成功。 创建项目django-admin startproject + 项目名称 启动服务（测试用，前台启动）python3 manage.py runserver (+端口号&#x2F;default:8000)python3 manage.py runserver 0.0.0.0:8000 关闭服务在终端crtl+csudo lsof -i:8000 -&gt;kill -9ubuntu 启动应用python manage.py startapp 列出所有的命令python3 manage.py 生成数据库迁移文件python manage.py makemigrations 执行数据库迁移python manage.py migrate 进入 Django Shellpython manage.py shell 创建adminpython manage.py createsuperuser 清理已过期Sessionspython manage.py clearsessions 生成requirements.txt； pip freeze &gt; requirements.txt 创建内存表python manage.py createcachetable manage.py 包含项目管理的子命令项目同名文件夹init:python包的初始化文件wsgi.py:WEB网关的配置文件，正式启动django时才需要用到urls.py:项目主路由配置-HTTP请求进入Django，有限调用settings.py:项目的配置文件-包含项目启动需要的配置。 settings.py 公有配置和自定义配置 配置项格式例： BASE_DIR &#x3D; ‘xxxx’ 公有配置：Django官方提供的基础配置 自定义配置满足命名规则，并尽量个性化 项目的绝对路径 BASE_DIR &#x3D; Path(file).resolve().parent.parent 启动模式：True调试模式： 检测代码改动后，立即重启服务 报错后提供一个 False正式启动模式、上线模式 DEBUG &#x3D; True 请求Host头,只处理请求头在在列表中的请求，过滤一些请求，debug &#x3D; 1在调试模式下默认接收127.0.0.1和localhost两个值。局域网内部访问时需要把局域网IP加上，一旦不为空就必须都配置上 ALLOWED_HOSTS &#x3D; [] 主路由文件位置： ROOT_URLCONF &#x3D; ‘hworld.urls’ 语言配置： LANGUAGE_CODE &#x3D; ‘en-us’（zh-Hans） 时区： TIME_ZONE &#x3D; ‘UTC’（Asia&#x2F;Shanghai） URL统一资源定位符（Uniform Resource Locator） protocal(协议)：&#x2F;&#x2F;hostname(主机)[:port(端口)]&#x2F;path(路由)[?query(查询字符串)][#fragment(锚点)] 协议http；https（加密，安全的https）；file，本地磁盘协议（file：&#x2F;&#x2F;&#x2F;） hostname:依靠DNS解析为IP 端口：默认http为80端口 路由地址 查询字符串：？menuld&#x3D;634898&amp;version&#x3D;AID9089 主要用于给动态网页传递参数，样式：？参数&#x3D;值&amp;参数&#x3D;值 信息片段：#subject锚点，直接定位到网页指定位置 Django如何处理URL?1.从配置文件中根据ROOT_URLCONF找到主路由文件，默认urls.py2.加载urlpatterns变量[包含很多数组的路由]3.依次匹配urlspatterns的path，匹配到第一个合适的中断后续匹配4.匹配成功-返回响应5.匹配失败-返回404 视图函数用于接收浏览器请求并通过HttpResponse对象返回响应的函数。此函数可以接收浏览器请求并根据业务逻辑返回相应的响应内容给浏览器。语法： 12def xxx_view(request[,其他参数…])： return HttpResponse对象 书写位置：项目同名文件夹下&#x2F;views.py 1234from django.http import HttpResponsedef page1_view(request): html = &#x27;&lt;h1&gt;这是一个页面&lt;/h1&gt;&#x27; return HttpResponse(html) 路由配置 path函数from django.urls import pathpath(route,views,name &#x3D; None) route:字符串类型，匹配的请求路径 views：指定路径所处理的视图处理函数的名称 name：地址别名 path转化器 path转换器&lt;转换器类型:自定义名&gt;作用：若转换器类型匹配到对应类型的数据，则将数据按照关键字传参的方式传递给视图函数 path(‘page&#x2F;int:page‘,views.xxx) 转换器： str：匹配除了’&#x2F;‘之外的非空字符串 int：int匹配0或任何正整数 slug：匹配任何由ASCII字母或数字以及连字符和下划线组成的短标签 path：匹配非空字段，包括路径分隔符‘&#x2F;’ re_path函数：正则匹配，更加精密的匹配规则re_path(reg,view,name &#x3D; xx)正则表达式为命名分组模式(?Ppattern); HTTP请求1.请求：浏览器通过HTTP协议发送给服务器端的数据2.响应：服务器端接收到请求后做相应的处理后再回复给浏览器端的数据。 12345起始行：方法、路由、协议headers：请求头 K:V请求体(body)：可能为空 请求方法： GET：返回实体主体 HEAD:调试获取报头 POST：向指定资源提交数据进行处理 PUT：更新 DELETE：删除 CONNECT:代理服务器 OPTIONS TRACE：回显，主要用于测试和诊断 Django中的请求：实际就是视图函数的第一个参数，及HttpRequest对象个人理解就是Django预先将请求转变为了对象，将请求内容转变为对象属性。说到底是对报文进行了预处理。 path_info:URL字符串 method：表示HTTP请求方法 GET：拿查询字符串（？后的值），QueryDict查询字典的对象 POST：拿POST表单里的数据，即用户提交的数据，QueryDict查询字典的对象 FILES：类似于字典的对象，拿文件 COOKIES session body scheme get_full_path() META:请求头 请求&#x2F;响应123起始行（协议版本 状态码）响应头(K:V)响应体body 响应状态码： 200 请求成功 500 内部服务器错误 301 永久重定向 302 临时重定向 404 请求的资源不存在 分类： 1**，收到请求，需要继续执行操作 2**，成功，操作被成功接收并处理 3**，重定向 4**，客户端错误 5**，服务器错误 Django的响应对象 HttpResponse(content &#x3D; 响应体，content_type &#x3D; 响应体数据类型default：html，status &#x3D; 状态码，default：200)作用：向客户端浏览器返回响应，同时携带响应体内容。 常用Content_Type ‘test&#x2F;html’ …… GET请求和POST请求统一由视图函数接收，因此一定是需要隔离业务逻辑 12345678910111213141516171819202122232425if request.method == &#x27;GET&#x27;: 处理GET业务逻辑elif request.method ==&#x27;POST&#x27;: 处理POST的业务逻辑else: 其他业务逻辑````**GET处理：**一般用于向服务器获取数据。能够产生GET请求的场景：+ 浏览器地址栏输入URL并回车+ &lt;a href = &quot;地址？参数=值&amp;参数=值&quot;\\&gt;+ form表单中的method为getGET请求方法中，如果有数据需要传递给服务器，通常会使用查询字符串传递。【注意不要传递敏感数据】URL:http://127.0.0.1:8000/page1\\?a=100&amp;b=200服务器端接收参数获取客户端请求GET请求提交的数据：```pythonrequest.GET[&#x27;参数名&#x27;]request.GET.get(&#x27;参数名&#x27;,&#x27;默认值&#x27;)request.GET.getlist(&#x27;参数名&#x27;) 如果有传递多个值，则参数对应的应该是一个列表，需要使用getlist方法取出所有值，get方法只能取出最后一个值。应用场景：问卷调查的复选框 POST处理一般用于向服务器提交大量&#x2F;隐私数据通过表单 1234&lt;form method = &#x27;post&#x27; action = &#x27;/login&#x27;&gt; 姓名：&lt;input type = &#x27;text&#x27; name = &#x27;username&#x27;&gt; &lt;input type = &#x27;submit&#x27; value = &#x27;登录&#x27;&gt;&lt;/form&gt; CSRF验证问题本身是django的防御措施，防御CSRF攻击问题，会阻止POST，暂时关闭：settings.py》注释django.middleware.csrf.CsrfViewMiddleware Django的设计模式传统的MVC Mode-View-Controller（模型-视图-控制器）模式。特点：低耦合 M模型层：主要用于对数据库层的封装 V视图层：用于给用户展示结果（WHAT + HOW显示什么，怎么显示） C控制层：用于处理请求、获取数据、返回结果 Django：MTV模式把MVC的V拆成了两层，并且弱化C层为路由文件。 M模型层：与MVC相同 T模板层：Template，专门负责html相关事情（HOW） V视图层：核心，负责接收请求，获得结果，返回结果。 在该模式下依然存在控制层C，即主路由 Django模板层模板层创建模板：根据字典数据动态变化的html网页，根据视图中传递的字典数据动态生成相应的html页面模板配置： 创建模板文件夹 &lt;项目名&gt;&#x2F;templates 在settings.py中TEMPLATE配置项 BACKEND：指定模板引擎 DIRS：模板的搜索目录（可以是一个或多个） APP_DIRS：是否在应用中的templates文件夹中搜索末班文件 OPTIONS：有关模板的选项 主要需要修改的：DIRS： ‘DIRS’:[os.path.join(BASE_DIR,’templates’)] 模板加载方案1： 1234567from django.template import loader1.通过loader加载模板t = loader.get_template(&quot;模板文件名&quot;)2.将t转化为HTML字符串html = t.render(字典数据)3.用响应对象将转换的字符串内容返回给浏览器return HttpResponse(html) 模板加载方案2：使用render直接加载并且响应模板。在视图函数中 12from django.shortcuts import renderreturn render(request,&#x27;模板文件名&#x27;,字典数据) 视图层与模板层之间的交互 视图函数中可以将Python变量封装到字典中传递到模板中。 123456def xxx_view(request): dic = &#123; k1: v1, k2: v2 &#125; return render(request, &#x27;xxx.html&#x27;, dic) 模板中使用的语法来调用视图传进来的变量。 模板的变量能传递到模板中的变量类型：str,int,list,tuple,dict,func,obj 在模板中使用变量的语法： 模板层的标签作用：将一些服务器端的功能嵌入到模板中，例如流程控制等 语法 123&#123;% 标签 %&#125;…&#123;% 结束标签 %&#125; 例：if标签 123456789&#123;% if 条件表达式 1 %&#125;…&#123;% elif 条件表达式 2 %&#125;…&#123;% elif 条件表达式 3 %&#125;…&#123;% else %&#125;…&#123;% endif %&#125;#！！一定记住要封口 NOTICE!在模板中使用实际括号是无效的语法，如果需要指示优先级，则应该选择嵌套if for标签语法 12345&#123;% for 变量 in 可迭代对象 %&#125; …循环语句&#123;% empty %&#125; …可迭代对象无数据时填充语句&#123;% endfor %&#125; 内置变量forloopforloop.counter:循环的当前迭代（从1开始索引）forloop.counter0:循环的当前迭代（从0开始索引）forloop.revcounter:counter倒序forloop.revcounter0:counter0倒序forloop.first:第一次循环为真‘forloop.last：最后一次循环为真forloop.parentloop：外层循环 模板层过滤器过滤器：在变量输出时对变量的值进行处理可以通过使用过滤器来改变变量的输出显示 语法： 1&#123;&#123;变量|过滤器1：&#x27;参数1&#x27;|过滤器2：&#x27;参数值2&#x27;…&#125;&#125; 常用过滤器： lower：转换为小写 upper：转换为大写 safe：魔人布对变量内的字符串进行html转义 add：将value的值增加n 模板的继承模板继承使父模板内容重用，子模板直接继承父模板的全部内容并可以覆盖父模板中相应的块。 语法——父模板中： 定义父模板中的块block标签 识别出哪些在子模板是允许被修改的 block标签：在父模板中定义，在子模板中覆盖 语法——子模板中： 继承模板extends标签（写在模板第一行） 例如 1&#123;%extend &#x27;base.html&#x27;&#125; 子模板 复写父模板中的内容块 12&#123;block block_name&#125;&#123;% endblock blockname %&#125; 重写的覆盖规则 不重写，按照父模板的效果显示 重写，则按照重写效果显示 注意： 模板继承时，服务器的动态内容无法继承 url反向解析代码中url的位置：1.模板 超链接&lt;a href &#x3D; &gt; form表单 form action 将表单中的数据用POST的方法提交到url 2.视图函数中 - 302跳转 HttpResponseRedirect(‘url’)将用户地址栏中的地址跳转到url 代码中的url书写规范 1.绝对地址：http://127.0.0.1:8000/page/ 2.相对地址： a ‘&#x2F;page&#x2F;1&#x2F;‘浏览器会把当前地址栏的协议、IP和端口加上这个地址 b ‘page&#x2F;1&#x2F;‘没有&#x2F;开头的，浏览器会根据当前url最后一个&#x2F;之前的内容加上该相对地址作为最终访问地址 url反向解析指在视图或模板中，用path定义的别名来动态查找或计算出相应的路由。path： path(route,views,name&#x3D;’别名’) 模板中： 12&#123;% url &#x27;别名&#x27;%&#125;&#123;% url &#x27;别名&#x27; &#x27;参数值1&#x27; &#x27;参数值2&#x27;%&#125; 视图函数中调用reverse方法进行方向解析 12from django.urls import reversereverse(&#x27;别名&#x27;, args=[], kwargs=&#123;&#125;) ex:print(reverse(‘pagen’,args&#x3D;[300]))print(reverse(‘person’,kwargs&#x3D;{‘name’:’xixi’,’age’:18})) 静态文件什么是静态文件：图片、css、js、音频、视频静态文件属于静态请求，不经过视图函数静态文件配置-settings.py 1.静态文件的访问路径，默认’&#x2F;static&#x2F;‘ 2.STATICFILES_DIRS，静态文件在服务器端的存储位置 元组 123STATICFILES_DIRS = （ os.path.join(BASE_DIR, &quot;static&quot;),） 3.方案2通过 1&#123;% static %&#125; 标签访问静态文件 1.加载static- 1&#123;% load static %&#125; 2.使用静态资源- 1&#123;% static&#x27;静态资源路径&#x27; %&#125; 3.样例： 1&lt;img src=&quot;&#123;% static &#x27;images/lena.jpg&#x27; %&#125;&quot;&gt; 应用应用创建每一个应用都是一个MTV创建应用 用manage.py执行startapp python manage.py startapp music 在settings.py的INSTALLED_APPS列表中配置安装此应用 执行创建应用后，应用文件夹下 migrations文件夹：与DB有关 init.py admin.py apps.py models.py:与DB相关 tests.py views.py：视图函数 分布式路由Django中，主路由配置文件可以不处理用户具体路由，主路由配置文件的可以做请求的分发（分布式请求处理）。具体的请求可以由各自的应用来进行处理。主路由匹配前缀，如&#x2F;news&#x2F;，再往下分发到子路由配置。配置分布式路由： 主路由中调用include函数 1http://127.0.0.1:8000/music/index -&gt; path(&#x27;music/&#x27;,include(&#x27;music.urls&#x27;)) 在子路由下创建urls.py，其内部结构与主路由完全一致。 path(‘index&#x2F;‘, views.index_view) 应用下的模板应用内部可以配置模板目录 1.应用下手动创建templates文件夹 2.settings.py中开启应用模板功能 TEMPLATE配置项中的’APP_DIRS’值为True即可、 important：查找模板的顺序：外层templates文件夹-&gt;注册顺序的app内部的templates文件夹解决方法：在应用层的templates下创建嵌套同名子目录，从而在views.py render中使得html获得不一样的路径 模型层及ORM介绍模型层：负责与数据库之间进行通信Django配置mysql 创建数据库mysql 更改settings.py： 123456789DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;mysite3&#x27;, &#x27;USER&#x27;: &#x27;root&#x27;, &#x27;PASSWORD&#x27;: &#x27;123456&#x27;, &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;, &#x27;POST&#x27;: &#x27;3306&#x27; &#125; 什么是模型： 模型是一个Python的类，它是由django.db.models.Model派生出的子类。 一个模型类代表数据库的一张数据表 模型类中每一个类属性都代表数据库中的一个字段 模型是数据交互的接口，是表示和操作数据库的方法和方式。 ORM框架ORM（对象关系映射），是一种程序技术，能够使用类和对象对数据库进行操作，从而避免通过SQL语句操作数据库。 作用 建立模型类和表之间的对应关系，允许我们通过面向对象的方式来操作数据库。 根据设计的模型类生成数据库中的表格。 通过简单的配置就能更换数据库引擎。 优点： 只需要面向对象编程，简化了向数据库编写代码的流程。 实现了数据模型与数据库的解耦，屏蔽了不同数据库操作上的差异。 缺点： 对于复杂业务，使用成本较高 根据对象的操作转换为SQL语句，根据查询结果转化为对象，在映射过程中有性能损失。 映射图：ORM———-&gt;DB类———-&gt;数据表对象——–&gt;数据行属性——–&gt;字段 数据库迁移：迁移是Django同步您对模型所做出的更改（添加字段，删除模型等）到您的数据库模式的方式。 1.生成迁移文件： python manage.py makemigrations生成一个中间文件，并保存在migrations文件夹中 2.执行迁移脚本程序 python manage.py migrate执行迁移程序实现迁移，将每个应用下的migrations目录中的中间文件同步回数据库。 模型类模型类-创建 123from django.db import modelsclass 模型类名(models.Model): 字段名 = models.字段类型（字段选项） 表名实际为 APP名称+类名称小写 模型类-字段类型： BooleanField 数据库类型：tinyint(1) 编程语言中将使用True或False来表示值 在数据库中则使用0或1来表示具体的值 Char 数据库类型：VarChar（Django不支持Char） 注意：必须要指定max_length参数值 DataField() 数据库类型：date 作用：表示日期 参数：三选一+ auto_now:每次保存对象时，自动设置该字段为当前时间（取值：True&#x2F;False）+ auto_now_add:当兑现第一次被创建时自动设置当前时间（取值：True&#x2F;False）+ default:设置当前时间 DataTimeField() 数据库类型：datatime(6)通常用这个，比上面那个精确一些 作用：表示日期和时间 参数：同DataField FloatField() 数据库类型：double 编程语言中和数据库中都使用小数表示值 DecimalField() 数据库类型：decimal(x,y) 编程语言中:使用小数表示该列的值 在数据库中：使用小数 参数（必须有）：max_digits;decimal_places EmailField() 数据库类型：varchar 编程语言和数据库中均使用字符串，但Django含有正则检查。 IntegerField() 数据库类型：Int 编程语言和数据库中使用整数 ImageField() 数据库类型：varchar(100) 作用：在数据库中为了保存图片路径 编程语言和数据库中使用字符串 TextField() 数据库类型：longtext 作用：表示不定长的字符数据 模型类-字段选项：创建列的额外信息 primary_key：设置为True，则为主键，此数据库表不会创建id字段 blank:设置为True，则字段可以为空，控制的是Admin后台的提交，和mysql的null不同 null：设置为True，则该列允许为空 默认为False,需要一个default选项来设置默认值 default：设置该列的默认值 db_index：设置为True，表示为该列增加索引 unique: 唯一索引 db_column：指定列的名称，如果不指定的话则采用属性名作为列名。不给的话字段名就是列名。 verbose_name：设置此字段在admin界面上的显示名称，可以中文化admin界面 好习惯：字段选项【添加或更改】均要执行 模型类-Meta内部类使用Meta类来给**模型(其实就是表的属性)**赋予属性，Meta类下有很多内建的类属性，可对模型类做一些控制。如改表名： 12345678910from django.db import modelsclass 模型类名(models.Model): 字段名 = models.字段类型（字段选项） class Meta: db_table = &#x27;book&#x27; #控制模型类在admin后台显示的名称 verbose_name = &#x27;单数名&#x27; #指定复数形态 verbose_name_plural = &#x27;复数名&#x27; Django对于数据库操作是惰性的，尽量不对数据库进行积极的修改，如设置的default值将不参与表的字段生成，只会参与实际插值。 ORM-创建数据增删改查ORM CRUD核心：模型类.管理器对象 管理器对象每一个models.Model的模型类，都会有一个objects对象被同样继承下来，这个对象叫做管理器对象。数据库的增删改查可以通过管理器实现。 创建数据方案1： MyModel.objects.create(属性1&#x3D;值1，属性2&#x3D;值2,…) 成功：返回创建好的实体对象失败：抛出异常 方案2： 创建MyModel实例对象，并调用save()并保存 123obj = Mymodel(属性 = 值，属性 = 值)obj.属性 = 值obj.save() 需要使用Django Shell python manage.py shell代码每次变化，都需要重启Django Shell ORM查询操作通过管理器对象进行通过MyModel.objects管理器方法调用查询方法方法 all() 用法：MyModel.objects.all() 等价于select * from table 返回值：QuerySet容器对象，类数组对象，内部存放了MyModel实例 如 1&lt;QuerySet [&lt;Book: Python,20.00&gt;, &lt;Book: jango,50.00&gt;, &lt;Book: JQuery,40.00&gt;, &lt;Book: Linux,30.00&gt;, &lt;Book: HTML5,26.00&gt;]&gt; 可以在模型类中定义__str__方法，自定义QuerySet中的输出格式，则输出时能输出格式化字符串。 Django 同样支持方法的串联，以下方法在返回QuerySet后均可使用方法串联，且最终都会按照SQL顺序对数据库进行操作。 print(QuerySet.query)将取得实际的SQL语句。 values(‘字段1’,’字段2’) 等价于select 列1，列2 from xxx 返回：QuerySet，但内部存字典，每一个字典代表一个数据 如： 1&lt;QuerySet [&#123;&#x27;title&#x27;: &#x27;HTML5&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;jango&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;JQuery&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;Linux&#x27;&#125;, &#123;&#x27;title&#x27;: &#x27;Python&#x27;&#125;]&gt; values_list(‘字段1’,’字段2’) 基本同上，但返回元组，使用时需要使用索引 1&lt;QuerySet [(&#x27;HTML5&#x27;,), (&#x27;jango&#x27;,), (&#x27;JQuery&#x27;,), (&#x27;Linux&#x27;,), (&#x27;Python&#x27;,)]&gt; order_by(‘-列’(降序),’列’) 等价于 ORDER BY 返回：QuerySet 如： 1&lt;QuerySet [&lt;Book: jango,50.00&gt;, &lt;Book: JQuery,40.00&gt;, &lt;Book: Linux,30.00&gt;, &lt;Book: HTML5,26.00&gt;, &lt;Book: Python,20.00&gt;]&gt; filter(条件) 语法：MyModel.objects.filter(属性1&#x3D;值1，属性2&#x3D;值2)（,默认是AND查询） 等价于 条件查询 返回值：QuerySet，存放模型实例 exclude(条件) 语法同上 等价于 WHERE NOT 作用：返回不包含此条件的全部数据集 电商取非可以用该语句 get(条件) 容易报错，一定要Try一下 语法：MyModel.objects.get（条件） 作用：返回满足条件的唯一一条数据 说明：该方法只能返回一条数据，直接获得Object 查询结果多于一条则抛出异常；查询结果没有数据则抛出Model.DoesNotExist异常。 查询谓词类属性 + ‘__’ + 谓词定义：做更灵活的条件查询时需要使用查询谓词说明：每一个查询谓词都是一个独立的查询功能 __exact:等值匹配 Author.objects.filter(id_exact&#x3D;1) &lt;&#x3D;&gt; SELECT * FROM Author WHERE ID&#x3D;1 __contains:包含指定值 Author.objects.filter(name__contains&#x3D;’w’)SELECT * FROM Author WHERE name Like ‘%w%’ __startwith:以xxx开始 __endwith:以xxx结束 __gt:大于指定值 __gte:大于等于 __lt:小于 __lte:小于等于 __in:指定范围内 Author.objects.filter(name__in&#x3D;[‘中国’，’美国’]) __range:查询数据是否在指定区间范围内 Author.objects.filter(age__range(35,50))&lt;&#x3D;&#x3D;&gt; SELECT * FROM Author WHERE age BETWEEN 35 AND 50 更新操作1.针对单个数据的修改查(get())-&gt;改：通过对象.属性的方式更改-&gt;保存：对象.save()2.批量更新数据直接调用QuerySet的update(属性&#x3D;值实现批量修改)针对QuerySet来做更改 删除操作1.单个数据删除 查找对应的数据对象 调用该数据对象的delete()方法实现删除 2.批量数据删除 查找QuerySet 调用delete()方法实现删除 3.伪删除操作通过在表里添加一个布尔型字段（is_active），默认是True；执行删除时，将欲删除数据的is_active置为False。注意：使用伪删除时，确保显示数据的地方，均添加了is_active&#x3D;True的过滤查询。 F对象F对象(很适合用于点赞)·········································**F对象实际等价于语句：UPDATE TABLE SET COLUMN&#x3D;TABLE.VALUE+10使用单句的数据库查询语句，Mysql的InnoDB引擎使用行锁，因此F对象的本质是使用了数据库中的锁。 **········································· 1from django.db.models import F 一个F对象代表数据库中某条记录的字段的信息(不直接取出来) 作用：通常对数据库字段值在不获取的情况下进行操作，用于类属性之间的比较 F(‘列名’) 对数据库字段值在不获取的情况下进行操作： 例：需求：将Book表中所有的market_price全部自增10。 该需求原本只能通过循环取出每一个数据后+10再写入实现。 Query的update方法必须结合F对象方法实现使用F语句 1Book.objects.all().update(market_price=F(&#x27;market_price&#x27;)+10) 用于类属性之间的比较： 1Book.objects.filter(market_price_gt=F(&#x27;price&#x27;)+10) Q对象用于进行逻辑或、逻辑非操作时使用 1Book.objects.filter(Q(market_price_lt=35)|Q(price_gt=40)) Q对象能够实现互相间的&amp;与,|或,非,&amp;与非等操作。 聚合查询聚合查询是指对一个表中的一个字段的数据进行部分或全部进行统计查询。分为整表聚合和分组聚合。 整表聚合 聚合函数需要导入 1from django.db.models import * 语法： 1MyModel.objects.aggregate(结果变量名（别名）=聚合函数(&#x27;列&#x27;)) 返回：字典 分组聚合 其实是为了实现Having语句 通过计算查询结果中每一个对象所关联的对象集合，从而得出总计值，为查询集的每一项生成聚合 1QuerySet.annotate(结果变量名（别名）=聚合函数(&#x27;列&#x27;)) 返回：QuerySet 原生数据库操作：11.只用来查询：MyoModel.objects.raw(sql语句，拼接参数) 返回值：RawQuerySet集合对象，不支持方法串联，只支持基本的循环等。 SQL注入问题：使用原生语句，使用拼接参数的方式进行查询能适当避免SQL注入问题。 2.完全跨过模型类操作数据库 导入 1from django.db import connection 用创建cursor类的构造函数创建cursor(游标)对象，为保证在出现异常时能够释放cursor，通常用with来创建操作 12with connection.cursor() as cur: cur.execute(&#x27;执行SQL语句&#x27;,&#x27;拼接参数&#x27;) admin后台管理admin后台用于开发过程中调用和调试，django会搜集所有已注册的模型类，并为这些模型类提供数据管理界面。 后台的创建：1python manage.py createsuperuser 注册自定义模型类 在应用的admin.py导入注册要管理的models类 调用admin.site.register方法进行注册 显示样式是按照models.py中__str__方法显示的。 模型管理器类作用：为后台管理界面添加便于操作的新功能继承于django.contrib.admin里的ModelAdmin类 在应用的admin.py定义模型管理器类 12class XXXXManager(admin.ModelAdmin): …… 绑定注册模型管理器和模型类,使用调用admin.site.register方法的第二个参数 类属性： 123456789101112class XXXXManager(admin.ModelAdmin): #表头 list_display = [&#x27;id&#x27;,&#x27;title&#x27;,&#x27;price&#x27;] #控制list_display哪些字段超链接进修改页 list_display_links = [&#x27;title&#x27;] #添加过滤器 list_filter = [&#x27;id&#x27;] #添加搜索框（模糊查询） search_fields = [&#x27;title&#x27;] #添加可在列表页可编辑的字段，与 #list_display_links字段是互斥的 list_editable = [&#x27;price&#x27;] 关系映射关系映射：一对一，一对多，多对多。 一对一映射创建一对一外键：语法：OneToOneField(类名, on_delete&#x3D;xxx(级联删除：在存在键的前提下的删除规则))on_delete: models.CASCADE：级联删除，只是模拟SQL约束ON DELETE CASCADE，不影响Mysql设置。 models.PROTECT:保护删除，等同于mysql默认的RESTRICT SET_NULL:保留关联数据，设置为NULL SET_DEFAULT:将外键设置为默认值。 创建一对一数据无外键的模型类，和之前相同有外键的模型类： wife &#x3D; Wife.objects.create(name&#x3D;’王夫人’,author &#x3D; author1(类属性名称绑实例))wife &#x3D; Wife.objects.create(name&#x3D;’王夫人’,author_id &#x3D; 1(类属性字段绑值)) 一对一查询 正向查询：从外键查对象 反向查询：从对象查外键 调用反向属性查询到关联的一方 一对多查询核心：正向属性(authors)和反向属性(book_set)在多表上设置外键，关联一表。 创建一对多数据：语法：Foreignkey(“一”的模型类, on_delete&#x3D;xxx(级联删除：在存在键的前提下的删除规则)) 添加数据：先添加“一”，再添加“多”。无外键的模型类，和之前相同有外键的模型类：类似上面 wife &#x3D; Wife.objects.create(name&#x3D;’王夫人’,author &#x3D; author1(类属性名称绑实例))wife &#x3D; Wife.objects.create(name&#x3D;’王夫人’,author_id &#x3D; 1(类属性字段绑值)) 查询数据：正向查询（有显性属性的）：由book查出版社：book.publisher反向查询(使用反向属性)： books &#x3D; pub1.book_set.all()或books &#x3D; Book.objects.filter(publisher&#x3D;pub1) 多对多映射核心：正向属性(authors)和反向属性(book_set)mysql中多对多需要用三张表实现Django中无需手动创建第三张表，Django自动完成 创建字段语法：属性 &#x3D; models.ManyToManyField(MyModel) 创建数据： 1.先创建Author，再关联book author1 &#x3D; Author.objects.create(name&#x3D;’1’)author2 &#x3D; Author.objects.create(name&#x3D;’2’)book1 &#x3D; author1.book_set.create(title &#x3D; ‘1’)#创建author2.book_set.add(book1)#绑定 2.先创建book,再关联author book &#x3D; Book.objects.create(title&#x3D;’p1’)author3 &#x3D; book.authors.create(name&#x3D;”3”)book.authors.add(author1) Cookies和Session会话从打开浏览器访问一个网站，到关闭浏览器结束此次访问，称之为一次会话。HTTP本身是无状态的，导致会话状态难以保持。 Cookies保存在客户端浏览器上的存储空间特点： cookies在浏览器是以键值对的形式进行存储的，键和值都是以ASCII码的形式存储的 存储的数据带有生命周期 cookies的数据是按照域隔离的，不同的域之间无法访问 cookies的内部数据会在每次访问此网站时都会携带到服务器，如果cookies过大会影响访问速度。 存储HttpResponse.set_cookie(key,value&#x3D;’’,max_age&#x3D;None,expires&#x3D;None)-key:cookie的名字-value：cookie的值-max_age：存活相对时间，秒-expires：具体过期时间当不指定max_age和expires时，关闭浏览器时此数据失效。 删除&amp;获取获取：request.COOKIES删除：request.delete_cookie(key) session会话保持-登录流程用户登录-&gt;账号密码传至后端，服务器数据库验证，正确则发放cookie-&gt;后续浏览器将自动把当前域下的cookie都发送至服务器。但浏览器存储不是十分安全，因此引入了session。 session技术实际将数据存在了服务器里，对于不同的浏览器有不同的存储空间，生成空间后，会将一个sessionID返还给浏览器，浏览器会将sessionID存储在Cookies，之后每次返还给服务器。 session是在服务器上开辟一段空间用于保留浏览器和服务器交互时的重要数据。 session初始配置： 1.INSTALLED_APPS:django.contrib.sessions 2.MIDDLEWARE: ‘django.contrib.sessions.middleware.SessionMiddleware’ session的使用：session对象是一个类似于字典的SessionStore类型的对象。 保存session的值到服务器： request.session[‘KEY’] &#x3D; VALUE 获取session的值 value &#x3D; request.session[‘KEY’] value &#x3D; request.session.get(‘KEY’,默认值) 删除session del request.session[‘KEY’] 干预session时间：settings.py里的SESSION_COOKIE_AGE指定cookies中的保存时间，默认两周SESSION_EXPIRE_AT_BROWSER_CLOSE &#x3D; True,关闭浏览器自动清除session，默认FalseSESSION的数据在Django中保存在数据库中，因此需要保证已经执行过了migrate Django session的问题： 1.django session的表是单表设计，且该表数据量不会自动清理，哪怕是已经过期。 2.可以每晚执行python manage.py clearsessions，会自动删除已经过期的session数据。 缓存定义：缓存是一类可以更快的读取数据的介质统称，也指其他可以加快数据读取的存储方式。一般用来存储临时数据，常用介质的是读取速度很快的内存。意义：视图渲染有一定成本，数据库的频繁查询过高；所以对于低频变动的页面可以考虑使用缓存技术，减少实际渲染次数；用户拿到响应的时间成本会更低。场景：1.博客列表页；2.电商商品详情页场景特点：数据变动频率较少 Django中设置缓存：(settings.py) 数据库缓存：将缓存存储在数据库中，尽管存储介质还是数据库，但把一次复杂查询的结果直接存储在表里，可避免重复进行复杂查询，提升效率。 配置方法： 1234567891011CACHES=&#123; &#x27;default&#x27;: &#123; &#x27;BACKEND&#x27;:&#x27;django.core.cache.backends.db.DatabaseCache&#x27;,#引擎 &#x27;LOCATION&#x27;:&#x27;my_cache_table&#x27;,#指定用于缓存的表 &#x27;TIMEOUT&#x27;:300,#缓存时间 &#x27;OPTIONS&#x27;:&#123; &#x27;MAX_ENTRIES&#x27;:300,#最大存储条数 &#x27;CULL_FREQUENCY&#x27;:2,#缓存条数达到最大值时，删除1/x的数据 &#125; &#125;&#125; 缓存到服务器内存中 配置方法： 123456CACHES=&#123; default: &#123; &#x27;BACKEND&#x27;:&#x27;django.core.cache.backends.locmem.LocMemCache&#x27;,#引擎 &#x27;LOCATION&#x27;:&#x27;unique-snowflake&#x27;,#雪花算法内存寻址 &#125;&#125; 将缓存数据存储到本地文件中 配置方法： 1234567CACHES=&#123; default: &#123; &#x27;BACKEND&#x27;:&#x27;django.core.cache.backends.filebased.FileBasedCache&#x27;,#引擎 &#x27;LOCATION&#x27;:&#x27;/var/tmp/django_cache&#x27;,#存储路径 # win&#x27;c:\\test\\cache&#x27; &#125;&#125; 整体缓存策略 视图函数中 django还是使用了装饰器来实现缓存逻辑 123from django.views.decorators.cache import cache_page@cache_page(30)# 单位秒def my_view(request): 路由中 一个道理，在进入视图函数前首先使用装饰器。换个地方写而已。 1234from django.views.decorators.cache import cache_pageurlpatterns = [ path(&#x27;foo/&#x27;,cache_page(60)(my_view)),] 使用简单粗暴，但是无法控制。 局部缓存策略相较于整体缓存更加灵活，复用性更好。缓存api的使用： 方式1：使用caches[‘CACHE配置key’]导入具体对象 123from django.core.caches import cachescache1 = caches[&#x27;myalias&#x27;]cache2 = caches[&#x27;myalias_2&#x27;] 方式2 123直接调用CACHE中的default值。相当于1中的cache = caches[&#x27;default&#x27;]from django.core.caches import cache 缓存api： 1.cache.set(key,value,timeout)-存储缓存 key:缓存的key，字符串类型 value:python对象 timeout：缓存存储时间，默认为CACHES中的TIMEOUT值 返回值：None 2.cacahe.get(key)-获取缓存 key：缓存的key 返回值，key的对应值，没有则返回None 3.cache.add(key,value)-存储缓存，只在key不存在的时候生效 返回值：True或False 4.cache.get_or_set(key,value,timeout) 5.cache.set_many(dict,timeout) 6.cache.get_many(key_list) 7.cache.delete(key) 8.cache.delete_many(key_list) 浏览器缓存策略-强缓存不会向服务器发送请求，直接从缓存中读取资源 1.响应头-Expires：定义缓存过期时间，是服务器端的具体的时间点 样例：Expires:Thu,02 Apr 2030 05:14:08 GMT 2.响应头-Cache-Control ‘Cache-Control:max-age&#x3D;120’120秒后缓存失效 说明：目前服务器都会带着这两个头同时响应给浏览器，浏览器优先使用Cache-Control cache-page整体缓存自带强缓存功能 浏览器缓存策略-协商缓存强缓存的对象是一些静态文件、大图片等，考虑到这类资源比较费带宽且不易变化，强缓存到期后，浏览器会根服务器进行协商，当前缓存是否可用，如果可用，服务器不必返回数据，浏览器继续使用原来缓存的数据，如果文件不可用，则返回最新数据。 1.Last-Modified响应头：文件的最近修改时间，同时告诉服务器到期后协商 2.If-Modified-Since请求头，浏览器向服务器请求协商，如果资源未发生变化，则返回304（响应体为空），否则返回200代表缓存不可用（响应体为最新资源） 上述的两个头仅通过精确到秒的时间来判断缓存是否有效，不是特别精准，后来HTTP又引入了新的缓存头： 3.Etag响应头：返回当前资源的唯一标识（由服务器生成），只要资源变化，Etag就会重新生成 4.缓存到期，浏览器返回If-None-Match请求头，给服务器请求协商，服务器比对文件标识，不一致则认为资源不可用。 中间件 中间件是请求&#x2F;响应的钩子框架，用于全局改变Django的输入和输出。 中间件以类的形式体现 每个中间件负责一些特定的功能 中间件方法继承django.utils.deprecation.MiddlewareMixin类中间件类须实现下列五个方法中的一个或多个： process_request(self,request) 执行路由之前被调用，在每个请求上调用，只能返回None或HttpResponse对象，None则通过。 process_view(self,request,callback,callback_args,callback_kwargs) 在视图之前调用，在每个请求上调用，返回None或HttpResponse对象。 process_response(self,request,response) 在响应返回浏览器被调用，在每个请求调用，返回HttpResponse对象。 process_exception(self,request,exception) 当处理过程中抛出异常时调用，返回一个HttpResponse对象。用来统一抓所有视图函数的异常。 process_template_response(self,request,response) 在响应中包含render方法时被调用，该方法返回二次封装后的render响应对象。 中间件中的大部分方法返回None则表示进入下一项时间，返回HttpResponse则被拦截。 编写中间件 1.注册中间件settngs.py-MIDDLEWARE 2.建立中间件包，编写中间件’ 中间件的执行顺序先由上到下，在进入视图后变为由下至上 CSRF - 跨站伪造请求攻击利用Cookies自动提交功能，同时利用了form表单及一些html控件的跨域提交。 django的防御机制：页面和COOKIE都有一个暗号，只有两个暗号同时发送到服务器并且能够匹配，才允许POST。配置步骤： 保证django.middleware.csrf.CsrfViewMiddleware打开 模板中，form标签下添加如下标签： 1&#123;% csrf_token %&#125; 当个别视图不需要django进行csrf保护可以用装饰器关闭对此视图的检查 12345from django.views.decorators.csrf import csrf_exempt@csrf_exemptdef my_view(request): return … 分页分页指在web页面有大量数据需要显示，为了阅读方便在每个页中只显示部分数据。 优点： 方便阅读 减少数据提取量，减轻服务器压力。 Django提供了Paginator类可以方便的实现分页功能Paginator类位于’django.core.paginator’模块中 paginator对象负责分页数据整体的管理 pagenator &#x3D; Paginator(object_list,per_page) object_list 需要分页数据的对象列表，如QuerySet per_page 分页数据个数 返回值：Paginator对象 Paginator对象属性 count：需要分页的数据对象总数 num_pages:分页后的页面总数 page_range：从1开始的range对象，用于记录当前页码数 per_page：每页数据个数 Paginator方法paginator对象.page(number) -参数number为页码信息(从1开始) -返回当前number页对应的页信息 -如果提供的页码不存在，抛出InvalidPage异常，包含两种异常子类-PageNotInteger页码不是整数和-EmptyPage页码超页 page对象Paginator对象的page()方法返回Page对象page &#x3D; paginator.page(页码) page对象属性： object_list：当前页上所有数据对象的列表 number:当前页面的序号，从1开始 paginator：当前page对象相关的Paginator对象 Page对象方法： has_next():如果有下一页返回True next_page_number():下一页页码，如果下一页不存在，抛出InvalidPage异常 has_previous:如果有上一页返回True previous_page_number():返回上一页的页码，如果上一页不存在，抛出InvalidPage异常。 has_other_pages：如果有上一页或者有下一页返回True csv文件 csv文件：逗号分隔值文件，其文件以纯文本形式存储表格数据（数字或文本） 说明：可被常见制表工具，如excel等直接进行读取 python中生成csv文件python提供了内建库 -csv；可直接通过该库操作csv文件。案例： 1234import csvwith open(&#x27;eggs.csv&#x27;,&#x27;w&#x27;, newline=&#x27;&#x27;) as csvfile:# newline指文件输出时换行符怎么处理，空字符串将不会转义 writer = csv.writer(csvfile) writer.writerow([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]) csv文件下载在网站中实现下载csv，注意如下： 响应Content-Type类型需修改为text&#x2F;csv。这告诉浏览器该文档是CSV文件，而不是HTML文件 响应为额外添加一个Content-Disposition标头，其中包含CSV文件的名称，它将被浏览器用于开启”另存为”对话框。 12345678910111213import csvfrom django.http import HttpResponsefrom .models import Bookdef make_csv_view(request): response = HttpResponse(content_type = &#x27;text/csv&#x27;) response[&#x27;Content-Disposition&#x27;] = &#x27;attachment;filename = &quot;mybook.csv&quot;&#x27; all_book = Book.objects.all() writer = csv.writer(response) writer.writerow([&#x27;id&#x27;,&#x27;title&#x27;]) for b in all_book: writer.writerow([b.id,b.title]) return response 内建用户系统模型类位置from django.contrib.auth.models import User（mysql中auth_user表）字段（属性）： username 用户名 password 密码 email 邮箱 first_name 名 last_name 姓 is_superuser 是否为超级用户 is_staff 是否为内部员工 is_active 伪删除 last_login 上次登陆时间 date_joined 用户创建时间 命令： 1.创建普通用户create_user,主要是需要处理密码，将自动转化密码为hash值。 12from django.contrib.auth.models import Useruser = User.objects.create_user(username=&quot;用户名&quot;,password=&quot;密码&quot;,email=&quot;邮箱&quot;,…) 2.创建超级用户create_superuser 3.删除用户(伪删除，更新操作) 4.校验密码 123from django.contrib.auth import authenticateuser = authenticate(username=username, password=password) 如果用户名密码校验成功则返回用户对象，否则返回None 5.修改密码set_password 6.登录状态保持 只存session，且时间不可控 1234from django.contrib.auth import logindef login_view(request)： user = authenticate(username=username, password=password) login(request,user) 7.登录状态校验 1234from django.contrib.auth.decorators import login_required@login_requireddef index_view(request): login_user = request.user#直接能拿到usert对象 8.登录状态取消 123from django.contrib.auth import logoutdef logout_view(request): logout(request) 内建用户表-扩展字段方案1:通过建立细腻哦啊，和内建表做1对1映射方案2：继承抽象user模型类方案2步骤： 1.添加应用 2.定义模型类，继承AbastractUser 3.settings.py中指明AUTH USER MODEL &#x3D; ‘应用名.类名’ ！！注意：此操作需要在第一次migrate之前进行！！ 12345from django.db import modelsfrom django.contrib.auth.models import AbstractUserclass UserInfo(Abstractuser): phone = models.CharField(max_length = 11, default = &#x27;&#x27;) 在settings.py里面添加配置：AUTH_USER_MODEL &#x3D; ‘user.UserInfo’ 添加用户from user.models import UserInfo UserInfo.objects.create_user(username&#x3D;……,phone&#x3D;’’) 文件上传定义：用户可以通过浏览器将图片等文件传至网站场景： 上传头像 上传流程性的文件 上传规范-前端上传必须为POST提交方式表单’&lt;\\form&gt;’中文件上传时必须有带有enctype&#x3D;’multipart&#x2F;form-data’时才会包含文件内容数据。表单中用&lt;input type &#x3D; ‘files’ name&#x3D;’xxx’&gt;标签上传文件 上传规范-后端视图函数中，需要用request.FILES取文件框的内容file&#x3D;request.FILES[‘xxx’]说明： 1.FILES的key对应页面中file框的name值 2.file绑定文件流对象 3.file.name文件名 4.file.file文件的字节流数据 配置文件的访问路径和存储路径在settings.py中设置MEDIA相关配置，Django将用户上传的文件统称为media资源 12MEDIA_URL=&#x27;/media/&#x27;MEDIA_ROOT = os.path.join(BASE_DIR, &#x27;media&#x27;) 同时MEDIA_URL和MEDIA_ROOT还需要手动绑定：在主路由添加： 123from django.conf import settingsfrom django.conf.urls.static import staticurlpatterns += static(settings.MEDIA_URL,document_root=settings.MEDIA_ROOT) 等价于做了MEDIA_URL开头的路由，Django接到该特征请求后去MEDIA_ROOT路径查找资源 文件写入： 1.open方法 可能出现文件名称的重名问题 1234567# 在视图函数POST中a_file = request.FILES[&#x27;myfile&#x27;]fileadd = os.path.join(settings.MEDIA_ROOT,afile.name)with open(filename,&#x27;wb&#x27;) as f: data = afile.file.read() f.write(data)return HttpResponse 2.借助ORM 字段FileField(upload &#x3D; ‘子目录名’) 建表时增加一个字段即可，实际收到后直接在视图函数中将绑定文件流对象扔给对应字段即可 1Content.objects.create(desc = title, content = a_file) 该方法若文件名重复则django将自动添加后缀 django发送邮件业务场景： 业务报警 邮件验证 密码找回 邮件相关协议 SMTP：Simple Mail Transfer Protocol，简单邮件传输协议（port：25） 负责邮件的发送，属于“推送”协议 IMAP：Internet Mail Access Protocol，交互式邮件访问协议，应用层协议（port：143） 负责本地邮件客户端访问远程服务器上的邮件，属于“拉取”协议 POP3：Post Office Protocol3：邮局协议第3个版本，是TCP&#x2F;IP协议族中的一员（port：110） 本协议主要用于支持使用客户端远程管理在服务器上的电子邮件，同样属于“拉取”协议。 IMAP VS POP3: 两者均为“拉取”协议，负责从邮件服务器中下载邮件 IMAP支持摘要浏览功能，并且是双向协议，客户端操作可以反馈给服务器 POP3必须下载全部邮件，且为单向协议，客户端操作无法同步服务器。 Django发邮件Django中配置邮件功能，主要为SMTP协议，负责发邮件原理： 给Django授权一个邮箱 Django用该邮箱给对应收件人发送邮件 django.core.mail封装了电子邮件的自动发送SMTP协议 授权： 邮箱端修改 开启SMTP相关的功能，获得授权码。 Django修改(settings.py添加) 123456EMAIL_BACKEND = &#x27;django.core.mail.backends.smtp.EmailBackend&#x27;# 引擎：写死EMAIL_HOST = &#x27;smtp.qq.com&#x27;# 腾讯qq邮箱的SMTP服务器地址EMAIL_PORT = 25# 默认25EMAIL_HOST_USER = &#x27;xxxx@qq.com&#x27;EMAIL_HOST_PASSWORD = &#x27;*******&#x27;# 指的是授权码EMAIL_USE_TLS = False # 与SMTP服务器通讯时，是否启动TLS连接（安全链接）默认为False，安全协议比较耗时 发送： 12345678from django.core import mailmail.send_mail( subject, message, from_email,# 发送邮箱 recipient_list = [&#x27;xxx@qq.com&#x27;],# 接受者邮箱列表)返回1则成功发送 通过中间件可以捕获所有视图函数的异常，并发送到指定邮箱process_exception(self,request,exception)定位错误位置：异常追溯 12import tracebacktraceback.format_exc()# 直接获得错误具体位置及出错信息 邮箱里可以直接发送traceback.format_exc() 自定义收件人：在settings里自定义属性，在调用send_mail位置 12from django.conf import settingsrecipient_list = settings.自定义属性 项目部署在软件开发完毕后，将开发机器上运行的软件实际安装到服务器上进行长期运行 安装机器上安装和配置同版本的环境[py,数据库等] django项目迁移，第三方工具：finalshare等 ubuntu直接用scp命令 sudo scp 需要复制文件路径 远程ip:路径 用uWSGI替代python manage.py runserver方法 配置nginx反向代理服务器 用nginx配置静态文件路径，解决静态路径问题 uWSGIWSGI：Web Server Gateway Interface，Web服务器网关接口，是Pyhton应用程序或框架和Web服务器之间的一种接口。uWSGI：WSGI的一种，实现了http协议、WSGI协议、uwsgi协议等多种协议。在python web圈热度极高，主要以学习配置为主。 uWSGI安装pip命令可以安装[ubuntu验证安装]:sudo pip3 freeze|grep -i ‘uwsgi’[ubuntu安装]:sudo pip3 install uwsgi&#x3D;&#x3D;2.0.18 -i https://pypi.tuna.tsinghua.edu.cn/simple/ 配置uWSGI: 项目同名文件夹&#x2F;uwsgi.ini 如mysite1&#x2F;mysite1&#x2F;uwsgi.ini文件以[uwsgi]开头，有如下配置项： 1监听端口 套接字方式的IP地址：端口号[此模式需要有nginx] socket&#x3D;127.0.0.1:8000 Http通信凡是的IP地址：端口号 http&#x3D;127.0.0.1:8000 2项目当前工作目录 chdir&#x3D;绝对路径 3项目中wsgi.py文件目录，相对于当前工作目录 wsgi-file&#x3D;相对路径 4进程个数(最多为cpu核数) process&#x3D;4 5每个进程的线程个数 threads&#x3D;2 6服务的pid记录文件 pidfile&#x3D;uwsgi.pid 7服务的日志文件位置(后台启动以及所有日志位置) daemonize&#x3D;uwsgi.log 8开启主进程管理模式 master&#x3D;true"},{"title":"微信小程序云开发实现图片的上传、存储、访问","path":"posts/dc7f.html","text":"我们在进行项目开发时，经常需要处理用户上传的图片，如果用传统的后端开发，处理起来是比较繁琐的。微信小程序云开发提供了一系列API供开发者完成想要的效果。下面我们要实现用户图片的上传、存储及访问。 1&lt;button type=&quot;primary&quot; bindtap=&quot;upImg&quot;&gt;上传图片&lt;/button&gt; 因为只是演示功能，我们用一个按钮实现点击事件的产生。首先我们用到的第一个API就是wx.chooseImage官方文档介绍: 123456789upImg()&#123; var that = this; wx.chooseImage(&#123; count: 1, success(res)&#123; console.log(res); &#125; &#125;) &#125;, 然后我们试着选中一个图片，然后看控制台的输出内容。这个tempFilePaths是我们需要的数据。接下来我们使用第二个API，wx.cloud.uploadFile官方文档介绍： 12345678910111213141516upImg()&#123; var that = this; wx.chooseImage(&#123; count: 1, success(res)&#123; console.log(res); wx.cloud.uploadFile(&#123; cloudPath:&#x27;test/&#x27; + Math.floor(Math.random()*1000000), filePath:res.tempFilePaths[0], success(res)&#123; console.log(&quot;成功&quot;,res); &#125; &#125;) &#125; &#125;) &#125;, wx.chooseImage里面其实没有什么我们需要填写的参数，直接使用就行。但是wx.cloud.uploadFile很明显需要我们填写cloudPath和filePath，这个cloudPath其实就是我们要在云存储中存放的位置，可以新建一个文件夹，也可以直接往里堆。我是新建了一个名为test的文件夹并且在后面拼接了一个很多位的随机数，避免重复。filePath就是我们上文提到的需要的数据，即wx.chooseImage的返回值中的tempFilePaths。然后我们现在再点击一下按钮，看一下wx.cloud.uploadFile的回调会给我们返回一个什么样的值。 fileID和statusCodefileID就是在云存储中的链接，可以直接在客户端访问到。statusCode是一个状态码，可以用来判断操作是否成功。 我们现在试一下fileID能不能直接在WXML中通过Image组件访问到 1&lt;image src=&quot;cloud://creator-xcq6k.6372-creator-xcq6k-1301361703/test/461783&quot;&gt;&lt;/image&gt; 没有问题，是可以直接访问的。但是这个fileID仅仅只是在客户端可以被访问到，在一些业务场景下是不够的。下面这个API可以把fileID转化为https的url地址，供全网访问。wx.cloud.getTempFileURL官方文档介绍： 12345678910111213141516171819202122upImg()&#123; var that = this; wx.chooseImage(&#123; count: 1, success(res)&#123; console.log(res); wx.cloud.uploadFile(&#123; cloudPath:&#x27;test/&#x27; + Math.floor(Math.random()*1000000), filePath:res.tempFilePaths[0], success(res)&#123; console.log(&quot;成功&quot;,res); wx.cloud.getTempFileURL(&#123; fileList:[res.fileID], success(res)&#123; console.log(res); &#125; &#125;) &#125; &#125;) &#125; &#125;)&#125;, 这里的tempFileURL就是我们需要的url。复制一下，打开任意一个浏览器，粘贴到地址栏，就会弹出下载的弹窗 下载了以后，因为没有后缀名所以是无法直接打开的，可以直接在后面填上.png或者.jpg的后缀。 其实这里我推荐在当初填云存储的图片路径的时候，即cloudPath，就把图片的后缀加上，可以通过正则表达式获取真实的图片后缀，也可以人为的在后面手动拼接后缀，都没有问题。如果路径上有图片的后缀的话，其实就可以直接在网页上浏览图片了，当然也可以下载。 转载： 微信小程序云开发实现图片的上传、存储、访问"},{"title":"XTU每日打卡","path":"posts/a542.html","text":"1.抓包1.1 工具使用ANDROID端app工具：httpcanary9.2.8.1 手机下载安装后安装证书： 之后点击小蓝飞机 允许VPN 便开始抓包了 IOS端：Http Traffic Http Traffic是一款 IOS 平台下的抓包工具，可以作为代{过}{滤}理服务器局域网内设备都可以连接并且抓包，监控网络手机或者 PC 机的网络请求，分析网络数据包情况。 Http Traffic使用 charles 的原理是一样的，通过本机启动一个代{过}{滤}理服务方式抓包，实现了以 iPhone 作为服务端的功能，在同一个局域网内的设备都可以进行连接。 可以抓取网络请求头和请求体的数据，同样可以抓取响应头和响应体的数据. 局域网内可以访问 iPhone 的 http://ip:8002 链接通过浏览器来查看抓包记录,iPhone 本机可以使用http:&#x2F;&#x2F; 127.0.0.1:8002 来访问内嵌的展示网页。 下载方式,Appstore 搜索 “http traffic” 即可下载. 抓包历史记录,抓包历史存档在本机,可以随时查阅抓包的历史, 会话内的数据包列表,可以展示数据包类型,数据包大小,以及图片预览等 查看数据包的请求和响应数据情况,包括请求链接,请求头,请求行,状态,返回的数据包,响应的头信息等. 1.2 抓取湘大校园打卡数据（以android端为例，IOS类比）关闭抓包软件 打开湘大校园停留到健康信息上报界面，这里先不提交 开启抓包 上报 回到抓包软件 找到链接为 https://app.xiaoyuan.ccb.com/channelManage/outbreak/addOutbreak 的那一条数据 点击 请求 -》RAW 复制所有数据 2.python文件123456789101112131415161718192021222324import requestsimport json def sender(): url = &#x27;https://app.xiaoyuan.ccb.com/channelManage/outbreak/addOutbreak&#x27; headers = &#123; &#x27;Host&#x27;: &#x27;app.xiaoyuan.ccb.com&#x27;, &#x27;Connection&#x27;: &#x27;keep-alive&#x27;, &#x27;Content-Length&#x27;: &#x27;1208&#x27;, &#x27;Accept&#x27;: &#x27;application/json, text/plain, */*&#x27;, //...... 后面同理填 &#125; null=&#x27;&#x27; data = &#123;&#x27;stuClass&#x27;:&#x27;9999&#x27;,&#x27;schoolId&#x27;:&#x27;10530&#x27;,//...... 后面同理填&#125; data = json.dumps(data) res = requests.post(url=url,data=data,headers=headers) return res.textdef main_handler(event, context): return sender()if __name__ == &#x27;__main__&#x27;: sender() 注意python的格式 3.腾讯云云函数部署腾讯云函数：[官网注册并激活] 新建 名称随便，运行环境python3.6，创建方式空白函数，将写好的py代码复制进index.py，点击完成 在函数管理-函数代码中点测试， 因为上面代码会return res.text，出现下图结果说明ok，还可以去健康信息上报界面验证一下最近一次提交时间 在触发管理点创建触发器，触发周期改为自定义触发周期，名称随意，Cron表达式 0 0 6 * * * * 表示每天的六点定时执行一次，以此类推，另外不建议将时间设为凌晨时间因为可能不算 OK！ 参考文章： 湘大校园-健康信息填报自动打卡"},{"title":"2021C.S.N 冬令营 微信小程序教学提纲","path":"posts/fd6b.html","text":"1.资料1接口地址： https://www.showdoc.cc/128719739414963 2.postman https://wwi.lanzous.com/iWb3zkhskje 3.微信开发官方文档 https://developers.weixin.qq.com/miniprogram/dev/framework/ 4.组件库 https://developers.weixin.qq.com/miniprogram/dev/component/button.html 5.CSS单位总结（如rem、px、em、vw、vh、vm ） https://www.php.cn/css-tutorial-411368.html 6.CSS calc() 函数 https://www.runoob.com/cssref/func-calc.html 7.JavaScript中的map()函数 https://blog.csdn.net/u010297791/article/details/55511326 8.CSS3 :nth-last-child() 选择器 https://www.w3school.com.cn/cssref/selector_nth-last-child.asp 9.JavaScript中避免回调地狱方法 https://andyli.blog.csdn.net/article/details/80742239?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control 10.JS 把url的参数解析成对象 https://a-jing.blog.csdn.net/article/details/80060315?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control 2.项目预览 3.创建项目3.1精简初始文件3.1.1 app.jswx-app 3.1.2 app.json删除不需要的界面 修改 navigationBarTitleText 3.1.3 pages删除不需要的界面； 修改index（参考2.1.1；2.1.2）； index.js wx-page index.json 修改 navigationBarTitleText index.wxss 删除内容 3.2 搭建目录结构 3.3 搭建项目页面 常用快捷键： 1234567ctrl +alt +downshift+endctrl +vshift+right 详见：https://www.kifroom.icu/posts/7362.html 3.4.引入字体图标3.4.1 创建阿里矢量库 https://www.iconfont.cn/ 加入到创建的项目 打开在线连接 复制到styles的iconfont.wxss 3.4.2 导入 3.4.3 使用 3.5 搭建项目tabBar3.5.1 图片文件阿里矢量库 3.5.2. tabBar 3.6 定义全局变量3.6.1 全局样式文件123456789101112@import &#x27;./styles/iconfont.wxss&#x27;;page,view,image,text&#123; bottom: 0; margin: 0; box-sizing: border-box;&#125;page&#123; /* 定义主题颜色 */ --themeColor:#e60039;&#125; 1px&#x3D; 2rpx 14px &#x3D; 28rpx 4.首页 4.1 搜索框-自定义组件4.1.1 新建组件components文件夹下 4.1.2 引用 4.1.3 搜索框编辑 4.2 轮播图4.2.1 接口数据api:https://www.showdoc.com.cn/128719739414963?page_id=2513235043485226 wx.request js:（此处可以用promise优化） 12345678910111213onLoad: function (options) &#123; wx - wx.request(&#123; url: &#x27;https://api-hmugo-web.itheima.net/api/public/v1/home/swiperdata&#x27;, header: &#123; &#x27;content-type&#x27;: &#x27;application/json&#x27; // 默认值 &#125;, success: (result) =&gt; &#123; console.log(result) &#125;, // fail: (res) =&gt; &#123;&#125;, // complete: (res) =&gt; &#123;&#125;, &#125;)&#125;, 注意： 坑1： 解决办法1：不校验域名 解决方法2：添加域名到白名单 https://mp.weixin.qq.com/ 数据： 1234567891011121314&#123; &quot;message&quot;: [ &#123; &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/banner1.png&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;goods_id&quot;: 129, &quot;navigator_url&quot;: &quot;/pages/goods_detail/index?goods_id=129&quot; &#125; ], &quot;meta&quot;: &#123; &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 &#125;&#125; 4.2.2 数据绑定123456789101112&lt;!-- 轮播图开始 --&gt; &lt;view class=&quot;swiper_view&quot;&gt; &lt;swiper&gt; &lt;swiper-item wx:for=&quot;&#123;&#123;swiperList&#125;&#125;&quot; wx:key=&quot;goods_id&quot;&gt; &lt;navigator&gt; &lt;image src=&quot;&#123;&#123;item.image_src&#125;&#125;&quot;&gt; &lt;/image&gt; &lt;/navigator&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; &lt;/view&gt; &lt;!-- 轮播图结束 --&gt; 4.2.3 布局优化1.图片标签mode属性渲染模式 widthFix：让图片的标签宽高和图片标签的内容的宽高都等比例的发生变化 2.swiper标签存在默认的宽度和高度100% * 150px 解决办法 让swiper高度与图片一样 3.swiper属性 4.3 导航4.3.1 接口数据api接口:https://api-hmugo-web.itheima.net/api/public/v1/home/catitems js:1234567891011121314gettabBarlist() &#123; wx-wx.request(&#123; url: &#x27;https://api-hmugo-web.itheima.net/api/public/v1/home/catitems&#x27;, success: (result) =&gt; &#123; console.log(result.data.message); this.setData(&#123; castList:result.data.message &#125;) &#125;, fail: (res) =&gt; &#123;&#125;, complete: (res) =&gt; &#123;&#125;, &#125;) &#125;, 数据：1234567891011121314151617181920212223242526&#123; &quot;message&quot;: [ &#123; &quot;name&quot;: &quot;分类&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/icon_index_nav_4@2x.png&quot;, &quot;open_type&quot;: &quot;switchTab&quot;, &quot;navigator_url&quot;: &quot;/pages/category/main&quot; &#125;, &#123; &quot;name&quot;: &quot;秒杀拍&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/icon_index_nav_3@2x.png&quot; &#125;, &#123; &quot;name&quot;: &quot;超市购&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/icon_index_nav_2@2x.png&quot; &#125;, &#123; &quot;name&quot;: &quot;母婴品&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/icon_index_nav_1@2x.png&quot; &#125; ], &quot;meta&quot;: &#123; &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 &#125;&#125; 4.3.2 数据绑定1234567&lt;!-- 导航开始 --&gt; &lt;view class=&quot;navView&quot;&gt; &lt;navigator class=&quot;nav&quot; wx:for=&quot;&#123;&#123;castList&#125;&#125;&quot; wx:key=&quot;name&quot;&gt; &lt;image mode=&quot;widthFix&quot; class=&quot;navimg&quot; src=&quot;&#123;&#123;item.image_src&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;/navigator&gt; &lt;/view&gt; &lt;!-- 导航结束 --&gt; css 12345678910111213.navView&#123; width: 100%; display: flex;&#125;.nav&#123; padding: 20rpx; flex:1;&#125;.navimg&#123; width: 100%;&#125; 课后作业1 1.Javascript this关键字： 面向对象语言中 this 表示当前对象的一个引用。 但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。 https://www.runoob.com/js/js-this.html 2.css display:flex 属性 4.4 楼层嵌套循环 4.4.1 接口数据api:https://api-hmugo-web.itheima.net/api/public/v1/home/floordata js:123456789101112getgoodsdata() &#123; wx - wx.request(&#123; url: &#x27;https://api-hmugo-web.itheima.net/api/public/v1/home/floordata&#x27;, success: (result) =&gt; &#123; this.setData(&#123; goodsList:result.data.message &#125;) &#125;, fail: (res) =&gt; &#123;&#125;, complete: (res) =&gt; &#123;&#125;, &#125;)&#125;, 数据：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&#123; &quot;message&quot;: [ &#123; &quot;floor_title&quot;: &#123; &quot;name&quot;: &quot;时尚女装&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor01_title.png&quot; &#125;, &quot;product_list&quot;: [ &#123; &quot;name&quot;: &quot;优质服饰&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor01_1@2x.png&quot;, &quot;image_width&quot;: &quot;232&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;navigator_url&quot;: &quot;/pages/goods_list?query=服饰&quot; &#125;, &#123; &quot;name&quot;: &quot;春季热门&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor01_2@2x.png&quot;, &quot;image_width&quot;: &quot;233&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;navigator_url&quot;: &quot;/pages/goods_list?query=热&quot; &#125;, &#123; &quot;name&quot;: &quot;爆款清仓&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor01_3@2x.png&quot;, &quot;image_width&quot;: &quot;233&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;navigator_url&quot;: &quot;/pages/goods_list?query=爆款&quot; &#125;, &#123; &quot;name&quot;: &quot;倒春寒&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor01_4@2x.png&quot;, &quot;image_width&quot;: &quot;233&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;navigator_url&quot;: &quot;/pages/goods_list?query=春季&quot; &#125;, &#123; &quot;name&quot;: &quot;怦然心动&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor01_5@2x.png&quot;, &quot;image_width&quot;: &quot;233&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;navigator_url&quot;: &quot;/pages/goods_list?query=心动&quot; &#125; ] &#125;, &#123; &quot;floor_title&quot;: &#123; &quot;name&quot;: &quot;户外活动&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor02_title.png&quot; &#125;, &quot;product_list&quot;: [ &#123; &quot;name&quot;: &quot;勇往直前&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor02_1@2x.png&quot;, &quot;image_width&quot;: &quot;232&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;navigator_url&quot;: &quot;/pages/goods_list?query=户外&quot; &#125;, &#123; &quot;name&quot;: &quot;户外登山包&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor02_2@2x.png&quot;, &quot;image_width&quot;: &quot;273&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;navigator_url&quot;: &quot;/pages/goods_list?query=登山包&quot; &#125;, &#123; &quot;name&quot;: &quot;超强手套&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor02_3@2x.png&quot;, &quot;image_width&quot;: &quot;193&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;navigator_url&quot;: &quot;/pages/goods_list?query=手套&quot; &#125;, &#123; &quot;name&quot;: &quot;户外运动鞋&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor02_4@2x.png&quot;, &quot;image_width&quot;: &quot;193&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;navigator_url&quot;: &quot;/pages/goods_list?query=运动鞋&quot; &#125;, &#123; &quot;name&quot;: &quot;冲锋衣系列&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor02_5@2x.png&quot;, &quot;image_width&quot;: &quot;273&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;navigator_url&quot;: &quot;/pages/goods_list?query=冲锋衣&quot; &#125; ] &#125;, &#123; &quot;floor_title&quot;: &#123; &quot;name&quot;: &quot;箱包配饰&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor03_title.png&quot; &#125;, &quot;product_list&quot;: [ &#123; &quot;name&quot;: &quot;清新气质&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor03_1@2x.png&quot;, &quot;image_width&quot;: &quot;232&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;navigator_url&quot;: &quot;/pages/goods_list?query=饰品&quot; &#125;, &#123; &quot;name&quot;: &quot;复古胸针&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor03_2@2x.png&quot;, &quot;image_width&quot;: &quot;263&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;navigator_url&quot;: &quot;/pages/goods_list?query=胸针&quot; &#125;, &#123; &quot;name&quot;: &quot;韩版手链&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor03_3@2x.png&quot;, &quot;image_width&quot;: &quot;203&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;navigator_url&quot;: &quot;/pages/goods_list?query=手链&quot; &#125;, &#123; &quot;name&quot;: &quot;水晶项链&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor03_4@2x.png&quot;, &quot;image_width&quot;: &quot;193&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;navigator_url&quot;: &quot;/pages/goods_list?query=水晶项链&quot; &#125;, &#123; &quot;name&quot;: &quot;情侣表&quot;, &quot;image_src&quot;: &quot;https://api-hmugo-web.itheima.net/pyg/pic_floor03_5@2x.png&quot;, &quot;image_width&quot;: &quot;273&quot;, &quot;open_type&quot;: &quot;navigate&quot;, &quot;navigator_url&quot;: &quot;/pages/goods_list?query=情侣表&quot; &#125; ] &#125; ], &quot;meta&quot;: &#123; &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 &#125;&#125; 4.4.2 数据绑定 mode&#x3D;”widthFix”图片等比例缩放 解决：第一张图片原图的宽高：232 * 386232 / 386 = 33.33vw / height 第一张图片的高度：height：33.33vw * 386 / 232后四个超链接图片的高度：height：33.33vw * 386 / 232 / 2后四张图片的高度应该跟随写好的样式：image标签的mode属性应改为mode=&quot;&#123;&#123;index2===0?'widthFix':'scaleToFill'&#125;&#125; wx:if 1index2==0 三元表达式 1234567891011121314151617&lt;!-- 商品数据开始 --&gt;&lt;view class=&quot;data&quot;&gt; &lt;view class=&quot;group&quot; wx:for=&quot;&#123;&#123;goodsList&#125;&#125;&quot; wx:for-item=&quot;item1&quot;&gt; &lt;view class=&quot;title&quot;&gt; &lt;image mode=&quot;widthFix&quot; class=&quot;titleImg&quot; mode=&quot;widthFix&quot; src=&quot;&#123;&#123;item1.floor_title.image_src&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=&quot;list&quot;&gt; &lt;navigator class=&quot;goodsNav&quot; wx:for=&quot;&#123;&#123;item1.product_list&#125;&#125;&quot; wx:for-item=&quot;item2&quot; wx:for-index=&quot;index2&quot; wx:key=&quot;name&quot;&gt; &lt;image class=&quot;goodsImg&quot; mode=&quot;&#123;&#123;index2===0?&#x27;widthFix&#x27;:&#x27;scaleToFill&#x27;&#125;&#125;&quot; src=&quot;&#123;&#123;item2.image_src&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;/navigator&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;!-- 商品数据结束 --&gt; 123456789101112131415161718192021222324.titleImg &#123; width: 100%;&#125;.goodsNav&#123;float: left;width: 33.33333%;&#125;/* 232/386=33.3vw / heighheigt = 386*33.3vw/232*/.goodsNav:nth-last-child(-n+4)&#123; /* height: 386*33.3vw/232/2; */ height: 27.702155172413vw;&#125;.goodsImg&#123; width: 100%; height: 100%;&#125; 5 分类5.1 预览 5.2 接口数据api: https://api-hmugo-web.itheima.net/api/public/v1/categories 数据映射 123456789101112131415161718192021222324252627282930313233343536&#123; &quot;message&quot;: [ &#123; &quot;cat_id&quot;: 1, &quot;cat_name&quot;: &quot;大家电&quot;, &quot;cat_pid&quot;: 0, &quot;cat_level&quot;: 0, &quot;cat_deleted&quot;: false, &quot;cat_icon&quot;: &quot;/full/none.jpg&quot;, &quot;children&quot;: [ &#123; &quot;cat_id&quot;: 3, &quot;cat_name&quot;: &quot;电视&quot;, &quot;cat_pid&quot;: 1, &quot;cat_level&quot;: 1, &quot;cat_deleted&quot;: false, &quot;cat_icon&quot;: &quot;/full/none.jpg&quot;, &quot;children&quot;: [ &#123; &quot;cat_id&quot;: 5, &quot;cat_name&quot;: &quot;曲面电视&quot;, &quot;cat_pid&quot;: 3, &quot;cat_level&quot;: 2, &quot;cat_deleted&quot;: false, &quot;cat_icon&quot;: &quot;https://api-hmugo-web.itheima.net/full/2fb113b32f7a2b161f5ee4096c319afedc3fd5a1.jpg&quot; &#125; ] &#125; ] &#125; ], &quot;meta&quot;: &#123; &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 &#125;&#125; 数据拆分左侧名称leftmenulist rightContent 123456789101112131415161718192021222324252627282930313233343536373839// pages/category/category.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; leftmenulist: [], rightContent: [], &#125;, cases: [], /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; this.getdataList(); &#125;, getdataList() &#123; wx - wx.request(&#123; url: &#x27;https://api-hmugo-web.itheima.net/api/public/v1/categories&#x27;, success: (result) =&gt; &#123; this.cases = result.data.message console.log(this.cases); // 左侧 let list = this.cases.map( function (item) &#123; return item.cat_name; &#125;); let list2=this.cases[0].children console.log(list2) this.setData(&#123; leftmenulist:list, rightContent:list2, &#125;) &#125;, &#125;) &#125;&#125;) map函数 5.3 界面5.3.1 引入搜索框json:123456&#123; &quot;usingComponents&quot;: &#123; &quot;searchInput&quot;:&quot;../../components/searchInput/searchInput&quot; &#125;, &quot;navigationBarTitleText&quot;: &quot;分类&quot;&#125; 5.3.2 左右可滚动视图区域组件： scroll-view 1234567891011121314151617181920212223242526/* pages/category/category.wxss */page &#123; height: 100%;&#125;.mainView&#123; height: 100%;&#125;.cates_container ,mainView &#123; height: calc(100vh - 45px); display: flex;&#125;.left_menu &#123; background-color: bisque; flex: 2;&#125;.right_content &#123; background-color: blue; flex: 5;&#125; height: calc(100vh - 45px); 空格！ 6.优化6.1 缓存技术目的：优化减少请求次数 思路： 6.1.1本地存储本地数据缓存 本地数据缓存是小程序存储在当前设备上硬盘上的数据，本地数据缓存有非常多的用途，我们可以利用本地数据缓存来存储用户在小程序上产生的操作，在用户关闭小程序重新打开时可以恢复之前的状态。我们还可以利用本地缓存一些服务端非实时的数据提高小程序获取数据的速度，在特定的场景下可以提高页面的渲染速度，减少用户的等待时间。 读取本地数据缓存 wx.getStorage&#x2F;wx.getStorageSync 详细参数 参数名 类型 必填 描述 key String 是 本地缓存中指定的 key success Function 否 异步接口调用成功的回调函数，回调参数格式: {data: key对应的内容} fail Function 否 异步接口调用失败的回调函数 complete Function 否 异步接口调用结束的回调函数（调用成功、失败都会执行） 写入本地数据缓存 wx.setStorage&#x2F;wx.setStorageSync 详细参数 参数名 类型 必填 描述 key String 是 本地缓存中指定的 key data Object&#x2F;String 是 需要存储的内容 success Function 否 异步接口调用成功的回调函数 fail Function 否 异步接口调用失败的回调函数 complete Function 否 异步接口调用结束的回调函数（调用成功、失败都会执行） 1234567891011121314151617181920212223const Cates = wx.getStorageSync(&quot;cates&quot;); if (!Cates) &#123; this.getdataList(); &#125; else&#123; if((Date.now()-Cates.time)&gt;1000*100) &#123; this.getdataList(); &#125; else&#123; this.cases =Cates.data; let list = this.cases.map( function (item) &#123; return item.cat_name; &#125;); let list2 = this.cases[0].children this.setData(&#123; leftmenulist: list, rightContent: list2, &#125;) &#125; &#125; 6.2 列表回顶scroll-view scroll-top属性 6.3 数据请求优化6.3.1 更改为promise方式原因：避免回调地狱（解决多层回调的问题） ES6 promise Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。 promise只有两个状态resolve和reject，当它触发任何一个状态后，它会将当前的值缓存起来，并在有回调函数添加进来的时候尝试调用回调函数，如果这个时候还没有触发resolve或者reject，那么回调函数会被缓存，等待调用，如果已经有了状态(resolve或者reject)，则立刻调用回调函数。并且所有回调函数在执行后都立即被销毁。 1New Promise( function(resolve, reject) &#123;...&#125; /* executor */ );1 executor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回新建对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled，或者在发生错误时将它的状态改为rejected。 JS 把url的参数解析成对象 1...params 等价于： 123456789101112// url参数解析function getUrlkey(url) &#123; var params = &#123;&#125;; var urls = url.split(&quot;?&quot;); console.log(&#x27;1_分割url:&#x27;, urls) var arr = urls[1].split(&quot;&amp;&quot;); console.log(&#x27;2_分割urls[1]:&#x27;, arr) for (var i = 0, l = arr.length; i &lt; l; i++) &#123; var a = arr[i].split(&quot;=&quot;); console.log(&#x27;3_遍历 arr 并分割后赋值给a:&#x27;, a[0], a[1]) params[a[0]] = a[1]; console.log(&#x27;4_a给params对象赋值:&#x27;, params) &#125; console.log(&#x27;5_结果:&#x27;, params) return params;&#125; eg: http&#x2F;&#x2F;aaa&#x2F;txt.php?a&#x3D;1&amp;b&#x3D;2&amp;c&#x3D;3"},{"title":"微信小程序开发笔记","path":"posts/9bb.html","text":"1.跳转方式123456789101112131415161718192021222324//只能跳转到tabBar配置页面wx.switchTab(&#123; url: &#x27;/pages/index/index&#x27;,&#125;);//返回上一级页面（delta：返回的页面数，如果 delta 大于现有页面数，则返回到首页，默认值为1）wx.navigateBack(&#123; delta: 2&#125;)//关闭当前页面，跳转到应用内的某个页面wx.redirectTo(&#123; url: &#x27;/pages/index/index&#x27;,&#125;);//保留当前页面，跳转到应用内的某个页面wx.navigateTo(&#123; url: &#x27;/pages/index/index&#x27;,&#125;);// 关闭所有页面，打开到应用内的某个页面wx.reLaunch(&#123; url: &#x27;/pages/index/index&#x27;,&#125;);"},{"title":"Javascript字符串处理","path":"posts/4428.html","text":"作为JavaScript基础数据类型，字符串具有一些很强大的方法，在平时的工作中用到的地方也特别的多，很多时候因为不熟悉某个字符串的方法，往往走了很多弯路，所以整理了15个常用又高效的字符串方法，来一起看看这15个提升工作效率的方法吧！ 1. 字符串去除首尾空格 —— trim()说明： 去除字符串两边的空白。 需求场景： 用户搜索前去除输入的首尾空格。 用法： string.trim() 例子： 1234let str = &quot; 白色不白，黑色不黑，我...我不喜欢你 &quot;let result = str.trim()console.log(result); // 控制台打印：&quot;白色不白，黑色不黑，我...我不喜欢你&quot;复制代码 2. 字符串替换指定字符（串）—— replace()说明： 字符串替换字符还是replace()最强大~默认替换第一个符合条件的字符串，也可用正则做全局匹配 需求场景： 字符串的替换，关键词的屏蔽隐藏等 用法： string.replace(searchvalue,newvalue) 例子： 123456let str = &quot;你知道吗？世界上有60亿人，宇宙有60万亿小行星，你比小行星还要珍贵一万倍&quot;let result1 = str.replace(&quot;亿&quot;,&quot;个&quot;)let result2 = str.replace(/亿/g,&quot;个&quot;)console.log(result1) // 控制台打印：&quot;你知道吗？世界上有60个人，宇宙有60万亿小行星，你比小行星还要珍贵一万倍&quot;console.log(result2) // 控制台打印：&quot;你知道吗？世界上有60个人，宇宙有60万个小行星，你比小行星还要珍贵一万倍&quot;复制代码 3. 字符串合并 —— concat()说明： 连接两个或更多字符串，并返回新的字符串。（悄悄告诉你，数组也可以使用哦~） 需求场景： 字符串合并展示。 用法： string.concat() 例子： 12345let str1 = &quot;我有很多好听的情话,&quot;let str2 = &quot;可面对你都不敢说不出口。&quot;let result = str1.concat(str2)console.log(result) // 控制台打印：&quot;我有很多好听的情话,可面对你都不敢说不出口。&quot;复制代码 4. 字符串转数组 —— split()说明： 把字符串通过特定字符分割为字符串数组，split还可以使用正则表达式实现拆分多个分隔符。 需求场景： 字符串转数组进行遍历等操作。 用法1： string.split() 用法2： string.split(/[*]/) 例子： 123456let str = &quot;张三,李四;王五&quot;let result1 = str.split(&#x27;,&#x27;)let result2 = str.split(/[,;]/)console.log(result1) // 控制台打印：[&quot;张三&quot;, &quot;李四;王五&quot;]console.log(result2) // 控制台打印：[&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]复制代码 5. 字符串转数组 —— […string]说明： 说起来，这并不是字符串的方法，主要是我觉得ES6语法中的扩展操作符的…语法是转数组最简洁的方法。它和split()区别在于：...语法不根据特定字符切割，而是把每个字符都当作单独的元素添加到数组中。 需求场景： 字符串全部分割成字符数组。 用法： [...string] 例子： 1234let str = &#x27;这是一个字符串string&#x27;let arr = [...str]console.log(arr) // 控制台打印：[&quot;这&quot;, &quot;是&quot;, &quot;一&quot;, &quot;个&quot;, &quot;字&quot;, &quot;符&quot;, &quot;串&quot;, &quot;s&quot;, &quot;t&quot;, &quot;r&quot;, &quot;i&quot;, &quot;n&quot;, &quot;g&quot;]复制代码 6. 字符串反转 —— […string].reverse().join(“”)说明： 这个也不能算是字符串方法，但是好用。本质上还是转成数组，数组反转之后，再拼接成字符串。 需求场景： 将当前字符串反转输出 用法： [...string].reverse().join(&quot;&quot;) 例子： 1234let str = &quot;两极反转，龙卷风摧毁停车场!&quot;let result = [...str].reverse().join(&quot;&quot;)console.log(result) // 控制台打印：!场车停毁摧风卷龙，转反极两复制代码 7. 字符串的多次复制 —— repeat ()说明： 复制字符串指定次数，并将它们连接在一起返回。 需求场景： 字符串需要进行 n 次自动复制。 用法： string.repeat(n) 例子： 12345678let str1 = &#x27;复制&#x27;let result = str1.repeat(2)consol.log(result) // 控制台打印：复制复制let str2 = &#x27;10&#x27;let result = str2.repeat(5)console.log(result) // 控制台打印：1010101010复制代码 8. 字符串是否包含某字符 （串）—— search()说明：检索字符串中指定的或与正则表达式相匹配的首个子字符串。如果匹配到了则返回匹配字符串首字符下标，如果没有匹配到，则返回 -1。 需求场景： 字符串内关键字的搜索查询定位。 用法： string.search(searchvalue)。 例子： 123456let str = &quot;今天的夜色很好，月亮也很圆，唯一遗憾的是，我不是从你的窗子里看到的月亮。&quot;let result1 = str.search(&quot;月亮&quot;)let result2 = str.search(/[，。]/)console.log(result1) // 控制台打印：8console.log(result2) // 控制台打印：7复制代码 9. 字符串内是否包含某字符（串）—— includes()说明： includes()可选择从某处下标之后开始查找，返回true或false。第二个参数代表从某下标处开始查找，忽略则代表从下标0开始查找。 它和search()区别在于：search()返回指定下标， includes()返回true或false；search()不能从指定下标开始查找， includes()可以从指定下标处开始查找。 需求场景： 判断字符串中是否有不合法字符等 用法： string.includes(searchvalue, start) 例子： 123456let str = &quot;没有夏日的的凉风，也没有冬日的暖阳，它们只是恰好出现在了合适的时间罢了&quot;let result1 = str.includes(&quot;冬日&quot;)let result2 = str.includes(&quot;冬日&quot;,20)console.log(result1); // 控制台打印：trueconsole.log(result2); // 控制台打印：false复制代码 10. 字符串中指定的字符串值在首次或最后一次出现的位置 —— indexOf() 和 lastIndexOf()说明： indexOf() 方法可返回某个指定的字符串值首次出现的位置，即从前向后搜索。如果指定第二个参数 start，则在字符串中的指定位置开始从前向后搜索。 lastIndexOf() 方法可返回某个指定的字符串值最后出现的位置，即从后向前搜索。如果指定第二个参数 start，则在字符串中的指定位置从后向前搜索。 需求场景： 关键字首次或最后一次出现的位置 用法1： string.indexOf(searchvalue,start) 指定的字符串值首次出现的位置 用法2： string.lastIndexOf(searchvalue,start) 指定的字符串值最后出现的位置 例子： 12345678910let str = &quot;你来人间一趟，你要看看太阳。和你的心上人一起走在街上，了解她，也要了解太阳&quot;let result1 = str.indexOf(&quot;太阳&quot;)let result2 = str.indexOf(&quot;太阳&quot;,10) // 从10下标的字符开始查找&quot;太阳&quot;，查找范围是&quot;太阳。和你的心上人一起走在街上，了解她，也要了解太阳&quot;，下标还是相对原字符串而言的，因此返回11。let result3 = str.lastIndexOf(&quot;太阳&quot;) let result4 = str.lastIndexOf(&quot;太阳&quot;,10) // 0-10下标的字符串为&quot;你来人间一趟，你要看看&quot;，没有&quot;太阳&quot;，返回-1console.log(result1) // 控制台打印：11console.log(result2) // 控制台打印：11console.log(result3) // 控制台打印：35console.log(result4) // 控制台打印：-1复制代码 11. 字符串转大小写 —— toLowerCase() 和 toUpperCase()说明： 字符串大小写之间的转换 需求场景： 网址，英文名，首字母大写等要求。 用法1： string.toLowerCase() 转成小写字母 用法2： string.toUpperCase() 转成大写字母 例子： 123456let str = &quot;For you, A thousand times over&quot;let result1 = str.toLowerCase()let result2 = str.toUpperCase()console.log(result1) // 控制台打印：&quot;for you, a thousand times over&quot;console.log(result2) // 控制台打印：&quot;FOR YOU, A THOUSAND TIMES OVER&quot;复制代码 12. 字符串填充到指定长度 —— padStart () 和 padEnd ()说明： 字符串填充指定字符到指定长度 需求场景： 字符串长度不足，需要补充至指定长度n，如年月日，隐藏手机号，隐藏昵称等。 用法1： string.padStart(n,&#39;补充内容&#39;) 从字符串前添加补充内容。 用法2： string.padEnd (n,&#39;补充内容&#39;) 从字符串后添加补充内容。 例子： 12345678910// 在字符串前补充&quot;-&quot;，直到字符串的长度为5let str1 = &#x27;预备开始&#x27;let result = str1.padStart(5, &#x27;-&#x27;)console.log(result) // 控制台打印：&quot;---预备开始&quot;//在末尾添加&quot;*&quot;，直到字符串的长度为11let str2 = &quot;184&quot;let result = str2.padEnd(11, &quot;*&quot;)console.log(result) // 控制台打印：&quot;184********&quot;复制代码 13. 字符串是否以特定字符（串）开头或结尾 —— startsWith()、endsWith()说明： 用于检测字符串是否以指定的子字符串开始。如果是以指定的子字符串开头返回 true，否则 false。startsWith()、endsWith()方法区分大小写。第二个参数代表从某下标处开始判断是否以特定字符（串）开头或结尾，忽略则startsWith()从下标0开始检测，endsWith()从字符串最后一位下标开始检测。 值得注意的是： 当startsWith() 的第二个参数如果超出了当前字符串的最大长度，依旧生效，返回false。 当endsWith() 的第二个参数如果超出了当前字符串的最大长度，会不生效，改为从字符串最后一位下标开始检测。 需求场景： 判断字符串是否以指定字符开头或结尾 用法1： string.startsWith(searchvalue, start) 用法2： string.endsWith(searchvalue, start) 例子： 12345678910let str = &quot;过去的时候，我们相视一笑，就已过了大半辈子&quot;let result1 = str.startsWith(&quot;过去&quot;)let result2 = str.startsWith(&quot;过去&quot;,10)let result3 = str.endsWith(&quot;半辈子&quot;)let result4 = str.endsWith(&quot;半辈子&quot;,20)console.log(result1); // 控制台打印：trueconsole.log(result2); // 控制台打印：falseconsole.log(result3); // 控制台打印：trueconsole.log(result4); // 控制台打印：false复制代码 14. 字符串长度计算 —— length说明： length属性不仅是数组的属性，同时伪数组，字符串都有length属性。但是遇到某些生僻字如“𩸽”或者表情符号“🙂”，它们的length为2，这时候返回的length可能不是我们真正想要的。这是因为js字符串是由16位的代码单元组成，而不是由Unicode代码点组成。同时js使用两个代码单元表示216及其以上的Unicode代码点。这两个代码单元被称为代理对。一个代码单元被默认为1个长度单位，像“𩸽”或者“🙂”是由两个代码单元组成的代理对，因此它们的length为2。 需求场景： 求出当前字符串长度 用法： string.length 例子： 1234let str = &quot;相约白头偕老，你却悄悄秃了头&quot;let result = str.lengthconsole.log(result) // 控制台打印：14复制代码 15. 字符串截取 —— substr() 和 slice() 和 substring()说明： 字符串截取和拼接是字符串最常用也是最易错的方法。主要原因是 substr() 、 slice() 和 substring()的区别有很多小伙伴还不太明白。 substr()： 参数一（必须）：一个整数，要开始截取字符的下标，如为负则代表从尾部开始截取。参数二（可选）：一个整数，要截取字符的数量。如果省略该参数，则默认为string.length，即当前字符串的长度。 slice() ： 参数一（必须）：一个整数，要开始截取字符的下标，如为负则代表从尾部开始截取。参数二（可选）：一个整数，要结束截取字符的下标，如为负则代表从尾部截取多少个字符。如果省略该参数，则默认为string.length，即当前字符串的长度。 substring() ： 参数一（必须）：一个非负的整数，要开始截取字符的下标。参数二（可选）：一个非负的整数，要结束截取字符的下标。如果省略该参数，则默认为string.length，即当前字符串的长度。 需求场景： 截取指定下标指定长度的字符串 用法1： string.substr(start,length) 用法2： string.slice(start,end) 用法3： string.substring(start,end) 例子： 123456789let str = &#x27;0123456789&#x27;let result1 = str.substr(2,5) // 从下标2开始截取，截取5位let result2 = str.slice(2,5) // 从下标2开始截取，截取到下标5（不含下标5）let result3 = str.substring(2,5) // 从下标2开始截取，截取到下标5（不含下标5）console.log(result1) // 控制台打印：23456console.log(result2) // 控制台打印：234console.log(result3) // 控制台打印：234复制代码 总结这就是关于字符串常用的15个方法详细说明，可在我们工作中的很多时候，可能并不能很好的使用它们。大多是因为不够熟练，看一遍容易忘记，所以我们要时常翻一翻这些常用的方法，也许就能节省你工作中几十分钟~ 为摸鱼大业添砖加瓦 ~ 转自：《看完就懂系列》15个方法教你玩转字符串"},{"title":"","path":"posts/2841.html","text":"输入未知长度字符数组1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; char array_num[100] ; int i = 0, length; do &#123; scanf(&quot;%c&quot;, &amp;array_num[i]); i++; &#125; while (array_num[i - 1] != &#x27;\\n&#x27;); length = i-1; for (i = 0; i &lt; length; i++) printf(&quot;%c&quot;, array_num[i]); getchar();//VS2017中特殊设置，解决CMD窗口闪退问题 return 0;&#125; 冒泡排序12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;void fun1(int num[], int length);int main() &#123; int a[1001]; int k, i, j; scanf(&quot;%d&quot;, &amp;k); for (i = 0; i &lt; k; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; fun1(a, k); for (i = 0; i &lt; k; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125;&#125;void fun1(int num[], int length) &#123; int i, j; for (i = 0; i &lt; length - 1; ++i) &#123; for (j = 0; j &lt; length - i - 1; ++j) &#123; if (num[j] &gt; num[j + 1]) &#123; int t; t = num[j]; num[j] = num[j + 1]; num[j + 1] = t; &#125; &#125; &#125;&#125; 折半查找1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;void fun1(int num[], int length);int fun2(int num[], int length, int x);int main() &#123; int a[1001]; int k, i, j; scanf(&quot;%d&quot;, &amp;k); for (i = 0; i &lt; k; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; fun1(a, k); for (i = 0; i &lt; k; i++) &#123; if (i == 0) &#123; printf(&quot;%d&quot;, a[i]); &#125; else &#123; printf(&quot; %d&quot;, a[i]); &#125; &#125; printf(&quot;\\n&quot;); int flag = fun2(a, k, 4); printf(&quot;%d\\n&quot;, flag);&#125;void fun1(int num[], int length) &#123; int i, j; for (i = 0; i &lt; length - 1; ++i) &#123; for (j = 0; j &lt; length - i - 1; ++j) &#123; if (num[j] &gt; num[j + 1]) &#123; int t; t = num[j]; num[j] = num[j + 1]; num[j + 1] = t; &#125; &#125; &#125;&#125;int fun2(int num[], int length, int x) &#123; int low = 0; int high = length - 1; while (low &lt; high) &#123; int mid = (high + low) / 2; if (x = num[mid]) &#123; return mid; &#125; else if (num[mid] &gt; x) &#123; high = mid - 1; &#125; else &#123; low = mid+1;; &#125; &#125; return 0;&#125; 桶排序12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char str[100]; int book[100] = &#123; 0 &#125;; while (scanf(&quot;%s&quot;, str) != EOF) &#123; int len = strlen(str); for (int i = 0; i &lt; len; i++) &#123; book[str[i]]++; &#125; for (int i = 0; i &lt; 95; i++) &#123; if (book[i] != 0) &#123; printf(&quot;%c&quot;, i); &#125; &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;int num[100];int n;void quicksort(int left, int right)&#123; int i, j,t, temp; if (left &gt; right) &#123; return; &#125; temp = num[left]; i = left; j = right; while (i != j) &#123; while (num[j] &gt;= temp &amp;&amp; j &gt; i) &#123; j--; &#125; while (num[i] &lt;= temp &amp;&amp; i &lt; j) &#123; i++; &#125; if (i &lt; j) &#123; t = num[i]; num[i] = num[j]; num[j] = t; &#125; &#125; num[left] = num[i]; num[i] = temp; quicksort(left, i - 1); quicksort(i + 1, right); return;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp; n); int i; for (i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;num[i]); &#125; quicksort(0, n-1); for (i = 0; i &lt; n; i++) &#123; if (i == 0) &#123; printf(&quot;%d&quot;, num[0]); &#125; else &#123; printf(&quot; %d&quot;, num[i]); &#125; &#125; printf(&quot;\\n&quot;); return 0;&#125; 埃氏筛法123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int fun(int n);int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); int k; k = fun(n); printf(&quot;%d\\n&quot;, k); return 0;&#125;int fun(int n) &#123; int count = 0; int num[n + 1]; int i; num[0] = 0; num[1] = 0; for (i = 2; i &lt; n; i++) &#123; num[i] = 1; &#125; int j; for (j = 2; j &lt;= n; j++) &#123; if (num[j] == 1) &#123; count++; int x; for (x = 2 * j; x &lt;= n; x = x + j) &#123; num[x] = 0; &#125; &#125; &#125; return count;&#125; 队列结构体 解密：一串字符，第1个数删除，第2个数放到最后；第3个数删除，第4个数放到最后.。。。。 例如：631758924加密后为615947283 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;struct queue&#123; int data[100]; int head; int tail;&#125;;int main()&#123; int n; struct queue q; scanf(&quot;%d&quot;, &amp;n); int i; for (i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;q.data[i]); &#125; q.head = 0; q.tail = n; while (q.head &lt; q.tail) &#123; printf(&quot;%d &quot;, q.data[q.head]); q.data[q.tail] = q.data[q.head + 1]; q.tail++; q.head += 2; &#125; printf(&quot;\\n&quot;); return 0;&#125; 栈判断回文串 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; int len; char s[101]; gets(s); len = strlen(s); int mid = len / 2-1; /// &lt;summary&gt; /// 左边压栈 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; char str[101]; int top = 0; int i; for (i = 0;i &lt;= mid; i++) &#123; str[++top] = s[i]; &#125; /// &lt;summary&gt; /// 判断 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; int next=0; if (len % 2 == 0) &#123; next = mid + 1; &#125; else &#123; next = mid + 2; &#125; for (i = next; i &lt; len; i++) &#123; if (s[i] != str[top]) &#123; break; &#125; top--; &#125; if (top == 0) &#123; printf(&quot;Yes\\n&quot;); &#125; else &#123; printf(&quot;No\\n&quot;); &#125; return 0;&#125; 深度优先1-10中选数字，使得a’b’c+def&#x3D;hij;不能重复选123456789void dfs(int step)&#123; 判断边界 尝试每一中可能for(i=0;i&lt;=n;i++) &#123; 继续下一步dfs(step+1) &#125; 返回&#125; 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;int a[10],book[10];int sum=0;void dfs(int step)&#123; int i; if(step==10) &#123; if(a[1]*100+a[2]*10+a[3]+a[4]*100+a[5]*10+a[6]==a[7]*100+a[8]*10+a[9]) &#123; sum++; printf(&quot;%d%d%d+%d%d%d=%d%d%d\\n&quot;,a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9]); &#125; return; &#125; for(i=1;i&lt;=9;i++) &#123; if(book[i]==0) &#123; a[step]=i; book[i]=1; dfs(step+1); book[i]=0; &#125; &#125; return;&#125;int main()&#123; dfs(1); printf(&quot;Total ： %d\\n&quot;,sum/2); return 0;&#125; 迷宫n行m列，0表示可走，1表示障碍，从（startx，starty）到（p，q)，找最短路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;int min=999;int a[51][51];book[51][51];int n,m;int p,q;int next[4][2]=&#123; &#123;1,0&#125;, &#123;0,1&#125;, &#123;-1,0&#125;, &#123;0,-1&#125;&#125;;void dfs(int x,int y,int step)&#123; if(x==p&amp;&amp;y==q) &#123; if(step&lt;min) &#123; min=step; &#125; return; &#125; int i=0; for(i=0;i&lt;4;i++) &#123; int tx = x+next[i][0]; int ty = y+next[i][1]; if(tx&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;m) &#123; if(book[tx][ty]==0&amp;&amp;a[tx][ty]==0) &#123; book[tx][ty]=1; dfs(tx,ty,step+1); book[tx][ty]=0; &#125; &#125; &#125; return;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); int i,j; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; scanf(&quot;%d&quot;,&amp;a[i][j]); &#125; &#125; int startx,starty; scanf(&quot;%d %d %d %d&quot;,&amp;startx,&amp;starty,&amp;p,&amp;q); book[startx][starty]=1; dfs(startx,starty,0); printf(&quot;%d\\n&quot;,min); return 0;&#125; 样例输入 123456785 40 0 1 00 0 0 00 0 1 00 1 0 00 0 0 10 0 3 2 样例输出 17 广度优先迷宫n行m列，0表示可走，1表示障碍，从（startx，starty）到（p，q)，找最短路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;stdio.h&gt;struct note&#123; int x;// 横坐标 int y;// 纵坐标 int s;// 步数&#125;;int main()&#123; struct note que[2501]; int a[51][51]; int book[51][51]=&#123;0&#125;; int next[4][2]=&#123; &#123;0,1&#125;, &#123;1,0&#125;, &#123;0,-1&#125;, &#123;-1,0&#125; &#125;; int head,tail; int n,m; int i,j; int startx,starty,p,q; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(i=1;i&lt;=n;i++) &#123; for(j=1;j&lt;=m;j++) &#123; scanf(&quot;%d&quot;,&amp;a[i][j]); &#125; &#125; scanf(&quot;%d %d %d %d&quot;,&amp;startx,&amp;starty,&amp;p,&amp;q); head=1; tail=1; que[tail].x=startx; que[tail].y=starty; que[tail].s=0; tail++; book[startx][starty]=1; int k,tx,ty; int flag=0; while(head&lt;tail) &#123; for(k=0;k&lt;4;k++) &#123; tx=que[head].x+next[k][0]; ty=que[head].y+next[k][1]; if(tx&gt;0&amp;&amp;tx&lt;=n&amp;&amp;ty&gt;0&amp;&amp;ty&lt;=m) &#123; if(a[tx][ty]==0&amp;&amp;book[tx][ty]==0) &#123; book[tx][ty]=1; que[tail].x=tx; que[tail].y=ty; que[tail].s=que[head].s+1; tail++; &#125; &#125; if(tx==p&amp;&amp;ty==q) &#123; flag=1; break; &#125; &#125; if(flag==1) &#123; break; &#125; head++; &#125; printf(&quot;%d\\n&quot;,que[tail-1].s); return 0;&#125; 样例输入 12345675 40 0 1 00 0 0 00 0 1 00 1 0 00 0 0 10 0 3 2 样例输出 17 不要输出多余的零1%g 数据类型 定义一个未知行数和列数的二维数组1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int **num = (int**)malloc(sizeof(int*)*n); int i; for(i=0;i&lt;n;i++)&#123; num[i]=(int*)malloc(sizeof(int)*n); &#125; int j; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n;j++)&#123; scanf(&quot;%d&quot;,&amp;num[i][j]); &#125; &#125; return 0;&#125; 前缀和前缀和是指某序列的前n项和，可以把它理解为数学上的数列的前n项和，而差分可以看成前缀和的逆运算。合理的使用前缀和与差分，可以将某些复杂的问题简单化。 一维前缀和输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和。 我们很容易想出暴力解法，遍历区间求和。 代码如下： 123456789101112131415int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);while(m--)&#123; int l,r; int sum=0; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); for(int i=l;i&lt;=r;i++) &#123; sum+=a[i]; &#125; printf(&quot;%d\\n&quot;,sum);&#125; 这样的时间复杂度为O(n*m)，如果n和m的数据量稍微大一点就有可能超时，而我们如果使用前缀和的方法来做的话就能够将时间复杂度降到O(n+m),大大提高了运算效率。 具体做法： 首先做一个预处理，定义一个sum[]数组，sum[i]代表a数组中前i个数的和。 求前缀和运算： 1234567const int N=1e5+10;int sum[N],a[N]; //sum[i]=a[1]+a[2]+a[3].....a[i];for(int i=1;i&lt;=n;i++)&#123; sum[i]=sum[i-1]+a[i]; &#125; 然后查询操作： 123 scanf(&quot;%d%d&quot;,&amp;l,&amp;r); printf(&quot;%d\\n&quot;, sum[r]-sum[l-1]);对于每次查询，只需执行sum[r]-sum[l-1] ，时间复杂度为O(1) 原理 sum[r] &#x3D;a[1]+a[2]+a[3]+a[l-1]+a[l]+a[l+1]……a[r];sum[l-1]&#x3D;a[1]+a[2]+a[3]+a[l-1];sum[r]-sum[l-1]&#x3D;a[l]+a[l+1]+……+a[r]; 二维前缀和 知道了两个点的位置和他们的二维前缀和图中红色是左上角的那个点的二维前缀和红色+黄色部分是右下角的那个点的二维前缀和是不是可以用这个来求出他们之间的矩阵的和呢？也就是这一部分： 1D - B - C + A 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;#define int long longusing namespace std;const int Max = 1003;int a[Max][Max];int f[Max][Max];signed main()&#123; freopen(&quot;acioi.in&quot;,&quot;r&quot;,stdin); int n,m,c; cin &gt;&gt; n &gt;&gt; m &gt;&gt; c; for(register int i = 1;i &lt;= n;++ i) for(register int j = 1;j &lt;= m;++ j) cin &gt;&gt; a[i][j],f[i][j] = f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1] + a[i][j]; int k; cin &gt;&gt; k; for(register int i = 1;i &lt;= k;++ i) &#123; int x1,x2,y1,y2;//x1,y1是左上角的坐标，另一对是右下角的坐标 cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; cout &lt;&lt; f[x2][y2] - f[x1 - 1][y2] - f[x2][y1 - 1] + f[x1 - 1][y1 - 1]; &#125; cout &lt;&lt; M &lt;&lt; endl; return 0;&#125; 2021计设2021年程序设计实践练习11123： duoxida的数字游戏 [ Submit Code ] [ Top 20 Runs ] [ Runs Status ] Acceteped : 892 Submit : 2072 Time Limit : 1000 MS Memory Limit : 65536 KB Description 题目描述duoxida很喜欢玩数字游戏，某天无聊的时候，他决定一个人玩数字游戏。他黑板上写下了一行总共有n个数，然后对其重复进行一个操作: 找到从左到右第k个的数x，在数字序列的最右边增加一个x，删除最左边的第一个数字。 duoxida很想知道知道多少次操作后，这个序列就变得完全一样。输入数据的第一行为一个整数t,1&lt;&#x3D;t&lt;&#x3D;10，表示测试用例的个数。每组样例的第一行是n，k,(1≤k≤n≤1000)。 接下来一行有n个整数。输出每个用例输出一行，即操作次数，如果这个序列无法变得完全一样，输出”-1”。样例输入2 3 2 3 1 1 3 1 3 1 1 样例输出1 -1 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;int main()&#123; int t; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; int n, k; scanf(&quot;%d %d&quot;, &amp;n, &amp;k); int x[1001]; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;x[i]); &#125; int flag = 1; int a = x[k - 1]; for (int i = k; i &lt; n; i++) &#123; if (a != x[i]) &#123; flag = 0; break; &#125; &#125; if (flag == 0) printf(&quot;-1\\n&quot;); else &#123; int sum = 0; for (int i = k - 2; i &gt; 0; i--) &#123; if (x[i] == a) &#123; sum++; &#125; else break; &#125; printf(&quot;%d\\n&quot;, k - 1 - sum); &#125; &#125; return 0;&#125; 1127： 数列 [ Submit Code ] [ Top 20 Runs ] [ Runs Status ] Acceteped : 567 Time Limit : 3000 MS Description 题目描述数列生成规则如下：第一项的值为a,第二项的值为b, (0 ≤ a,b ≤ 9)前两项之积，如果为一位数，则为本项的值；如果为两位数，则十位为本项，个位为后一项。比如a&#x3D;2,b&#x3D;3,那么数列为2,3,6,1,8,8,…。 请写一个程序，输出数列的第n个元素的值。输入第一行是一个整数K，表示样例的个数。 每个样例的第一行是三个整数a,b,Q(1 ≤ Q ≤ 1,000),其中Q表示查询的次数。 以后的Q行，每行一个整数n,(1 ≤ n ≤ 1,000,000,000)。输出每个样例的每个查询输出一行，即对应元素的值。样例输入3 2 3 4 1 2 3 4 3 3 4 1 2 3 4 9 9 1 100000000 样例输出2 3 6 1 3 3 9 2 2 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void shulie(int b, int c, int m)&#123; int x[1001]=&#123;0&#125;; x[0]=b;x[1]=c; int i,o,n,p; for(i=2;i&lt;108;i++) &#123; n=x[i-1]*x[i-2]; if(n&lt;10) x[i]=n; else &#123; x[i]=n/10; x[i+1]=n%10; i++; &#125; &#125; for(i=0;i&lt;m;i++) &#123; scanf(&quot;%d&quot;,&amp;o); if(o&lt;108) printf(&quot;%d\\n&quot;,x[o-1]); else&#123; p=(o-108)%8+100; printf(&quot;%d\\n&quot;,x[p-1]); &#125; &#125;&#125;int main()&#123; int k, a, b, q, n, i; scanf(&quot;%d&quot;, &amp;k); while (k--) &#123; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;q); shulie(a, b, q); &#125; return 0;&#125; 1163： ASCII [ Submit Code ] [ Top 20 Runs ] [ Runs Status ] Acceteped : 1654 Submit : 5058 Time Limit : 1000 MS Memory Limit : 65536 KB Description 题目描述给你一段ASCII编码的文字，输出其每个字符的ASCII码。输入一段文字，由ASCII码字符组成。输出先输出行号，行号为16进制，占5位，从0开始计数，行号前导为0，然后空一格。 每行最多输出32个字符的ASCII码，每个ASCII码为16进制，占2位，前导为0，中间用空格隔开。 所有16进制使用大写AF表示1015。最后一行行末无空格，无换行。样例输入ACM International Collegiate Programming Contest, I LOVE YOU Lotus is a mystic symbol. 样例输出00000 41 43 4D 20 49 6E 74 65 72 6E 61 74 69 6F 6E 61 00001 6C 20 43 6F 6C 6C 65 67 69 61 74 65 20 50 72 6F 00002 67 72 61 6D 6D 69 6E 67 20 43 6F 6E 74 65 73 74 00003 2C 0A 49 20 4C 4F 56 45 20 59 4F 55 0A 4C 6F 74 00004 75 73 20 69 73 20 61 20 6D 79 73 74 69 63 20 73 00005 79 6D 62 6F 6C 2E 20 0A 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;int main()&#123; char s[100000]; char c; int a = 0; while((c=getchar()) != EOF) &#123; s[a++] = c; &#125; int lineCnt; int line = 0; if(a % 16 == 0) &#123; lineCnt = a / 16; &#125; else &#123; lineCnt = a / 16 + 1; &#125; for(int i = 0; i &lt; lineCnt - 1; i++) &#123; printf(&quot;%05X &quot;, line++); for(int j = 0; j &lt; 15; j++) &#123; printf(&quot;%02X &quot;, s[i*16+j]); &#125; printf(&quot;%02X&quot;, s[i*16+15]); printf(&quot;\\n&quot;); &#125; printf(&quot;%05X &quot;, line++); for(int j = 0; j &lt; a%16 - 1; j++) &#123; printf(&quot;%02X &quot;, s[(lineCnt-1)*16+j]); &#125; printf(&quot;%02X&quot;, s[(lineCnt-1)*16+a%16-1]); return 0; &#125; 1170： ICPC [ Submit Code ] [ Top 20 Runs ] [ Runs Status ] Acceteped : 1009 Submit : 2432 Time Limit : 1000 MS Memory Limit : 65536 KB Description 题目描述ACM&#x2F;ICPC比赛涉及的知识点非常多，一个队伍三个人需要能够互补。一个队伍某个知识点的高度是三个人中水平最高的那个人决定。现在给你三个人的每个知识点的水平情况，请计算一下这个队伍的水平。输入存在多个样例。每个样例的第一行是一个整数N(3≤N≤100)，表示所有知识点的个数。 以后三行为每个人每个知识点的水平情况。水平用A到E表示，一共5级，A最强，E最弱，依次递减。输出每个样例输出两行，第一行为一个字符串，一个队伍的各个知识点的水平情况。第二行是5个整数，表示5个级别知识点的个数,每个整数之间有一个空格。样例输入3 ABC BBB AAE 4 DDBD DEDC CDDE 0 样例输出AAB 2 1 0 0 0 CDBC 0 1 2 1 0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;stdio.h&gt;int main()&#123; int n; while(scanf(&quot;%d&quot;,&amp;n)) &#123; if(n==0) &#123; return 0; &#125; getchar(); char x[3][100]; int i,j; for(i=0;i&lt;3;i++) &#123; for(j=0;j&lt;n;j++) &#123; scanf(&quot;%c&quot;,&amp;x[i][j]); &#125; getchar(); &#125; char max[100]; int t=0; for(j=0;j&lt;n;j++)&#123; char max1=x[0][j]; for(i=0;i&lt;3;i++) &#123; if(max1&gt;x[i][j]) &#123; max1=x[i][j]; &#125; &#125; max[t]=max1; t++; &#125; int a=0,b=0,c=0,d=0,e=0; for(i=0;i&lt;t;i++) &#123; printf(&quot;%c&quot;,max[i]); if(max[i]==&#x27;A&#x27;) &#123; a++; &#125; else if(max[i]==&#x27;B&#x27;) &#123; b++; &#125; else if(max[i]==&#x27;C&#x27;) &#123; c++; &#125; else if(max[i]==&#x27;D&#x27;) &#123; d++; &#125; else &#123; e++; &#125; &#125; printf(&quot;\\n&quot;); printf(&quot;%d %d %d %d %d\\n&quot;,a,b,c,d,e); &#125; return 0; &#125; 1241: Permutation [ Submit Code ] [ Top 20 Runs ] [ Runs Status ] Acceteped : 1179 Submit : 2750 Time Limit : 1000 MS Memory Limit : 65536 KB Description 输入第一行是一个整数K(1≤K≤1000)，表示样例的个数。 每个样例占一行，第一个整数是n(1≤n≤100)，以后的n个整数xi,1≤xi≤n且 xi是唯一的, (1x12x2⋯⋯nxn)表示一个置换。输出输出一个样例的结果。样例输入3 3 1 2 3 3 2 1 3 3 2 3 1 样例输出1 2 3 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;int gcd(int a,int b) &#123; if(b==0) return a; return gcd(b,a%b);&#125;int main()&#123; int k; scanf(&quot;%d&quot;,&amp;k); while(k--)&#123; int n; scanf(&quot;%d&quot;,&amp;n); int num[120]; for(int i = 1 ;i &lt;= n;i++) &#123; scanf(&quot;%d&quot;,&amp;num[i]); &#125; long long int res = 1; for(int i = 1 ;i &lt;= n;i++)&#123; long long int tmp = 1; int pos = num[i]; while(pos!=i)&#123; tmp++; pos = num[pos]; &#125; res = res * tmp /gcd(res,tmp); &#125; printf(&quot;%d\\n&quot;,res); &#125; return 0;&#125; 1251: Colombian Number [ Submit Code ] [ Top 20 Runs ] [ Runs Status ] Acceteped : 2630 Submit : 6299 Time Limit : 1000 MS Memory Limit : 65536 KB Description Colombian Number题目描述对于正整数n,不存在整数k,使得n等于k加上k的数码累加和，我们称这样的数是哥伦比亚数或者自我数。 比如 11就不是一个哥伦比亚数，因为10加上10的数码累加和1等于11;而20则是一个哥伦比亚数。输入第一行是一个整数K(K≤10,000)，表示样例的个数。 以后每行一个正整数n(1≤n≤1,000,000,000)输出每行输出一个样例的结果，如果是哥伦比亚数输出”Yes”,否则输出”No”。样例输入5 1 2 3 20 21 样例输出Yes No Yes Yes No 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;int Colnum(int i)&#123; int m = i; while(i != 0) &#123; m += i%10; i /= 10; &#125; return m;&#125;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int n,i; int flag = 1; scanf(&quot;%d&quot;,&amp;n); for(i = n-1; i &gt; 0 &amp;&amp; i &gt; n-81; i--) &#123; if(Colnum(i) == n) &#123; flag = 0; break; &#125; &#125; if(flag==1) &#123; printf(&quot;Yes\\n&quot;); &#125; else &#123; printf(&quot;No\\n&quot;); &#125; &#125; return 0;&#125;"},{"title":"vue axios传中文参数导致乱码的解决方案","path":"posts/33d0.html","text":"问题描述1234567891011121314151617181920var that = this; var name = that.signform.signname; var username = that.signform.signusername; var password = that.signform.signpassword; var user_type = that.sign_user_type; var email = that.signform.mailAddress; var studentid = that.signform.studentid; this.$axios(&#123; method: &quot;post&quot;, url: this.$api + `/Register/?name=$&#123;name&#125;&amp;username=$&#123;username&#125;&amp;password=$&#123;password&#125;&amp;user_type=$&#123;user_type&#125;&amp;email=$&#123;email&#125;&amp;studentid=$&#123;studentid&#125;`, //利用了字符串模板来携带id &#125;) .then((res) =&gt; &#123; console.log(res); this.changeCode(); &#125;) .catch((req) =&gt; &#123; // console.log(req); &#125;); 在vue axios post 请求注册用户时，刚开始通过如上字符拼接形式调用api时，在服务器后端出现了utf-8汉语乱码： 图中name字段本是中文，服务器后端出现了utf-8汉语乱码， 查询bing后有如下几种解决办法： 其中有添加 headers: { ​ “Content-Type”: “application&#x2F;x-www-form-urlencoded;charset&#x3D;UTF-8” ​ }, 但个人实验了一下没有解决问题， 之后又试了下js函数把字符转换，没有解决问题。 方法：使用vue axios推荐的vue-axios的使用及其get与post网络请求 即： get请求时用如下方式代替字符拼接方式 12345678910111213// Optionally the request above could also be done asaxios.get(&#x27;/user&#x27;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); post请求时一样： 12345678910axios.post(&#x27;/user&#x27;, &#123; firstName: &#x27;Fred&#x27;, lastName: &#x27;Flintstone&#x27; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 所以项目中最终采取的代码： 12345678910111213141516let data = new FormData();data.append(&quot;name&quot;, this.signform.signname);data.append(&quot;username&quot;, this.signform.signusername);data.append(&quot;password&quot;, this.signform.signpassword);data.append(&quot;user_type&quot;, this.sign_user_type);data.append(&quot;email&quot;, this.signform.mailAddress);data.append(&quot;studentid&quot;, this.signform.studentid);console.log(data);var that = this;axios .post(this.$api + &quot;/Register/&quot;, data) //以slash结尾 .then(function (response) &#123; console.log(response.data); &#125;) .catch((err) =&gt; &#123;&#125;); 注意的时此时后台时没有显示字段的，但是数据库里已经加入了（注册功能哈）。"},{"title":"操作系统之调度","path":"posts/4be5.html","text":"调度调度的基本概念调度研究的问题：当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是调度研究的问题。 举个有味道的例子：现在有4个人要上厕所(他们几乎同时到达)，他们分别需要使用厕所3分钟、10分钟、1分钟、4分钟。但是他们面前只有一个厕所，而且厕所里面只有一个马桶，那我们应该怎么确定他们上厕所的顺序呢？*我们有以下的方案：**1. 谁先来，谁就先用厕所。\\2. 谁需要使用的时间少，谁先用厕所。***我们先说说第一种方案，这种方案很公平，谁先来谁先用，但是这样会产生一个问题。假如他们来的顺序是10分钟、4分钟、3分钟、1分钟，显然，采用这种方案的话，对于最后一个人，他上厕所1分钟要等17分钟，估计翔都憋不住了吧…我们再说下第二种方案，采用这种方案的话，虽然没有第一种方案公平，但是这4个人的整体平均等待时间是最少的。(平均等待时间 &#x3D; 每个人等待的时间的和 &#x2F; 人数)**** 在上面的例子中，厕所就是资源，方案就是调度的规则，而调度就是安排他们上厕所。 我们回到操作系统，在多道程序系统中，进程的数量往往是多于处理机个数的，这样就导致处理机不能并行的处理所有进程。处理机调度，就是从就绪队列中按照某种的算法选择一个进程并将处理机分配给它，以实现进程的并发运行。 操作系统的调度有三个层次，分别是高级调度、中级调度和低级调度。下面分别介绍它们。 高级调度 (外存 –&gt; 内存)我们知道是计算机的内存空间是有限，所以有时操作系统无法将用户提交的作业全部放入内存 (在单道批系统时)，因此操作系统就需要确定某种算法，决定作业调度内存的顺序。高级调度，就是按某种算法在外存中处于后备队列的作业中挑选一个(或多个)作业，给它分配内存等必要资源，并建立相应的进程(建立PCB)，以使它(们)获得竞争处理机的权利。高级调度是外存与内存之间的调度。在这里，每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，而调出的时机必然是作业运行结束后。这种调度就好像刚刚的上厕所问题，厕所外的人处于后备队列，而高级调度的任务就类似把人从厕所外调入到厕所内。 中级调度 (外存 –&gt; 内存)背景：在引入了虚拟存储技术之后，操作系统可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存稍有空闲时，操作系统再把它调回内存。回顾一下，我们之前说过进程有几种状态，如 就绪态、阻塞态、运行态…，那被调到外存等待的进程处于什么状态呢？这些进程会处于挂起态。值得注意的，该进程的数据段和代码段会被调回外存，但PCB依旧会留在内存中的，并不会被调回外存，因为操作系统只有通过该进程的PCB，才能对其进行管理。被挂起进程的PCB会被操作系统放到挂起队列中。 中级调度，就是决定将哪个挂起状态的进程从外存重新调回内存。注意和高级调度区分，虽然同样是从外存调到内存，但高级调度是调入，中级调度是调回。由于一个进程可能会被多次调出、调回内存，因此中级调度发生的频率要比高级调度的高。 补充：进程的挂起态与七状态模型暂时调到外存等待的进程状态为挂起态。挂起态其实又可以进一步细分为就绪挂起、阻塞挂起两种状态，于是，五状态模型现在变成了七状态模型。 注意： 注意”挂起态”和”阻塞态”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程实体(除PCB外)调到外存，而阻塞态的进程实体还留存在内存中。 有的操作系统不只把挂起态分为阻塞挂起和就绪挂起，甚至会根据阻塞原因的不同把阻塞挂起态的进程进一步细分为多个队列。 低级调度 (内存 –&gt; CPU)低级调度的主要任务是按照某种规则从就绪队列中选取一个进程，将CPU分配给它。低级调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置低级调度。而且低级调度的频率很高，一般几十毫秒一次。 又是一个有味道的例子故事背景：现在有很多个人想上厕所，他们面前有一间厕所，厕所里面有三个马桶。 接下来，我们把厕所看作是内存，马桶看作是CPU，现在我们来看看这三种调度与这例子的类比。 高级调度：研究怎么让还没进入过厕所的人进入厕所。(厕所外 –&gt; 厕所内，之前一直在厕所外) 中级调度：有的人进入了厕所，但是尿不出来，于是他们被赶了出去。中级调度就是研究怎么让这些被赶出去的人再次回到厕所。 (厕所外 –&gt; 厕所内，之前进入过厕所) 低级调度：研究怎么给厕所内的人分配马桶。(厕所内 –&gt; 马桶上) 总结 调度的算法先来先服务调度算法（FCFS）最简单的一个调度算法，就是非抢占式的先来先服务（*First Come First Severd, FCFS*）算法了。 顾名思义，先来后到，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。 这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。 FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。 最短作业优先调度算法（SJF）最短作业优先（*Shortest Job First, SJF*）调度算法同样也是顾名思义，它会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。 这显然对长作业不利，很容易造成一种极端现象。 比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。 高响应比优先调度算法（HRRN）前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。 那么，高响应比优先 （*Highest Response Ratio Next, HRRN*）调度算法主要是权衡了短作业和长作业。 每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行，「响应比优先级」的计算公式： 时间片轮转调度算法（RR）最古老、最简单、最公平且使用最广的算法就是时间片轮转（*Round Robin, RR*）调度算法。 每个进程被分配一个时间段，称为时间片（*Quantum*），即允许该进程在该时间段中运行。 如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程； 如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换； 另外，时间片的长度就是一个很关键的点： 如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率； 如果设得太长又可能引起对短作业进程的响应时间变长。将 通常时间片设为 20ms~50ms 通常是一个比较合理的折中值。 多级反馈队列调度算法多级反馈队列（*Multilevel Feedback Queue*）调度算法是「时间片轮转算法」和「最高优先级算法」的综合和发展。 顾名思义： 「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列； 来看看，它是如何工作的： 设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短； 新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成； 当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行； 可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的兼顾了长短作业，同时有较好的响应时间。 几种调度算法的比较： 参考文章： CPU调度算法总结 大厂面试爱问的「调度算法」，20 张图一举拿下"},{"title":"操作系统之信号量、P、V操作","path":"posts/c299.html","text":"信号量是最早出现的用来解决进程同步与互斥问题的机制(也可实现进程通信)，包括一个称为信 号量的变量及对它进行的两个原语操作。信号量为一个整数，我们设这个信号量为：sem。很显然，我们规定在sem大于等于零的时候代表可供并发进程使用的 资源实体数，sem小于零的时候，表示正在等待使用临界区的进程的个数。根据这个原则，在给信号量附初值的时候，我们显然就要设初值大于零。 p操作和v操作是不可中断的程序段，称为原语。P,V原语中P是荷兰语的Passeren，相当于英文的pass, V是荷兰语的Verhoog,相当于英文中的incremnet。 且在P,V愿语执行期间不允许有中断的发生。 对于具体的实现，方法非常多，可以用硬件实现，也可以用软件实现。这种信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点。 首先应弄清PV操作的含义：PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下： ​ P（S）：①将信号量S的值减1，即S&#x3D;S-1； ​ ②如果S&gt;&#x3D;0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。 ​ V（S）：①将信号量S的值加1，即S&#x3D;S+1； ​ ②如果S&gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。 PV操作的意义：我们用信号量及PV操作来实现进程的同步和互斥。PV操作属于进程的低级通信。 什么是信号量？信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该 信号量的下一个进程。信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的 进程个数。注意，信号量的值仅能由PV操作来改变。 一般来说，信号量S&gt;&#x3D;0时，S表示可用资源的数量。执行一次P操作意味着请求分配一个单位资源，因此S的值减1； 当S&lt;0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。而执行一个V操作意味着释放一个单位资源，因此S的值加1； 若S&lt;&#x3D;0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去 利用信号量和PV操作实现进程互斥的一般模型是：进程P1 进程P2 …… 进程Pn …… …… …… P（S）； P（S）； P（S）； 临界区； 临界区； 临界区； V（S）； V（S）； V（S）； …… …… …… …… 其中信号量S用于互斥，初值为1 使用PV操作实现进程互斥时应该注意的是： （1）每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。 （2）P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。 （3）互斥信号量的初值一般为1。 利用信号量和PV操作实现进程同步PV操作是典型的同步机制之一。用一个信号量与一个消息联系起来，当信号量的值为0时，表示期望的消息尚未产生；当信号量的值非0时，表示期望的消息已经存在。用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息。 利用信号量和PV操作实现进程互斥的一般模型是： 进程A 进程B …. …. L: P(信号量) L2:V(信号量） …. …. 使用PV操作实现进程同步时应该注意的是： （1）分析进程间的制约关系，确定信号量种类。在保持进程间有正确的同步关系情况下，哪个进程先执行，哪些进程后执行，彼此间通过什么资源（信号量）进行协调，从而明确要设置哪些信号量。 （2）信号量的初值与相应资源的数量有关，也与P、V操作在程序代码中出现的位置有关。 （3）同一信号量的P、V操作要成对出现，但它们分别在不同的进程代码中。 【例1】生产者-消费者问题 在多道程序环境下，进程同步是一个十分重要又令人感兴趣的问题，而生产者-消费者问题是其中一个有代表性的进程同步问题。下面我们给出了各种情况下的生产者-消费者问题，深入地分析和透彻地理解这个例子，对于全面解决操作系统内的同步、互斥问题将有很大帮助。 12345678910111213141516171819202122232425262728293031（1）一个生产者，一个消费者，公用一个缓冲区。定义两个同步信号量：empty——表示缓冲区是否为空，初值为1。full——表示缓冲区中是否为满，初值为0。生产者进程while(TRUE)&#123; 生产一个产品; P(empty); 产品送往Buffer; V(full); &#125;消费者进程while(TRUE)&#123; P(full); 从Buffer取出一个产品; V(empty); 消费该产品; &#125; （2）一个生产者，一个消费者，公用n个环形缓冲区。 定义两个同步信号量： empty——表示缓冲区是否为空，初值为n。 full——表示缓冲区中是否为满，初值为0。 ​ 设缓冲区的编号为1～n&amp;61485;1，定义两个指针in和out，分别是生产者进程和消费者进程使用的指针，指向下一个可用的缓冲区。 生产者进程 12345678910111213while(TRUE)&#123; 生产一个产品; P(empty); 产品送往buffer(in); in=(in+1)mod n; V(full); &#125; 消费者进程 12345678910111213while(TRUE)&#123;P(full); 从buffer(out)中取出产品; out=(out+1)mod n; V(empty); 消费该产品; &#125; （3）一组生产者，一组消费者，公用n个环形缓冲区 ​ 在这个问题中，不仅生产者与消费者之间要同步，而且各个生产者之间、各个消费者之间还必须互斥地访问缓冲区。 定义四个信号量： empty——表示缓冲区是否为空，初值为n。 full——表示缓冲区中是否为满，初值为0。 mutex1——生产者之间的互斥信号量，初值为1。 mutex2——消费者之间的互斥信号量，初值为1。 ​ 设缓冲区的编号为1～n&amp;61485;1，定义两个指针in和out，分别是生产者进程和消费者进程使用的指针，指向下一个可用的缓冲区。 生产者进程 1234567891011121314151617while(TRUE)&#123; 生产一个产品; P(empty); P(mutex1); 产品送往buffer(in); in=(in+1)mod n; V(mutex1); V(full); &#125; 消费者进程 1234567891011121314151617while(TRUE)&#123;P(full); P(mutex2); 从buffer(out)中取出产品; out=(out+1)mod n; V(mutex2); V(empty); 消费该产品; &#125; 需要注意的是无论在生产者进程中还是在消费者进程中，两个P操作的次序不能颠倒。应先执行同步信号量的P操作，然后再执行互斥信号量的P操作，否则可能造成进程死锁。 【例2】桌上有一空盘，允许存放一只水果。爸爸可向盘中放苹果，也可向盘中放桔子，儿子专等吃盘中的桔子，女儿专等吃盘中的苹果。规定当盘空时一次只能放一只水果供吃者取用，请用P、V原语实现爸爸、儿子、女儿三个并发进程的同步。 分析 在本题中，爸爸、儿子、女儿共用一个盘子，盘中一次只能放一个水果。当盘子为空时，爸爸可将一个水果放入果盘中。若放入果盘中的是桔子，则允许儿子吃，女 儿必须等待；若放入果盘中的是苹果，则允许女儿吃，儿子必须等待。本题实际上是生产者-消费者问题的一种变形。这里，生产者放入缓冲区的产品有两类，消费 者也有两类，每类消费者只消费其中固定的一类产品。 ​ 解：在本题中，应设置三个信号量S、So、Sa，信号量S表示盘子是否为空，其初值为l；信号量So表示盘中是否有桔子，其初值为0；信号量Sa表示盘中是否有苹果，其初值为0。同步描述如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int S＝1;int Sa＝0;int So＝0;main() &#123; cobegin father(); /*父亲进程*/ son(); /*儿子进程*/ daughter(); /*女儿进程*/ coend&#125;father()&#123; while(1) &#123; P(S); 将水果放入盘中; if（放入的是桔子） V(So); else V(Sa); &#125;&#125;son() &#123; while(1) &#123; P(So); 从盘中取出桔子; V(S); 吃桔子; &#125;&#125;daughter()&#123; while(1) &#123; P(Sa); 从盘中取出苹果; V(S); 吃苹果; &#125;&#125; 例题3设公交车上,司机和售票员的活动如下：司机;启动车辆;正常行使,到站停车. 售票员;关车门,售票 开车门. 在汽车不断到站 停车 行驶过程中这两个活动有什么同步关系? 用信号量和pv操作实现。 123456789101112131415161718192021设信号量为s1(是否开车)和s2(是否停车),s1=1,s2=0;司机进程： 售票员进程：begin beginL1: L2:P(S1); 关闭车门；启动车辆； V(s1); 正常行驶； 售票；V(s2）； P(s2);goto L1; 开车门；end； goto L2; end； 思考题：四个进程A、B、C、D都要读一个共享文件F，系统允许多个进程同时读文件F。但限制是进程A和进程C不能同时读文件F，进程B和进程D也不能同时读文件F。为了使这四个进程并发执行时能按系统要求使用文件，现用PV操作进行管理，请回答下面的问题： （1）应定义的信号量及初值： 。 （2）在下列的程序中填上适当的P、V操作，以保证它们能正确并发工作： A() B() C() D() { { { { [1]; [3]; [5]; [7]; read F; read F; read F; read F; [2]; [4]; [6]; [8]; } } } } 思考题解答：（1）定义二个信号量S1、S2，初值均为1，即：S1&#x3D;1，S2&#x3D;1。其中进程A和C使用信号量S1，进程B和D使用信号量S2。 （2）从[1]到[8]分别为：P(S1) V(S1) P(S2) V(S2) P(S1) V(S1) P(S2) V(S2) 信号量、PV操作是解决进程间的同步与互斥问题的。 ★ 做题时尤其要注意隐藏的同步、互斥问题。这些问题通常可以归入生产者－消费者问题和阅读者－写入者问题。 ★ PV操作一定是成对出现的，但是这不意味着它会在一个进程内成对出现。 ★ 在互斥关系中，PV操作一定是在一个进程内成对出现。而且，信号一定大于0,具体多少视情况而定。而对于同步关系，则一对PV操作在两个进程或者更多的进程中出现。 ★ 对于同步关系，信号量可能为0，也可能不为0；用于同步的信号个数可能1个，也可能是多个。 ★ 对信号量为1的，应该先执行V操作。 ★ 在生产者－消费者问题中，要设置三个信号量：empty－空闲的缓存区数量，初值为n；full－已填充的缓存区数量，初值为0；mutex－保证只有一个进程在写入缓存区，初值为1。 ★ 在阅读者－写入者问题中，设置两个信号量：信号量access－控制写入互斥，初值为1；信号量rc－控制对共享变量ReadCount（读者统计值）的互斥访问。转自：http://hongti88.blog.163.com/blog/static/38276487200882733818688/"},{"title":"操作系统习题知识点","path":"posts/116.html","text":"知识点：第一章：操作系统引论操作系统有硬件和软件组成，硬件是CPUC软件建立与活动的基础，而软件是对硬件功能的扩充。硬件包括CPU、内存、I&#x2F;O设备和总线等，软件通常分为应用软件、支撑软件和系统软件。 冯洛伊曼体系：存储器、运算器、控制器、输入设备、输出设备。 操作系统的基本功能：管理系统内各种资源方便用户使用。 操作系统五大功能：存储管理（内存分配、地址映射、内存保护、内存扩充）， 作业和进程管理（作业和进程调度、进程控制、进程通信）， 设备管理（缓冲区管理、设备分配、设备驱动、设备无关性）， 文件管理（文件存储空间管理、文件的一般管理、目录管理、文件读写管理和存取控制）， 用户接口服务（程序接口、图形接口、命令行接口）。 操作系统定义：管理和控制计算机系统内的各种硬件软件资源、有效地组织多道程序正常运行的系统软件（或程序组合），是用户和计算机之间的接口。 操作系统发展的动力：硬件技术的更新、应用需求的扩大。 操作系统基本种类：批处理系统、分时操作系统、实时操作系统、网络系统和分布式操作系统。 操作系统基本特征：并发、共享和不确定性。 操作系统结构：整体结构、层次结构、虚拟机结构和客户-服务器结构。 系统初启的引导过程：硬件检测、加载引导程序、初始化内核、用户登录。 脱机I&#x2F;O：输入&#x2F;输出工作不受主机直接控制，而由卫星机专门负责完成I&#x2F;O，主机专门完成快速计算任务，从而二者可以并行操作。 联机I&#x2F;O：指作业的输入、调入内存及结果输出都在CPU直接控制下进行。 硬件 是指计算机物理装置本身，它是计算机系统的物理基础。如CPU、内存、设备等。 软件是相对硬件而言的，它是与数据处理系统的操作有关的计算机程序、过程、规则及相关文档资料的总称。简单地说，软件是计算机执行的程序 单道程序设计每次主机内存中仅存放一道作业,每当它运行期间发出输入输出请求后，高速的CPU便处于等待低速的I&#x2F;O完成状态。(基本特征: 顺序性) 多道程序设计在这种设计技术下，内存中能同时存放多道程序，在管理程序的控制下交替地执行。这些作业共享CPU和系统中的其他资源。 并发是指两个或多个活动在同一给定的时间间隔中进行。它是宏观上的概念。 吞吐量 在一段给定的时间内，计算机所能完成的总工作量。 分时就是对时间的共享。在分时系统中，分时主要是指若干并发程序对CPU时间的共享。 实时 表示“及时”或“即时”。 系统调用是用户在程序中能以“函数调用”形式调用的、由操作系统提供的子功能的集合。每一个子功能称做一条系统调用命令。它是操作系统对外的接口，是用户级程序取得操作系统服务的唯一途径。 操作系统为用户提供的服务包括：命令和数据输入&#x2F;输出的管理，内存的分配，用户文件的管理，CPU的分配，设备管理等。 核心态和用户态当执行操作系统程序时，处理机处于核心态。它有较高的特权，可以执行所有的指令，包括一般用户程序中不能使用的特权指令，从而能对所有寄存器和内存进行访问、启动I&#x2F;O操作等。 用户程序是在用户态下执行，它的权限较低，只能执行指令集中非特权指令。 设置这两种不同状态的目的是为了保护操作系统程序（特别是其内核部分），防止受到用户程序的损害。 设计实时操作系统必须首先考虑实时系统的一个重要特征就是对时间的严格限制和要求。实时系统的首要任务是调度一切可利用的资源完成实时控制任务，其次才着眼于提高计算机系统的使用效率。所以，设计实时操作系统必须首先考虑处理各种事件的时间限制。 特权指令和系统调用特权指令是一类只能在核心态下执行的机器指令。而系统调用不是机器指令，它往往以函数调用的形式出现，实现操作系统提供的子功能，它是操作系统与用户的编程接口。在用户程序中可以使用系统调用来获得操作系统服务。 在系统调用代码中可以使用特权指令。 采用层次结构的好处①结构关系清晰，提高系统的可靠性和安全性。 ②各层模块的功能明确，提高系统的可扩充性和可移植性。 ③各层间具有单向依赖性，增强系统的可维护性。 ④符合软件工程的思想，便于实施研制开发。 微内核模式设计系统的优点①精减核心的功能，提供了一种简单的高度模块化的体系结构，提高了系统设计及使用的灵活性。 ②可移植性好。所有与具体机器特征相关的代码，全部隔离在微内核中。 ③可伸缩性好。操作系统能方便地进行定制、扩充或缩减，以适应硬件的快速更新和应用需求的不断变化。 ④实时性好。微内核可以方便地支持实时处理。 ⑤提供多线程机制，支持多处理器的体系结构和分布式系统及计算机网络。 ⑥系统安全性好。传统的操作系统将安全性功能建立在内核之外，因而它并不是很安全的。而微内核则将安全性作为系统内特性来进行设计。 中断与硬件相关，外部设备通过发送中断信号通知CPU抽空处理设备请求。 原语处于操作系统的最底层，是最接近硬件的部分。具有原子性一其操作只能一气呵成。 RAM:随机访问存储器( random-access memory的缩写)特征:可随机读写，读写速度快，断电后数据消失。 ROM:只读存储器(read only memory)特征:数据写入之后不可更改，即使断电数据也不消失。 EPROM:电可编程序只读存储器(Electrically Programmable Read- Only- Memory)，-种特殊的ROM。 BIOS: Basic Input Output System 基本输入输出系统 实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，并控制所有实时任务协调一致运行的操作系统。 响应比响应比&#x3D; (等待的时间+要求服务的时间) &#x2F;要求服务的时间 eg:进程A要求服务5秒，进程B要求服务10秒，且进程B更重要。若两进程同时到达，则等待10秒之后:进程A响应比&#x3D;3，进程B响应比&#x3D;2。处理顺序: 进程A-&gt;进程B 系统调用 VS 库函数 第二章：进程和线程当进程顺序执行时，具有封闭性和可再现性。为提高计算机的运行速度和增强系统的处理能力，广泛采用了多道程序设计技术。该技术可以实现程序的并发执行和资源的共享。但是程序与计算活动失去了一一对应，而且程序并发执行时产生相互制约的关系。为了更好地描述程序的并发过程，引入了“进程”概念。 进程可表述为：程序在并发环境中的执行状态。 进程最基本的特征：动态性和并发性。 进程状态间转化：进程的三态模型： 按进程在执行过程中的不同情况至少要定义三种状态： 运行（running）态：进程占有处理器正在运行的状态。 进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。 就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行的状态。 当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。 等待（wait）态：又称阻塞态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。 也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I&#x2F;O而等待I&#x2F;O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。 123456789引起进程状态转换的具体原因如下：运行态→等待态：等待使用资源；如等待外设传输；等待人工干预。等待态→就绪态：资源得到满足；如外设传输结束；人工干预完成。运行态→就绪态：运行时间片到；出现有更高优先权进程。就绪态—→运行态：CPU 空闲时选择一个就绪进程。 进程的五态模型： 五态模型在三态模型的基础上增加了新建态（new）和终止态（exit）。 新建态：对应于进程被创建时的状态，尚未进入就绪队列。 创建一个进程需要通过两个步骤： 1.为新进程分配所需要资源和建立必要的管理信息。 2.设置该进程为就绪态，并等待被调度执行。 终止态：指进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。 处于终止态的进程不再被调度执行，下一步将被系统撤销，最终从系统中消失。 终止一个进程需要两个步骤： 1.先等待操作系统或相关的进程进行善后处理（如抽取信息）。 2.然后回收占用的资源并被系统删除。 1234567891011121314151617引起进程状态转换的具体原因如下：NULL→新建态：执行一个程序，创建一个子进程。新建态→就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许。运行态→终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结。运行态→就绪态：运行时间片到；出现有更高优先权进程。运行态→等待态：等待使用资源；如等待外设传输；等待人工干预。就绪态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。等待态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。终止态→NULL：完成善后操作。 PCB每个进程都有唯一的一个进程控制块（PCB），它是进程存在的唯一标识，PCB表的物理组织方式有若干种，常见的有线性表、链接表和索引表方式。线性表简单，链接表灵活，索引表处理速度快。 PCB中有表明进程状态的信息，该进程的状态包括运行态、就绪态和阻塞态，它利用状态信息来描述进程的动态性质。 PCB一般包括：进程名、特征信息、进程状态信息、调度优先权、通信信息、现场保护区等。 PCB作用：每个进程有唯一的进程控制块，操作系统根据控制块对进程实施控制和管理，进程的状态、并发特征都是通过PCB表示出来的，PCB是进程存在的唯一标识。 核心利用原语对进程实施操作，包括创建进程、阻塞进程、终止进程和唤醒进程等操作。 线程：是进程中实施调度和分配的基本单位。 进程只作为资源的分配单位和拥有者，而线程才是CPU调度的单位和占有者。 线程两种实现方式：在用户空间实现，切换速度快， 在核心空间实现，支持多线程并发。 利用组合方式可以取长补短。 进程在活动过程中会彼此发生作用，主要是同步、互斥和通信关系。同步是合作关系，互斥是竞争关系，通信是信息交流。 临界资源：一次只允许一个设备使用的资源。 临界区域（CS）：对临界资源实施操作的那段程序 利用信号量和P、V操作可以很好的解决进程间的同步和互斥问题。 详见（信号量P，V操作） 管程是功能更强的同步机制，它自动实现进程互斥进入管程。管程中可以引入条件变量，利用两个操作原语实现进程同步。 为什么引入进程概念由于多道程序并发执行时共享系统资源，共同决定这些资源的状态，因此系统中各程序在执行过程中就出现了相互制约的新关系，程序的执行出现“走走停停”的新状态。用程序这个静态概念已不能如实反映程序并发执行过程中的这些特征。为此，人们引入了“进程（Process）”这一概念来描述程序动态执行过程的性质。 进程和程序 进程与程序之间存在密切关系，进程的功能是通过程序的运行得以实现的，进程活动的主体是程序。进程不能脱离开具体程序而独自存在。 进程的互斥与同步概念同步：逻辑上相关的两个或者多个进程为完成同一个任务，通过协调活动来使用同一资源，而产生的执行时序的约束关系 互斥：逻辑上相互无关的两个或多个京城由于争用同一资源而发生的相互制约的关系 临界区进入准则：位数临界区域得到充分使用，必须严格禁止两个或多个进程同时进入，即欲进入的若干进程徐满足下列要求： 1.单个入区 2.独自占用 3.尽快退出 4.“落败让权” 进程通信—-低级进程通信 ———-互斥 ———-同步 —-高级进程通信 ———-共享存储器方式 ———-消息传递方式 —————-直接消息传递 —————-间接消息传递 ———-管道文件方式 消息传递系统原语：send 、receive 第三章：死锁死锁：指多个进程循环等待他方占有的资源而无限期的僵持下去的局面 产生的原因：根本原因：资源有限且操作不当 一种是竞争资源引起的死锁，另一种原因是进程推进顺序不当。 产生条件：互斥条件、不可抢占条件、占有且申请条件、循环等待条件 对待死锁的策略：预防、避免、检测与恢复，以及完全忽略 死锁预防基本思路：要求进程申请资源时遵循某种协议，从而打破产生死锁的四个必要条件中的一个或者几个，保证系统不会陷入死锁。 预防方法中最有效的是实施资源有序分配策略，即把资源事先编号，按序分配，所有进程对资源的请求必须资源序号递增的顺序提出，·使进程在申请、占有资源时不会形成回路。 死锁避免：是排除死锁的动态策略，关键是确定资源分配的安全性。 代表：银行家算法： 根据进程对资源的请求，试探分配后系统是否处于安全状态。若安全才分配。 死锁的检测和恢复系统有专门的机构负责，在死锁发生时，会检测死锁发生的位置和原因，且通过外力破坏死锁发生的必要条件。 资源分配图系统资源都为单体资源的情况下，若资源分配图中出现回路，则系统存在死锁。 系统资源都为多体资源的情况下，若系统存在死锁，则资源分配图一定存在回路，反之不一定。 系统选择“牺牲者”的主要依据：代价因素· 第四章：调度详见： CPU调度：CPU调度是操作系统最核心的调度，它根据算法选择合适的进程，并把CPU分配给进程使用。 每个操作系统必须的 处理机调度分为三级作业调度（高级调度） 中级调度 进程调度（低级调度） 中级调度实现进程的挂起和进程映像的转换 作业调度（高级调度）的基本功能：选择有权竞争CPU的进程，一般来说，资源分配策略（特别是内存管理）对作业调度影响很大。 作业状态：提交状态、后备状态、执行状态和完成状态 作业控制快JCB 为了管理和控制作业而引入，记录该作业的有关信息 作业调度功能： 1.记录各个作业的情况 2.按照某种算法在后备作业队列中挑选作业， 3.为选中的作业分配资源 4.为选中的作业分配进程，并把进程放到就绪队列中。 5.作业结束后的善后工作 常用算法： 先来先服务、短作业优先、最短剩余时间优先。 进程调度（低级调度）是从就绪队列中选择进程并把CPU分配给它。 功能： 保存现场、挑选进程、恢复现场 基本方式： 非抢占方式、抢占方式 常用调度算法： 轮转法、优先级法、多级队列法、短进程优先、高响应比优先等 调度准则评价调度策略的性能指标CPU利用率 Eg：某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒，再用打印机打印输出6秒，之后再在CPU运行7秒。问：在此过程中，CPU利用率、打印机利用率分别为多少？直接给出计算结果。 吞吐量 Eg：某计算机处理完10道作业，费时100秒，请计算系统吞吐量。 周转时间周转时间&#x3D;作业完成时间点−作业提交时间点 对于用户来说，他们关心自己的单个作业的周转时间，但是对于操作系统来说，操作系统更关心整体表现，于是出现了平均周转时间，即 周转时间的平均值。下面是平均周转时间的计算公式。 平均周转时间&#x3D;各作业周转时间之和&#x2F;作业数目 举个例子：小明去打酱油，他打酱油很快，只需要1分钟。但是到酱油铺后，由于人太多了，小明等了10分钟才轮到自己，这是小明打酱油的经历。现在小红去打醋，她打醋要花10分钟，她到醋铺后只等了1分钟就轮到了自己。我们可以算出他们的周转时间都是11分钟，但是他们的体验感有所不同，小明打酱油1分钟却等了10分钟，他肯定很暴躁。而小红打醋10分钟却只等了1分钟，她觉得这样的体验挺OK的。回到操作系统，类比一下，打酱油和打醋都是作业，小明和小红作为用户。可以看出，他们在周转时间相同的情况下，体验是不一样的。 于是，人们提出了带权周转时间来衡量满意度。公式如下。 带权周转时间&#x3D;作业周转时间 &#x2F; 作业实际运行的时间&#x3D;（作业完成时间点−作业提交时间点）&#x2F;作业实际运行的时间 可以看出，带权周转时间肯定大于等于一，因为作业周转时间包括了作业实际运行的时间。而且，带权周转时间越小，用户满意度越高，反之则越低。例如上面的小明小红，他们的平均周转时间分别是11、1.1。当然，操作系统更关心他们的整体满意度，所以出现了平均带权周转时间，即 带权周转时间的平均值，公式如下。 均带权周转时间&#x3D;各作业带权周转时间之和&#x2F;作业数目 等待时间等待时间&#x3D;周转时间−运行时间 响应时间响应时间，指从用户提交请求到首次产生响应所用的时间。 调度算法：详见： 线程调度：分为：用户级调度和核心级调度 实时调度：实时任务类型：1.根据对截至时间的要求分为：硬实时任务和软实时任务 硬实时任务：指系统必须满足对戒指时间的要求。 软实时任务：任务与预期的截至时间相关联，但不会严格要求。 2.按照任务执行是否有周期性规律分为周期性任务和非周期性任务。 中断中断的概念中断是指程序执行过程中，遇到急需处理的事件时，暂时中止CPU上现行程序的运行，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程 操作系统是“中断驱动”的；换言之，中断（广义）是激活操作系统的唯一方式 中断有广义和狭义之分，上述中断时指广义的中断 中断源：引起中断的事件或者发出中断请求的来源 中断请求中断源向CPU发出的中断请求 断点发生中断是被打断程序的暂停点 中断系统中断系统是计算机系统中响应和处理中断的系统，包括硬件子系统和软件子系统两部分 中断响应由硬件子系统完成 中断处理由软件子系统完成 中断系统的作用：1.提高主机利用率， 2.及时进行事故处理 3.实现分时操作 4.实现实时操作 5.方便程序调试 中断类型：中断、异常 中断的处理过程：硬件： 终止当前程序的执行，保存断点信息、转到相应的处理程序。 软件： 保存现场，分析原因，处理中断，中断返回。 对中断的处理是在核心态下进行的。 处理机调度的主要目的就是为了分配处理机 引入中级调度的目的：提高内存利用率和吞吐量 作业调度与进程调度之间的差别：作业调度是宏观调度，它所选择的作业只是具有获得处理机的资格，但尚未占有处理机，不能立即在其上实际运行；而进程调度是微观调度，动态地把处理机实际地分配给所选择的进程，使之真正活动起来。另外，进程调度相当频繁，而作业调度执行的次数一般很少。 作业调度从外存的后备队列中选择一批作业调入内存，为它们创建进程，这些进程被送入就绪队列。进程调度从就绪队列中选出一个进程来，并把它的状态改为运行态，把CPU分配给它。当运行进程要等待某一事件时，就让出CPU，进入相应的阻塞队列，并进行进程调度。运行进程完成后，由作业调度进行善后处理工作。 第五章：存储管理逻辑地址：应用程序编译后每个模块都以0地址开始编址，这种地址称为逻辑地址或相对地址 物理地址：内存中各物理存储单元都以同一个基地址开始编址，这种地址称为物理地址或绝对地址 重定位：解决逻辑地址和物理地址之间的映射关系 静态重定位：在程序装入内存时进行地址转换。由装入程序执行，早期小型 OS 使用。 动态重定位：在 CPU 执行程序时进行地址转换，依赖硬件来进行转换。如果不用硬件，效率会极大地下降。 分区法：固定分区法：内存中分区个数不变，各个分区大小固定 缺点：浪费严重，碎片化多 动态分区法：各个分区在相应进程建立时才分配，使其大小正好是进程大小 缺点：一段时间后碎片化严重 处理碎片问题：紧缩把所有的碎片连成一片连续的空闲区（通过移动已分区的内容），可以很好解决碎片化，但是需要读写大量分区中信息，耗费大量CPU时间，时间成本高 分页管理解决动态分区法碎片利用率问题 分页存储管理将进程的逻辑地址分为若干页。对每个页进行编号，从0开始，如：第0页，第1页。相应的，把内存中的物理地址分为若干块，同时对他们进行编号，如0#，1#等。在内存分配时，以块为单位，将若干页面分别装入多个不相邻的物理块中。由于进程的最后一页经常装不满，就形成了不可利用的碎片，称为“页面碎片” 分页地址中地址结构如下： 页表在分页系统中，为了保证进程可以在内存中找到每个页面对应的物理块，系统为每一个进程建立了一张页面映像表，简称页表。在进程地址空间内的所有页，依次在页表中有一页表项，其中记录了相应页在内存对应的物理块号。如下图： 页表解决了块外碎片问题，但减低了性能，页面大小制约因素（太大块内碎片，浪费；太小页表项多，查询时间成本大），所以还要优化——》分段技术 例题15： 分段管理：解决了编译后出现多个0地址 在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例如，有主程序段MAIN、子程序段X、数据段D及栈段S等，通常，用段号代替段名。每个段都从0开始编址，并采用一段连续的地址空间。 段的长度由相应的逻辑信息组的长度决定，因此每个短对长度并不相等。 分段地址中地址具有的结构 段表 段页式存储管理方式分页系统以页面作为内存分配的基本单位，能够有效提高内存的利用率，而分段系统以段作为内存分配的基本单位，它能够更好的满足用户多方面的需求。而段页式系统这很好的集两者之长。 段页式系统的基本原理是分段和分页原理的结合，即先将用户程序分为若干段，再把系统分为若干页，为每一个段分配一个段明。 段页地址结构包括三部分：段号，段内页号，页内地址 1.等分内存 2.进程的地址空间采用分段方式，将每段再划分为若干页，页面的大小与内存块相同，每段的每个页面都从0开始编址 段表的内容和分段系统不同，它还包括页表大小和页内始址，下图就是利用段表进行从逻辑地址到物理地址的转变 存储管理的基本模式： 单连续存储管理 段式存储管理 页式存储管理 段页式存储管理 第六章：文件系统文件： 是被命名的数据的集合体，是由操作系统定义和执行的抽象数据 文件系统功能：文件管理、目录管理、文件存储空间管理、文件共享和保护、提供方便的用户接口 两种形式的结构 ① 文件的逻辑结构，这是从用户观点出发所观察到的文件组织形式，是用户可以直接处理的数据及其结构，独立于文件的物理特性，又称为文件组织。 ② 文件的物理结构，又称为文件的存储结构，是指文件在外存上的存储组织形式，不仅与存储介质有关，还与外存分配方式有关。 什么是虚拟存储器？它有哪些基本特征？是用户能作为可编址内存对待的虚拟存储空间，它使用户逻辑存储器与物理存储器分离 题目：1.用户可以通过( B) 两种方式来使用计算机。A.命令接口和函数B.命令接口和系统调用C.命令接口和文件管理D.设备管理方式和系统调用 备注： 易懵概念和常见问法:系统调用&#x3D;系统调用命令&#x3D;广义指令操作系统提供给用户直接(间接)使用的接口是?—-&gt;命令接口(程序接口&#x2F;系统调用)操作系统提供给编程人员&#x2F;应用程序使用的接口是?—-&gt;程序接口&#x2F;系统调用 2.系统调用是由操作系统提供给用户的，它(B ) 。A.直接通过键盘交互方式使用B.只能通过用户程序间接使用C.是命令接口中的命令D.与系统的命令一样 系统调用:由操作系统实现的所有系统调用所构成的集合即程序接口或应用编程接口。是应用程序同系统之间的接口。 3.系统调用的目的是(A）A.请求系统服务B.中止系统服务C.申请系统资源D.释放系统资源 4.用户在程序中试图读某文件的第100个逻辑块，使用操作系统提供的(B ) 接口。A.系统调用B.键盘命令C.原语D.图形用户接口 逻辑块:内存块&gt;计算机资源读: I&#x2F;O操作,核心态服务题目转换为→用户在程序中要访问一部分计算机资源，并且需要进入核心态使用内核服务,需要使用操作系统() 接口 5.操作系统与用户通信接口通常不包括(）A. shellB.命令解释器C.广义指令D.缓存管理指令 Shell属于命令解析器，属于命令接口广 义指令就是系统调用指令 系统中的缓存，全部由操作系统管理,对用户是透明的，操作系统不提供管理系统缓存的系统调用。 6.下列选项中， 不属于多道程序设计的基本特征是( C) 。A.制约性B.间断性C.顺序性D.共享性 7.计算机开机后，操作系统最终被加载到( A) 。[2013年计算机联考真题]A. BIOSB. ROMC. EPROMD. RAM RAM:随机访问存储器( random-access memory的缩写)特征:可随机读写，读写速度快，断电后数据消失。ROM:只读存储器(read only memory)特征:数据写入之后不可更改，即使断电数据也不消失。EPROM:电可编程序只读存储器(Electrically Programmable Read- Only- Memory)，-种特殊的ROM。BIOS: Basic Input Output System 基本输入输出系统 例子:为一个裸机安装操作系统Step 1:一般要先进入BIOS系统，选择安装模式(CD或U盘? )Step 2:安装系统的过程，其实是将操作系统相关数据写入硬盘的过程_(C盘)Step 3:安装完毕，正常开机启动。操作系统相关数据从硬盘加载到RAM中，才能被CPU处理 裸机里有什么?裸机的主板.上有ROM、有RAM、有空空如也的硬盘。一台裸机只有RON中有数据，因此BIOS-定是存在ROM中 8.批处理系统的主要缺点是( D) 。A.系统吞吐量小B. CPU利用率不高C.资源利用率低D.无交互能力 单道批处理系统：单道性、顺序性、自动性 多道批处理系统：制约性、多道、间断性、宏观上并行、微观上串行 9.操作系统的基本类型主要有(B )。A.批处理操作系统、分时操作系统和多任务系统B.批处理操作系统、分时操作系统和实时操作系统C.单用户系统、多用户系统和批处理操作系统D.实时操作系统、分时操作系统和多用户系统 10.下列关于批处理系统的叙述中，正确的是(A )。I.批处理系统允许多个用户与计算机直接交互II.批处理系统分为单道批处理系统和多道批处理系统I.中断技术使得多道批处理系统和I&#x2F;O设备可与CPU并行工作A.仅I、IIIB.仅I|C.仅I、IID.仅1、III 11.与单道程序系统相比，多道程序系统的优点是( D) 。I . CPU利用率高II.系统开销小III.系统吞吐量大IV. I&#x2F;O设备利用率高A.仅I、IIIB.仅I、IVC.仅II、IIID.仅I、III、IV单道程序系统:内存中最多只有-道作业，作业之间是串行执行的。若当前作业等待I&#x2F;O，则CPU闲置等待。多道程序系统:内存中有多道作业，作业之间并发执行。若当前作业等待I&#x2F;O，则CPU转 而处理另一道作业。CPU利用率: CPU“忙” 的时间所占的比例系统开销:除了处理作业之外，系统在进程、内存等管理上消耗的时间系统吞吐量:单位时间内CPU完成作业数量 （相同作业下，总耗时越少，吞吐量越大）I&#x2F;0设备利用率: I&#x2F;0设 备”忙”的时间所占的比例 eg： 作业A: CPU 5ms –&gt; I&#x2F;0 5ms –&gt; CPU 5ms –&gt; I&#x2F;O 5ms作业B: CPU 5ms –&gt; I&#x2F;0 5ms – CPU 5ms –&gt; 1&#x2F;0 5ms 单道： 完成2个作业，总耗时40ms， CPU利用 率&#x3D;20&#x2F;40&#x3D;50%，&#x2F;0设备利用率&#x3D;20&#x2F;40&#x3D;50% 多道： 完成2个作业，总耗时25ms，CPU利用率&#x3D;20&#x2F;25&#x3D;80%，&#x2F;0设备利用率&#x3D;20&#x2F;25&#x3D;80% 12.实时操作系统必须在( B) 内处理来自外部的事件。A.一个机器周期B.被控制对象规定时间C.周转时间D.时间片 实时操作系统:是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统做出快速响应，并控制所有实时任务协调-致运行的操作系统。产生目的:为了能在某个时间限制内完成某些紧急任务而不需要时间片排队 13.实时系统的进程调度，通常采用( C) 算法。A.先来先服务B.时间片轮转C.抢占式的优先级高者优先D.高响应比优先 实时操作系统:将时间作为关键参数。系统必须能足够及时地处理某些紧急的外部事件。Key:响应比&#x3D; (等待的时间+要求服务的时间) &#x2F;要求服务的时间eg:进程A要求服务5秒，进程B要求服务10秒，且进程B更重要。若两进程同时到达，则等待10秒之后:进程A响应比&#x3D;3，进程B响应比&#x3D;2。处理顺序: 进程A-&gt;进程B 这种情况下A会先处理，不符合. 先来先服务:早期的单道批处理系统时间片轮转:分时操作系统抢占式的优先级高者优先:实时操作系统高响应比优先:常用于多道程序系统中的作业调度 14.分时系统的一个重要性能是系统的响应时间,对操作系统(C ) 因素进行改进有利于改善系统的响应时间。A.加大时间片B.采用静态页式管理C.优先级+非抢占式调度算法D.代码可重入 分时操作系统的工作方式: -台主机连接了若干个终端，每个终端有一个用户在使用。用户交互式地向系统提出命令请求，系统接受每个用户的命令,采用时间片轮转方式处理服务请求,并通过交互方式在终端上向用户显示结果 响应时间:从用户提交请求到系统首次产生响应所用的时间 16 虚拟存储技术是（A）。A. 补充内存物理空间不足的技术 B. 补充相对地址空间的技术 C. 扩充外存空间的技术 D. 扩充输入输出缓冲区的技术 17.段页式存储管理汲取了页式管理和段式管理的长处，其实现原理结合了页式和段式管理的基本思想，即（B）。A. 用分段方法来分配和管理物理存储空间，用分页方法来管理用户地址空间。 ​ B. 用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间。 ​ C. 用分段方法来分配和管理主存空间，用分页方法来管理辅存空间。 ​ D. 用分段方法来分配和管理辅存空间，用分页方法来管理主存空间。 18.（B）是指将作业不需要或暂时不需要的部分移到外存，让出内存空间以调入其他所需数据。​ A. 覆盖技术 B. 交换技术 ​ C. 虚拟技术 D. 物理扩充 19.通道是一种（C）。A. I&#x2F;O端口 B. 数据通道 C. I&#x2F;O专用处理机 D. 软件工具 1.下面各项中， (C ) 不是引入操作系统的最主要目的。A.方便用户使用 B.更有效地利用软.硬件资源 C.及时响应用户请求 D.改善系统性能 2.分时系统响应时间与( D)有关。A.每个应用进程分配的时间片长度 B.进程大小 C.就绪进程数目 D.就绪进程数目和时间片长度 3.采用多道程序设计能( B )。A.增加平均周转时间 B.发挥并提高并行工作能力 C.缩短每道程序的执行时间 D.降低对处理器调度的要求 4.下面对进程的描述中，错误的是( D )。 A.进程是动态的概念 B.进程执行需要处理机 C.进程是有生命期的 D.进程是指令的集合 5.多道程序系统中，当( B )时，进程从执行状态转变为就绪状态。A.进程被进程调度程序选中 B.时间片到 C.等待某一事件 D.等待的事件发生 6.下列选项中，导致创建新进程的操作是( C )。I 用户登录成功 II 设备分配 III启动程序执行 A.仅I和II B.仅II和III C.仅I和III D.I II和III 7.下列因素中，( C )不一定是引起进程调度的因素。 A.一个进程运行完毕 B.运行进程被阻塞 C.一个高优先级进程被创建 D.实时调度中，一个紧迫的任务到来 8.一种既有利于短小作业又兼顾到长作业的作业调度算法是( C )。A.先来先服务 B.轮转 C.最高响应比优先 D.均衡调度 9. “死锁”问题的讨论是针对( D )的。A.某个进程申请系统中不存在的资源 B.某个进程申请资源数超过了系统拥有的最大资源数 C.硬件故障 D.多个并发进程竞争独占型资源 10.采用资源剥夺法可以解除死锁，还可以采用(B )方法解除死锁。A.执行并行操作 B.撤消进程 C.拒绝分配新资源 D.修改信号量 11.下列对重定位的叙述中，正确的选项是( B )。A.经过静态重定位后，指令代码并不发生变化 B.经过静态重定位后，数据地址和指令地址发生了变化 C.经过动态重定位后，数据地址和指令地址都发生了变化 D.经过动态重定位后，数据地址发生了变化而指令地址没有发生变化 12.将主存空闲区按地址顺序从小到大登记在空闲区表中，每次分配时总是顺序查找空闲区表，此种分配算法称为( A)分配算法。A.最先适应 B.最优适应 C.最坏适应 D.随机适应 13.某系统采用页式存储管理策略，拥有逻辑地址空间32页，每页2K，拥有物理空间1M，进程的页表有（ B）项A.16 B.32 C.48 D.96 14.在段式存储管理的地址转换时，若段内地址大于段表中该段的长度，则发生（ D）。A.缺页中断 B.溢出中断 C.硬件故障中断 D.地址越界中断 15.在I&#x2F;O设备控制的发展过程中，最主要的推动因素是( C )。A.提高资源利用率 B.提高系统吞吐量 C.减少主机对I&#x2F;O控制的干预 D.提高CPU与I&#x2F;O设备的并行操作程度 16.用户程序发出磁盘I&#x2F;O请求后，系统的正确处理流程是( B)。A.用户程序→系统调用处理程序→中断处理程序→设备驱动程序 B.用户程序→系统调用处理程序→设备驱动程序→中断处理程序 C.用户程序→设备驱动程序→系统调用处理程序→中断处理程序 D.用户程序→设备驱动程序→中断处理程序→系统调用处理程序 17.逻辑文件的组织结构是由( C )确定的。A.操作系统 B.存储容量 C.用户 D.文件长度 18.在文件的物理结构中，( A )结构不利于文件长度的动态增长。A.顺序 B.链接 C.索引 D.Hash 19.文件系统中文件被按照名字存取是为了（ B ）。A.方便操作系统对信息的管理 B.方便用户的使用 C.确定文件的存取权限 D.加强对文件内容的保密 20.设文件F1当前引用计数值为1，先建立F1的符号链接(软链接)文件F2，再建立F1的硬软链接文件F3，然后删除F1。此时，F2和F3的引用计数值分别是（B ）。A.0，1 B.1，1 C.1，2 D.2，1 21.多道批处理系统的主要缺点是(C )。 A.CPU利用率低 B.不能并发执行 C.缺少交互性 D.以上都不是 22.下列选项中，操作系统提供给应用程序的接口是( A ) 。 A.系统调用 B.中断 C.库函数 D.原语 23.多道程序设计是指(C )。A.在多台处理机上同时执行多道程序 B.在多台处理机上同一时刻执行多道程序 C.在一台处理机上同时执行多道程序 D.在一台处理机上同一时刻执行多道程序 24.有关进程的下列叙述中，(D )是正确的。A.进程是静态的文本 B.进程与程序是一一对应的 C.进程与作业是一一对应的 D.多个进程可以在单个CPU上同时执行 25.下列的进程状态变化中，( C )的变化是不可能发生的。A.运行→就绪 B.运行→等待 C.等待→运行 D.等待→就绪 26.下面所述步骤中，( A )不是创建进程所必需的。 A.由调度程序为进程分配CPU B.建立一个进程控制块 C.为进程分配内存 D.将进程控制块链入就绪队列 27.下列各项中，不是进程调度时机的是( D)。A.现运行的进程正常结束或异常结束 B.现运行的进程从运行态进入就绪态 C.现运行的进程从运行态进入等待态 D.有一进程从等待态进入就绪态 28.在作业调度中，排队等待时间最长的作业被优先调度，这是指( A )调度算法。A.先来先服务 B.短作业优先 C.响应比高优先 D.优先级 29.产生死锁的原因与( D )有关。A.与多个进程竞争CPU B.与多个进程释放资源 C.仅由于并发进程的执行速度不当 D.除资源分配策略不当外，也与并发进程执行速度不当 30.某计算机系统中有8台打印机，有k个进程竞争使用，每个进程最多需要3台打印机。该系统可能会发生死锁的k的最小值是( C )。(最坏情况每bai个进程du卡2台，4个进程全部卡zhi死) A.2 B.3 C.4 D.5 31.在虚拟内存管理中，地址变换机构将逻辑地址变换为物理地址，形成该逻辑地址的阶段是( B )。A.编辑 B.编译 C.连接 D.装载 32.在系统运行时，对于固定分区的存储管理方式，内存中能并发执行的作业的最大数量是( )。A.用户确定的 B.可变的 C.不受限制的 D.固定的 33.在操作系统的存储管理中，页式分配是（ A ）。A.把程序的逻辑空间和内存的物理空间按同样的尺寸分成若干页 B.把作业按其所需空间分成若干页 C.将内存的空闲空间分成若干页 D.随机地将每个作业的地址空间分成大小相同的若干页 34.在段式存储管理中，下列哪个说法是正确的（ A ）。A.以段为单位分配，每一段是一个连续存储区 B.段与段之间必定不连续 C.段与段之间必定连续 D.每段是等长的 35.I&#x2F;O系统硬件结构分为4级：①设备控制器；②I&#x2F;O设备；③计算机；④I&#x2F;O通道。按级别由高到低的顺序是( D)。A.②-④-①-③ B.③-①-④-② C.②-①-④-③ D.③-④-①-② 36.I&#x2F;O软件一般分为4个层次：用户层、与设备无关软件层、设备驱动程序、中断处理程序。以下工作中，不是由设备驱动程序完成的是( C )。A.向设备寄存器写命令 B.检查用户是否有权使用设备 C.将二进制整数转换成ASCII码以便打印 D.解释用户的I&#x2F;O请求，并将该请求转化为具体的I&#x2F;O操作 37.以下关于文件组织结构的说法中，错误的是( C )。A.文件组织从用户和文件系统的不同角度出发分为逻辑文件和物理文件 B.逻辑文件是用户概念中的文件，分为流式文件和记录式文件 C.磁带文件的物理组织方式一般可以采用顺序结构或链接结构 D.磁盘文件的物理组织方式一般可以采用顺序结构、链接结构或索引结构等 38.采用直接存取（随机存取）方法来读写磁盘上的物理记录时，效率最低的是(C ) 。A.连续结构文件 B.索引结构文件 C.隐式链接结构文件 D.显式链接结构文件 39.文件系统采用多级目录结构可以（B ）。A.节省存储空间 B.解决命名冲突 C.缩短文件传送时间 D.减少系统开销 40.以下（ B ）不是磁盘存储空间的常用管理方法。A.位示图 B.记录的成组操作 C.空闲块表 D.空闲块链 41.从用户的观点看，操作系统是( A)。A.用户与计算机之间的接口 B.控制和管理计算机系统的资源 C.合理组织计算机工作流程 D.一个大型的工具软件 42.下列选项中，在用户态执行的是(A ) 。A.命令解释程序 B.缺页处理程序 C.进程调度程序 D.时钟中断处理程序 43.在计算机系统中，允许多个程序同时进入内存并运行，这种方法称为( D )。A.SPOOLing技术 B.虚拟存储技术 C.缓冲技术 D.多道程序设计技术 44.一个进程是( C )。A.由协处理器执行的一个程序 B.一个独立的程序 + 数据集 C.PCB结构.程序和数据的集合 D.一个独立的程序 45.如果单CPU系统中有n个并发进程，则就绪队列中进程个数最多可达(B )个。A.n B.n-1 C.n-2 D.1 46.通常，用户进程被建立后，( B )。 A.便一直存在于系统中，直到被操作人员撒消 B.随着作业运行正常或不正常结束而撒消 C.随着时间片轮转而撒消与建立 D.随着进程的阻塞或唤醒而撒消与建立 47.支持多道程序设计的操作系统在运行过程中，不断地选择新进程运行来实现CPU的共享，下列选项中，(D )不是引起操作系统选择新进程的直接原因。A.运行进程的时间片用完 B.运行进程出错 C.运行进程要等待某一时件发生 D.有新进程进入就绪状态 48.分时系统中进程调度算法通常采用( B )。A.响应比高者优先 B.时间片轮转法 C.先来先服务 D.短作业优先 49.在操作系统中，所谓“死锁”是指( B )。A.程序死循环 B.多个进程彼此等待资源而不能前进的状态 C.硬件故障 D.时间片太短，进程的调进调出太频繁而效率太低 50.在多进程的并发系统中，肯定不会因竞争( D)而产生死锁。A.打印机 B.磁带机 C.磁盘 D.CPU 51.把目标程序中的逻辑地址转换成主存空间的物理地址称为( B)。A.存储分配 B.地址重定位 C.地址保护 D.程序移动 52.在下述存储管理方案中，( D )管理方式要求作业的逻辑地址与占有主存的存储区域都是连续的。A.段页式 B.页式 C.段式 D.可变分区 53.页式存储管理中，每次从主存中取指令或取操作数，当读快表失败时，要读（B ）次主存。A.1 B.2 C.3 D.4 54.采用段页式存储管理，在CPU中应设置（ A）寄存器。A.段表和页表控制 B.段表控制 C.页表控制 D.界地址 55.硬件采用了中断和通道技术，使得( B )。 A.CPU与外设能紧密结合 B.CPU与外设能并行工作 C.CPU速度提高 D.外设速度提高 56.程序员利用系统调用打开I&#x2F;O设备时，通常使用的设备标识符是(A )。A.逻辑设备名 B.物理设备名 C.主设备号 D.从设备号 57.下列选项中，( B )不是删除文件所需要完成的工作。A.释放文件所占用的存储空间 B.对文件原占用的存储单元全部清零 C.删除该文件的目录项，即文件控制块(FCB) D.若文件为共享文件，还要对共享设置进行处理 58.下列文件物理结构中，适合随机访问且易于文件扩展的是( B )。A.连续结构 B.索引结构 C.链式结构且磁盘块定长 D.链式结构且磁盘块变长 59.不包含在文件控制块（又称文件目录项）中的信息是 （AA ）。A.存储介质标志 B.文件名 C.存取控制信息 D.文件的物理结构 60.某操作系统的文件系统中，采用3个字节表示磁盘块号，每个磁盘块大小为512字节。该系统中每个（逻辑）磁盘允许的最大容量是（ C ）字节。A.2G B.4G C.8G D.16G 答案：12345678910111213141516171819202122231.C 2.D 3.B 4.D 5.B 6.C 7.C 8.C 9.D 10.B11.B 12.A 13.B 14.D 15.C16.B 17.C 18.A 19.B 20.B21.C 22.A 23.C 24.D 25.C26.A 27.D 28.A 29.D 30.C31.B 32.D 33.A 34.A 35.D36.C 37.C 38.C 39.B 40.B41.A 42.A 43.D 44.C 45.B46.B 47.D 48.B 49.B 50.D51.B 52.D 53.B 54.A 55.B56.A 57.B 58.B 59.A 60.C 1、试说明进程在三个基本状态之间转换的典型原因。答案：（1）就绪状态→执行状态：进程分配到CPU资源 （2）执行状态→就绪状态：时间片用完 （3）执行状态→阻塞状态：I&#x2F;O请求 （4）阻塞状态→就绪状态：I&#x2F;O完成 2、什么是基于顺序搜索的动态分区分配算法？它可分为哪几种？答案：为了实现动态分区式分配，将系统中的空闲分区组织成空闲分区表或空闲分区链。所谓顺序搜索，是指按表或链的组织顺序，检索表或链上记录的空闲分区，去寻找一个最符合算法的、大小能满足要求的分区。 分区存储管理中常采用的分配策略有：首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法。 3、试说明低级调度的主要功能。答案：（1）保存处理机的现场信息（2）按某种算法选取进程（3）把处理机分配给进程。 4、试从动态性，并发性和独立性上比较进程和程序?答案：(1)动态性是进程最基本的特性，表现为由创建而产生，由调度而执行，因得不到资源而暂停执行，由撤销而消亡。进程有一定的生命期，而程序只是一组有序的指令集合，是静态实体。 (2)并发性是进程的重要特征，同时也是OS 的重要特征。引入进程的目的正是为了使其程序能和其它进程的程序并发执行，而程序是不能并发执行的。 (3)独立性是指进程实体是一个能独立运行的基本单位，也是系统中独立获得资源和独立调度的基本单位。对于未建立任何进程的程序，不能作为独立单位参加运行。 5、实现虚拟存储器需要哪些硬件支持？答案： （1）请求分页（段）的页（段）表机制 （2）缺页（段）中断机构 （3）地址变换机构 6、引入缓冲的主要原因是什么？答案： 缓和CPU与I&#x2F;O设备之间速度不匹配的矛盾； 减少对CPU的中断频率； 放宽对中断响应时间的限制； 解决数据力度不匹配的问题； 提高CPU和I&#x2F;O设备之间的并行性。 7、处理机管理有哪些主要功能？其主要任务是什么？答案：处理机管理的主要功能是：进程管理、进程同步、进程通信和处理机调度； 进程管理：为作业创建进程，撤销已结束进程，控制进程在运行过程中的状态转换。 进程同步：为多个进程（含线程）的运行进行协调。进程 通信：用来实现在相互合作的进程之间的信息交换。 处理机调度： （1）作业调度。从后备队里按照一定的算法，选出若干个作业，为他们分配运行所需的资源。（2）进程调度：从进程的就绪队列中，按照一定算法选出一个进程，把处理机分配给 它，并设臵运行现场，使进程投入执行。 8、虚拟存储器有哪些特征？其中最本质的特征是什么？答案：虚拟存储器有多次性、对换性、虚拟性三大特征。最本质的特征是虚拟性。 9、文件系统的模型 可分为三层，试说明其每一层所包含的基本内容。答案：第一层：对象及其属性说明（文件、目录、硬盘或磁带存储空间）； 第二层：对对象操纵和管理的软件集合（I&#x2F;O控制层即设备驱动程序、基本文件系统即物理I&#x2F;O层、基本I&#x2F;O管理程序或文件组织模块层、逻辑文件系统层） 第三层：文件系统接口（命令接口&#x2F;图形化用户接口与程序接口）。 10、文件管理有哪些主要功能？其主要任务是什么？答案：文件管理主要功能：文件存储空间的管理、目录管理、文件的读（写）管理和保护。 文件管理的主要任务：管理用户文件和系统文件，方便用户使用，保证文件安全性。 11、试从调度性、并发性、拥有资源性及系统开销方面对进程和线程进行比较。答案： a. 调度性。在传统的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程，在引入线程的OS中，则把线程作为调度和分派的基本单位，而把进程作为资源拥有的基本单位； b. 并发性。在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间，亦可并发执行，因而使OS具有更好的并发性； c. 拥有资源。无论是传统的操作系统，还是引入了线程的操作系统，进程始终是拥有资源的一个基本单位，而线程除了拥有一点在运行时必不可少的资源外，本身基本不拥有系统资源，但它可以访问其隶属进程的资源； d. 开销。由于创建或撤销进程时，系统都要为之分配和回收资源，如内存空间等，进程切换时所要保存和设置的现场信息也要明显地多于线程，因此，操作系统在创建、撤消和切换进程时所付出的开销将显著地大于线程。 12、与文件系统有关的软件可分为哪几个层次？答案：一般地，把与文件系统有关的软件分为四个层次： I&#x2F;O控制层，是文件系统的最低层，主要由磁盘驱动程序等组成，也可成为设备驱动程序层 基本文件系统层，主要用于处理内存与磁盘之间数据块的交换。 基本I&#x2F;O管理程序，该层用于完成与磁盘I&#x2F;O有关的事务，如将文件逻辑块号转换为物理块号，管理磁盘中的空闲盘块，I&#x2F;O缓冲的指定等。 逻辑文件系统，用于处理与记录和文件相关的操作，如允许用户和应用程序使用符号文件名访问文件及记录，实现对文件的记录和保护等。 13.简述操作系统的基本特征和功能。答：基本特征：并发、共享、异步、虚拟。 功能：处理机管理、存储器管理、设备管理、文件管理、用户接口。 14.试比较进程与程序的差异。答：（1）程序是一个静态概念，而进程是一个动态概念，是程序的一次执行； （2）进程具有并行特性，而程序没有； （3）进程和程序不是一一对应的，一个程序可对应多个进程；一个进程可以执行一个或几个程序。 某进程调度程序采用基于优先数(priority)的调度策略，即选择优先数最小的进程运行，进程创建时由用户指定一个nice作为静态优先数。为了动态调整优先数，引入运行时间cpuTime和等待时间waitTime，初值均为0。进程处于执行态时，cpuTime定时加1，且waitTime置0；进程处于就绪态时，cpuTime置0，waitTime定时加1。请回答下列问题。 (1)若调度程序只将nice的值作为进程的优先数，即priority&#x3D;nice，则可能会出现饥饿现象，为什么? (2)使用nice、cpuTime和waitTime设计一种动态优先数计算方法，以避免产生饥饿现象，并说明waitTime的作用。 答：（1）由于采用了静态优先数，当就绪队列中总有优先数较小的进程时，优先数较大的进程一直没有机会运行，因而会出现饥饿现象。 （2）优先数的计算公式为： priority&#x3D;nice+k1cpuTime- k2waitTime,其中k1&gt;0, k2&gt;0。waitTime可使长时间等待的进程的优先数减少。 SPOOLing系统由哪几部分组成？以打印机为例说明如何利用SPOOLing技术实现多个进程对打印机的 答 组成：(1)输入井和输出井,(2)输入和输出缓冲区,(3)输入(收容)进程SPi 和输出(提取)进程Spo。 当用户进程请求打印输出时， SPOOLing系统同意为它打印输出， 但并不真正立即把打印机分配给该用户进程， 而只为它做两件事： ① 由输出进程在输出井中为之申请一个空闲磁盘块区， 并将要打印的数据送入其中； ② 输出进程再为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中， 再将该表挂到请求打印队列上。 当打印机空闲，输出进程将从请求打印队列的对首取出一张请求打印表，根据表中的要求将打印的数据从输出井传送到内存缓冲区，再由打印机打印….。 20.一个例子的形式讲解逻辑地址到物理地址的转换：某虚拟存储器的用户编程空间共32个页面，每页为1KB，内存为16KB。假定某时刻一用户页表中已调入内存的页面的页号和物理块号的对照表如下： 页号 物理块号 0 3 1 7 2 11 3 8 则逻辑地址0A5C(H)所对应的物理地址是什么？要求：写出主要计算过程。 ****解题过程****： ​ 首先要知道页式存储管理的逻辑地址分为两部分：页号和页内地址。物理地址分为两部分： 关系为：逻辑地址＝ 页号＋页内地址 ​ 物理地址＝ 块号＋页内地址； 分析题：已知：用户编程空间共３２个页面，２ˆ５ ＝ ３２ 得知页号部分占５位，由“每页为1KB”，1K&#x3D;2^10，可知内页地址占10位。 由“内存为16KB”，２^４＝１６得知块号占4位。 ​ 逻辑地址0A5C（H）所对应的二进制表示形式是：００００１０１００１０１１１００，后十位１００１０１１１００是页内地址， ０００１０为为页号，页号化为十进制是２，在对照表中找到２对应的物理块号是１１,１１转换二进制是１０１１，即可求出物理地址为１０１１１００１０１１１００，化成十六进制为２Ｅ５Ｃ； 即则逻辑地址0A5C(H)所对应的物理地址是２Ｅ５Ｃ； 15：分页技术例题 参考文章: 操作系统中的中断（详细介绍+图片理解） 操作系统13————存储器管理之分页存储 操作系统14————存储器管理之分段存储&amp;段页存储 操作系统选择题"},{"title":"Kali linux Vmware安装","path":"posts/56b3.html","text":"一、kalilinux下载 根据电脑配置选择合适的版本，在这里我选择的是64位版本， 二、vmware安装打开VMware 创建适合KALI的虚拟机，使用自定义的配置方法，点击下一步 三、激活 语言设置汉语就可"},{"title":"埃式筛法","path":"posts/fdf6.html","text":"做法：做法其实很简单， 首先将2到n范围内的整数写下来，其中2是最小的素数。将表中所有的2的倍数划去，表中剩下的最小的数字就是3，他不能被更小的数整除，所以3是素数。再将表中所有的3的倍数划去……以此类推，如果表中剩余的最小的数是m，那么m就是素数。然后将表中所有m的倍数划去，像这样反复操作，就能依次枚举n以内的素数，这样的时间复杂度是O(nloglogn)。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;int fun(int n);int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); int ans = fun(n); printf(&quot;%d\\n&quot;, ans); return 0;&#125;int fun(int n) &#123; //all 素数 //筛除 int num[n + 1]; int i; int count = 0; for (i = 0; i &lt; n; i++) &#123; num[i] = 1; &#125; num[0] = 0; num[1] = 0; int j; for (j = 2; j &lt;= n; j++) &#123; if (num[j] == 1) &#123; count++; int x; for (x = 2 * j; x &lt;= n; x = x + j) &#123; num[x] = 0; &#125; &#125; &#125; return count;&#125;"},{"title":"高考季：我来给你说说湘潭大学","path":"posts/4db9.html","text":"&#x3D;&#x3D;_前排提示：_本文是从一个在湘大学习一年（准确说是半年吧）的学生角度介绍下湘潭大学，受众主要是想了解湘大的或者想考湘大的同学 ，属于个人介绍，个人见解，&#x3D;&#x3D; 官方介绍：湘潭大学是湖南省与教育部、国家国防科工局共建的综合性全国重点大学，入选两期国家“中西部高校基础能力建设工程”，是全国首批具有硕士学位授予权的单位，教育部本科教学工作水平评估“优秀”学校，历年来全国一本招生高校。软科点评：主席倡办亲提校名，工材化学发展迅速。 办学历史：湘潭大学是毛泽东主席亲自倡办、亲笔题写校名、亲切嘱托一定要办好的综合性全国重点大学；学校的建设发展，也得到了党中央、国务院和历代党和国家领导人的亲切关怀 学科门类：学校学科覆盖文、史、哲、理、工、经、管、艺等9大门类。现有3个国家重点学科，4个国防特色学科，2个湖南省优势特色重点学科，19个湖南省重点学科；有15个一级学科博士点，110个二级二级学科博士点，31个一流学科硕士点，194个二级学科硕士点，13个硕士专业学位类别，11个博士后科研流动站；有11个专业排名全国前10%，国家级特色专业11个，国际级专业综合改革试点专业1个，6个专业通过国家工程教育认证。十大优势学科：马克思主义理论、法学、政治学、理论经济学、材料科学与工程、化学工程与技术、图书情报与档案管理、哲学、力学、工商管理。 人才培养：学校设有拔尖人才培养教改实验班7个，包括数学类韶峰班、物理学类韶峰班、材料类师昌绪班、法学卓越班、经济学类韶峰班、公共管理类韶峰班、化学类韶峰班。学校为实验班配备一流师资，提供一流学习条件，创造一流学术氛围。2019届数学类韶峰班、物理学类韶峰班、材料类师昌绪班毕业生中76.8%被推荐免试攻读北京大学等双一流大学研究生。 国际视野：学校与美国、英国等20多个国家和地区的60多所国际知名大学建立了广泛深入的校际交流合作关系；与西班牙莱昂大学、乌干达麦克雷雷大学合作共建了“&#x3D;&#x3D;孔子学院&#x3D;&#x3D;”；可以与美国、日本、韩国等国家知名大学生互派交换生。 校园环境：学校是“全国绿化模范单位”、“湖南省文明单位”、“湖南省文明高校”、湖南省“十佳书香校园”。学生宿舍全部安装有空调，智慧校园实现无线WIFI全覆盖。 个人了解外界宣传相信很多同学（尤其我这样属于西部偏远地区的孩子）对湘潭大学了解很少，甚至没有听说过。我在高考完填报志愿的时候是根据志愿填报机构的大数据推荐才把它填上志愿的。当时十几个志愿学校（有同学可能惊讶怎么十几个志愿，这是因为还有国家专项、地方专项、高校专项这些）只有两个省外的，湘大就是其中之一，按分数作为第二志愿我被湘大录取了。于是，这个时候我才开始在各大网站上了解湘大。湘大在外界并没有很多人知道，因为它既不是985也不是211，目前也不是双一流，它是省属普通一本中的战斗机，推免率最高的普通一本，超一本线不多的考生性价比高校考虑之一。是重点大学中比较可以的一所高校，综合实力强于绝大部分省属普通一本，最值得读的专业是数学类、法学类、经管类。在与湖南本地的同学交流后发现在湖南名声还可以，但学校在其他地方的宣传还有待加强，这样才有助于其他地方的同学对它有更多的了解。而在各大社交平台上也有很多人对湘大进行了评价，有兴趣的同学也可以去看看。近一年的生活之后，我个人对湘大也有了很大态度上的改变。 分数陕西本科一批历年分数（数据来源：中国教育在线） 年份 最高分 最低分 最低位次 平均分 2019 563 521 31815 539 2018 – 531 25894 —- 2017 – 501 26955 – 2016 – – – 525 陕西本科一批各专业分数线（部分，数据来源：中国教育在线） 专业 最高分 最低分 最低位次 数学类（韶峰班） 563 557 18396 物理学类（韶峰班） 554 553 19660 会计学（ACCA班） 553 552 19982 计算机科学与技术 559 548 21352 软件工程 553 548 21352 数学类 555 546 22045 材料类（师昌绪班） 547 544 22789 网络工程 545 541 23888 经济学类（韶峰班） 555 552 19982 其余省份历年分数中国教育在线 湘潭大学分数线 由分数大家应该可以看出来考着个分数的大多数同学其实是高考有失误，如果你是一个高考生，高考分数离大城市的985 211有点距离，那湘潭大学一定是你最好的本一选择，不接受反驳！哈哈哈。因为这个分数有点“高不成低不就”，这也就使得湘大的一部分同学刚来的时候是有一些抵触的。 地域 湘潭大学座落在毛泽东同志的故乡、中国历史文化名城——湖南省湘潭市。湖南省湘潭市雨湖区北二环羊牯塘街道。邮编号码是411105地级市经济一般 位置偏僻 远离省会繁华，适合潜心学习，湘大的发展相对缓慢与这地理因素有一定原因，但这并不意味着出去游玩有很多困难，近几年“长株潭”一体化建设的加强也使得出行各方面有很大便利，从南门做公交近一个小时可到达湘潭火车站，在做十几分钟的城际高铁便能到达长沙，我个人因为大一班委事情多，加上学业负担重，也就出去玩了一次，长沙美食啥的就不多赘述了。公交车半个小时应该能到市里，看个电影什么的，还是挺方便的。湘潭离长沙很近，高铁就二十分钟的事，看个演唱会，音乐节啥的都很方便。 校园环境湘大的校园环境还是挺不错的，湘大校区集中，校园内部联系快捷、沟通方便，且不受外界喧闹干扰，具备特有的舒适幽静的学习、科研环境，是读书、治学的理想殿堂。学校是全国66所本科院校教育信息化试点单位之一。主干万兆的校园有线网络覆盖了所有教学、办公区域、学生公寓区和部分学生宿舍，无线网络覆盖所有教学、办公区域和学生公寓、宿舍区域和主要室外公共场所。 三道拱门湘潭大学的校门——三道拱门，建立于上世纪80年代初，是学校的标志性建筑。 简洁而不乏宏伟之气势，质朴而不失现代之灵光，三道拱门的整体设计融合了传统文化内涵和现代审美气息，具有独特丰富的内涵：1、它代表湘潭大学是文、理、工综合性大学，兆示着学校文、理、工多学科交叉发展的无限潜能；2、它蕴涵一生二，二生三，三生万物的传统哲学思想，隐含着学术自由、平等博爱、追求无极的理性思辨，彰显著知行合一、德才兼备、情理互融的育人理念；3、整体看三道拱门像汉字“山”，象征着不断进取、勇登高峰。每一道直达云际、顶端开启的拱门，宛如开启知识殿堂的钥匙，意味着在探求未知领域的过程中学习、研究永无止境；4、单看每一道拱门像汉字“人”，三道拱门代表三人成众、众志成城，突出团队合作精神；同时，“三人行，必有我师鄢”，意味着湘大人善于学习、不断进取的作风。 食堂湘大有南苑、雅园、琴湖、北五、乐园、公一、兴湘7个食堂。7大食堂各有特色，南苑环境优美，现代化装修；琴湖菜品多样，好评如潮;乐园、雅园面食丰富……南苑公一北五极宜讨论问题、学习。还有联建小吃街 金翰林小吃街 堕落坑 三大小吃街，金陵汤包、上海生煎、陕西肉夹馍、麻辣烫、湘西泡菜、炸鸡甜品、臭豆腐、小龙虾、烧烤……南北中外,小食饮品，应有尽有。 寝室湘大有琴湖，南苑，金翰林，北苑四个宿舍区。每间宿舍都有风扇空调，大部分寝室都有独立卫浴，楼道有洗衣机，饮水机但很多寝室也会选择合伙买一个洗衣机，热水是充足的，所以半夜两点起来泡泡面不是问题。寝室楼下一般都会有自动售货机，有双人，四人，六人，八人间几种。我所在的琴湖18栋本来是四人间，奈何19扩招吧，四人间魔改为八人间，这也是同学们比较难以接受的。但这一年又校区扩建，不知道能不能得到改善。宿舍不让使用大功率电器，但是大功率电器是2000w。吹风机，小电锅，你值得拥有。去年元旦我们寝室就在一起煮饺子（嘘!）。一般没有查寝，刷卡进宿舍楼，据说十一点半以后进寝室会有记录，但从来没管过哈哈哈。校园wifi说起来是晚上12.00断网，也有人吐槽网速慢，但我用着还可以。 图书馆每到考试月的时候，这里总是座无虚席。大家可以在微信公众号“来选座”上面预定学习座位，但我只抢到过一次，湘大图书馆饱满到上了微博热搜， 体育馆这个地方我渠道比较少，当时军训在这边，之后也就“新生杯篮球赛“去看过，里面挺大的，设施也齐全，有好多同学办了健身卡经常去锻炼。 最后放一些平时收集的图片吧！ 最后！ 另附一份2020湘大招生简介：http://mp.weixin.qq.com/s?__biz&#x3D;MzUxNjQ4ODQ4Ng&#x3D;&#x3D;&amp;mid&#x3D;2247487965&amp;idx&#x3D;1&amp;sn&#x3D;755340e0fb9f9ade8721436d1a9938ae&amp;chksm&#x3D;f9a7fd94ced074822e8fe205b51e618eb5ac5cbf727a785a94ef14b1eccc136de19599ca8c2e&amp;mpshare&#x3D;1&amp;scene&#x3D;23&amp;srcid&#x3D;0720pKhXgFwuL0kqaov8YqHZ&amp;sharer_sharetime&#x3D;1595255579779&amp;sharer_shareid&#x3D;d439481da0998db784a4fe3429654f79#rd"},{"title":"GUID生成算法","path":"posts/20a.html","text":"随机数不管是前端还是后端都会用到的一个地方，不管是从验证码还是各种生成的状态码，基本都是随机生成的，还有就是一些抽奖的算法，也是用随机数来处理的，生成随机数的方法目前是很多的，但是其实很多是重复性很大的，今天简单的讲一下怎么生成随机数重复性很低的一种办法GUID（Globally Unique Identifier）一种由算法生成的二进制长度为128位的数字标识符 不重复的原理：GUID 的总数达到了2^128（3.4×10^38）个，所以随机生成两个相同GUID的可能性非常小，但并不为0。用于生成GUID的算法通常都加入了非随机的参数（如时间），以保证这种重复的情况不会发生。 不BB上代码： GUID的 js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147function GUID() &#123; this.date = new Date(); /* 判断是否初始化过，如果初始化过以下代码，则以下代码将不再执行，实际中只执行一次 */ if (typeof this.newGUID != &#x27;function&#x27;) &#123; /* 生成GUID码 */ GUID.prototype.newGUID = function() &#123; this.date = new Date(); var guidStr = &#x27;&#x27;; sexadecimalDate = this.hexadecimal(this.getGUIDDate(), 16); sexadecimalTime = this.hexadecimal(this.getGUIDTime(), 16); for (var i = 0; i &lt; 9; i++) &#123; guidStr += Math.floor(Math.random()*16).toString(16); &#125; guidStr += sexadecimalDate; guidStr += sexadecimalTime; while(guidStr.length &lt; 32) &#123; guidStr += Math.floor(Math.random()*16).toString(16); &#125; return this.formatGUID(guidStr); &#125; /* * 功能：获取当前日期的GUID格式，即8位数的日期：19700101 值：返回GUID日期格式的字条串 */ GUID.prototype.getGUIDDate = function() &#123; return this.date.getFullYear() + this.addZero(this.date.getMonth() + 1) + this.addZero(this.date.getDay()); &#125; /* * 功能：获取当前时间的GUID格式，即8位数的时间，包括毫秒，毫秒为2位数：12300933 值：返回GUID日期格式的字条串 */ GUID.prototype.getGUIDTime = function() &#123; return this.addZero(this.date.getHours()) + this.addZero(this.date.getMinutes()) + this.addZero(this.date.getSeconds()) + this.addZero( parseInt(this.date.getMilliseconds() / 10 )); &#125; /* * 功能: 为一位数的正整数前面添加0，如果是可以转成非NaN数字的字符串也可以实现 : 参数表示准备再前面添加0的数字或可以转换成数字的字符串 * 返回值: 如果符合条件，返回添加0后的字条串类型，否则返回自身的字符串 */ GUID.prototype.addZero = function(num) &#123; if (Number(num).toString() != &#x27;NaN&#x27; &amp;&amp; num &gt;= 0 &amp;&amp; num &lt; 10) &#123; return &#x27;0&#x27; + Math.floor(num); &#125; else &#123; return num.toString(); &#125; &#125; /* * 功能：将y进制的数值，转换为x进制的数值 ：第1个参数表示欲转换的数值；第2个参数表示欲转换的进制；第3个参数可选，表示当前的进制数，如不写则为10 * 返回值：返回转换后的字符串 */ GUID.prototype.hexadecimal = function(num, x, y) &#123; if (y != undefined) &#123; return parseInt(num.toString(), y).toString(x); &#125; else &#123; return parseInt(num.toString()).toString(x); &#125; &#125; /* * 功能：格式化32位的字符串为GUID模式的字符串 ：第1个参数表示32位的字符串 * 返回值：标准GUID格式的字符串 */ GUID.prototype.formatGUID = function(guidStr) &#123; var str1 = guidStr.slice(0, 8) + &#x27;-&#x27;, str2 = guidStr.slice(8, 12) + &#x27;-&#x27;, str3 = guidStr.slice(12, 16) + &#x27;-&#x27;, str4 = guidStr.slice(16, 20) + &#x27;-&#x27;, str5 = guidStr.slice(20); return str1 + str2 + str3 + str4 + str5; &#125; &#125;&#125; HTML代码： 1234567891011121314151617181920212223242526272829303132333435363738&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;script src=&quot;../js/guid.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;var guid = new GUID();var radom = guid.newGUID();/*正则处理一下，将中间的-去掉*/var str = radom.replace(/-/g, &quot;&quot;);alert(radom);alert(str);&lt;/script&gt;&lt;/html&gt; 作者：何处锦绣不灰堆 来源：CSDN 原文：https://blog.csdn.net/qq_41485414/article/details/80106955"},{"title":"Oracle数据库学习","path":"posts/78e.html","text":"SQL基础主键 在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，students表的两行记录： id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。 对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为主键。 例如，假设我们把name字段作为主键，那么通过名字小明或小红就能唯一确定一条记录。但是，这么设定，就没法存储同名的同学了，因为插入相同主键的两条记录是不被允许的。 对主键的要求，最关键的一点是：记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。 由于主键的作用十分重要，如何选取主键会对业务开发产生重要影响。如果我们以学生的身份证号作为主键，似乎能唯一定位记录。然而，身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。 所以，选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。 因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。 作为主键最好是完全业务无关的字段，我们一般把这个字段命名为id。常见的可作为id字段的类型有： 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键； 全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。 对于大部分应用来说，通常自增类型的主键就能满足需求。我们在students表中定义的主键也是BIGINT NOT NULL AUTO_INCREMENT类型。 如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。 联合主键关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。 对于联合主键，允许一列有重复，只要不是所有主键列都重复即可： id_num id_type other columns… 1 A … 2 A … 2 B … 如果我们把上述表的id_num和id_type这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。 没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。 小结主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许NULL。 可以使用多个列作为联合主键，但联合主键并不常用。 外键 当我们用主键唯一标识记录时，我们就可以在students表中确定任意一个学生的记录： id name other columns… 1 小明 … 2 小红 … 我们还可以在classes表中确定任意一个班级记录： id name other columns… 1 一班 … 2 二班 … 但是我们如何确定students表的一条记录，例如，id=1的小明，属于哪个班级呢？ 由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个classes的记录可以对应多个students表的记录。 为了表达这种一对多的关系，我们需要在students表中加入一列class_id，让它的值与classes表的某条记录相对应： id class_id name other columns… 1 1 小明 … 2 1 小红 … 5 2 小白 … 这样，我们就可以根据class_id这个列直接定位出一个students表的记录应该对应到classes的哪条记录。 例如： 小明的class_id是1，因此，对应的classes表的记录是id=1的一班； 小红的class_id是1，因此，对应的classes表的记录是id=1的一班； 小白的class_id是2，因此，对应的classes表的记录是id=2的二班。 在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键。 外键并不是通过列名实现的，而是通过定义外键约束实现的： 1234ALTER TABLE studentsADD CONSTRAINT fk_class_idFOREIGN KEY (class_id)REFERENCES classes (id); 其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。 通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果classes表不存在id=99的记录，students表就无法插入class_id=99的记录。 由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。 要删除一个外键约束，也是通过ALTER TABLE实现的： 12ALTER TABLE studentsDROP FOREIGN KEY fk_class_id; 注意：删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN ...实现的。 多对多通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。 多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系： teachers表： id name 1 张老师 2 王老师 3 李老师 4 赵老师 classes表： id name 1 一班 2 二班 中间表teacher_class关联两个一对多关系： id teacher_id class_id 1 1 1 2 1 2 3 2 1 4 2 2 5 3 1 6 4 2 通过中间表teacher_class可知teachers到classes的关系： id=1的张老师对应id=1,2的一班和二班； id=2的王老师对应id=1,2的一班和二班； id=3的李老师对应id=1的一班； id=4的赵老师对应id=2的二班。 同理可知classes到teachers的关系： id=1的一班对应id=1,2,3的张老师、王老师和李老师； id=2的二班对应id=1,2,4的张老师、王老师和赵老师； 因此，通过中间表，我们就定义了一个“多对多”关系。 一对一一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。 例如，students表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表contacts，我们就可以得到一个“一对一”关系： id student_id mobile 1 1 135xxxx6300 2 2 138xxxx2209 3 5 139xxxx8086 有细心的童鞋会问，既然是一对一关系，那为啥不给students表增加一个mobile列，这样就能合二为一了？ 如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，contacts表就不存在对应的记录。实际上，一对一关系准确地说，是contacts表一对一对应students表。 还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表user_info和用户详细信息表user_profiles，大部分时候，只需要查询user_info表，并不需要查询user_profiles表，这样就提高了查询速度。 小结关系数据库通过外键可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。 索引 在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。 索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。 例如，对于students表： id class_id name gender score 1 1 小明 M 90 2 1 小红 F 95 3 1 小军 M 88 如果要经常根据score列进行查询，就可以对score列创建索引： 12ALTER TABLE studentsADD INDEX idx_score (score); 使用ADD INDEX idx_score (score)就创建了一个名称为idx_score，使用列score的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如： 12ALTER TABLE studentsADD INDEX idx_name_score (name, score); 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。 可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。 对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。 唯一索引在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。 但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设students表的name不能重复： 12ALTER TABLE studentsADD UNIQUE INDEX uni_name (name); 通过UNIQUE关键字我们就添加了一个唯一索引。 也可以只对某一列添加一个唯一约束而不创建唯一索引： 12ALTER TABLE studentsADD CONSTRAINT uni_name UNIQUE (name); 这种情况下，name列没有索引，但仍然具有唯一性保证。 无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。 小结通过对数据库表创建索引，可以提高查询速度。 通过创建唯一索引，可以保证某一列的值具有唯一性。 数据库索引对于用户和应用程序来说都是透明的。 基本查询 要查询数据库表的数据，我们使用如下的SQL语句： 1SELECT * FROM &lt;表名&gt; 假设表名是students，要查询students表的所有行，我们用如下SQL语句： 1SELECT * FROM students; 使用SELECT * FROM students时，SELECT是关键字，表示将要执行一个查询，*表示“所有列”，FROM表示将要从哪个表查询，本例中是students表。 该SQL将查询出students表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。 要查询classes表的所有行，我们用如下SQL语句： 1SELECT * FROM classes; 运行上述SQL语句，观察查询结果。 SELECT语句其实并不要求一定要有FROM子句。我们来试试下面的SELECT语句： 1SELECT 100+200; 上述查询会直接计算出表达式的结果。虽然SELECT可以用作计算，但它并不是SQL的强项。但是，不带FROM子句的SELECT语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条SELECT 1;来测试数据库连接。 小结使用SELECT查询的基本语句SELECT * FROM &lt;表名&gt;可以查询一个表的所有行和所有列的数据。 SELECT查询的结果是一个二维表。 条件查询 使用SELECT * FROM &lt;表名&gt;可以查询到一张表的所有记录。但是，很多时候，我们并不希望获得所有记录，而是根据条件选择性地获取指定条件的记录，例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。 SELECT语句可以通过WHERE条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成WHERE条件就是SELECT * FROM students WHERE score &gt;= 80。 其中，WHERE关键字后面的score &gt;= 80就是条件。score是列名，该列存储了学生的成绩，因此，score &gt;= 80就筛选出了指定条件的记录： 12SELECT * FROM students WHERE score &gt;= 80; 因此，条件查询的语法就是： 1SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt; 条件表达式可以用&lt;条件1&gt; AND &lt;条件2&gt;表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来： 条件1：根据score列的数据判断：score &gt;= 80； 条件2：根据gender列的数据判断：gender = &#39;M&#39;，注意gender列存储的是字符串，需要用单引号括起来。 就可以写出WHERE条件：score &gt;= 80 AND gender = &#39;M&#39;： 12SELECT * FROM students WHERE score &gt;= 80 AND gender = &#x27;M&#x27;; 第二种条件是&lt;条件1&gt; OR &lt;条件2&gt;，表示满足条件1或者满足条件2。例如，把上述AND查询的两个条件改为OR，查询结果就是“分数在80分或以上”或者“男生”，满足任意之一的条件即选出该记录： 12SELECT * FROM students WHERE score &gt;= 80 OR gender = &#x27;M&#x27;; 很显然OR条件要比AND条件宽松，返回的符合条件的记录也更多。 第三种条件是NOT &lt;条件&gt;，表示“不符合该条件”的记录。例如，写一个“不是2班的学生”这个条件，可以先写出“是2班的学生”：class_id = 2，再加上NOT：NOT class_id = 2： 12SELECT * FROM students WHERE NOT class_id = 2; 上述NOT条件NOT class_id = 2其实等价于class_id &lt;&gt; 2，因此，NOT查询不是很常用。 要组合三个或者更多的条件，就需要用小括号()表示如何进行条件运算。例如，编写一个复杂的条件：分数在80以下或者90以上，并且是男生： 12SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = &#x27;M&#x27;; 如果不加括号，条件运算按照NOT、AND、OR的优先级进行，即NOT优先级最高，其次是AND，最后是OR。加上括号可以改变优先级。 常用的条件表达式 条件 表达式举例1 表达式举例2 说明 使用&#x3D;判断相等 score &#x3D; 80 name &#x3D; ‘abc’ 字符串需要用单引号括起来 使用&gt;判断大于 score &gt; 80 name &gt; ‘abc’ 字符串比较根据ASCII码，中文字符比较根据数据库设置 使用&gt;&#x3D;判断大于或相等 score &gt;&#x3D; 80 name &gt;&#x3D; ‘abc’ 使用&lt;判断小于 score &lt; 80 name &lt;&#x3D; ‘abc’ 使用&lt;&#x3D;判断小于或相等 score &lt;&#x3D; 80 name &lt;&#x3D; ‘abc’ 使用&lt;&gt;判断不相等 score &lt;&gt; 80 name &lt;&gt; ‘abc’ 使用LIKE判断相似 name LIKE ‘ab%’ name LIKE ‘%bc%’ %表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’ 小结通过WHERE条件查询，可以筛选出符合指定条件的记录，而不是整个表的所有记录。 投影查询 使用SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。 如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用SELECT 列1, 列2, 列3 FROM ...，让结果集仅包含指定列。这种操作称为投影查询。 例如，从students表中返回id、score和name这三列： 12SELECT id, score, name FROM students; 这样返回的结果集就只包含了我们指定的列，并且，结果集的列的顺序和原表可以不一样。 使用SELECT 列1, 列2, 列3 FROM ...时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...。 例如，以下SELECT语句将列名score重命名为points，而id和name列名保持不变： 12SELECT id, score points, name FROM students; 投影查询同样可以接WHERE条件，实现复杂的查询： 12SELECT id, score points, name FROM students WHERE gender = &#x27;M&#x27;; 小结使用SELECT *表示查询表的所有列，使用SELECT 列1, 列2, 列3则可以仅返回指定列，这种操作称为投影。 SELECT语句可以对结果集的列进行重命名。 排序 排序我们使用SELECT查询时，细心的读者可能注意到，查询结果集通常是按照id排序的，也就是根据主键排序。这也是大部分数据库的做法。如果我们要根据其他条件排序怎么办？可以加上ORDER BY子句。例如按照成绩从低到高进行排序： 12SELECT id, name, gender, score FROM students ORDER BY score; 如果要反过来，按照成绩从高到底排序，我们可以加上DESC表示“倒序”： 12SELECT id, name, gender, score FROM students ORDER BY score DESC; 如果score列有相同的数据，要进一步排序，可以继续添加列名。例如，使用ORDER BY score DESC, gender表示先按score列倒序，如果有相同分数的，再按gender列排序： 12SELECT id, name, gender, score FROM students ORDER BY score DESC, gender; 默认的排序规则是ASC：“升序”，即从小到大。ASC可以省略，即ORDER BY score ASC和ORDER BY score效果一样。 如果有WHERE子句，那么ORDER BY子句要放到WHERE子句后面。例如，查询一班的学生成绩，并按照倒序排序： 12345SELECT id, name, gender, scoreFROM studentsWHERE class_id = 1ORDER BY score DESC; 这样，结果集仅包含符合WHERE条件的记录，并按照ORDER BY的设定排序。 小结使用ORDER BY可以对结果集进行排序； 可以对多列进行升序、倒序排序。 分页 使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。 要实现分页功能，实际上就是从结果集中显示第1100条记录作为第1页，显示第101200条记录作为第2页，以此类推。 因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过LIMIT &lt;M&gt; OFFSET &lt;N&gt;子句实现。我们先把所有学生按照成绩从高到低进行排序： 12SELECT id, name, gender, score FROM students ORDER BY score DESC; 现在，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用LIMIT 3 OFFSET 0： 12345SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 0; 上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。 如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3： 12345SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 3; 类似的，查询第3页的时候，OFFSET应该设定为6: 12345SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 6; 查询第4页的时候，OFFSET应该设定为9: 12345SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 9; 由于第4页只有1条记录，因此最终结果集按实际数量1显示。LIMIT 3表示的意思是“最多3条记录”。 可见，分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize（这里是3），然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值： LIMIT总是设定为pageSize； OFFSET计算公式为pageSize * (pageIndex - 1)。 这样就能正确查询出第N页的记录集。 如果原本记录集一共就10条记录，但我们把OFFSET设置为20，会得到什么结果呢？ 12345SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 20; OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。 注意OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。 在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15。 使用LIMIT &lt;M&gt; OFFSET &lt;N&gt;分页时，随着N越来越大，查询效率也会越来越低。 小结使用LIMIT &lt;M&gt; OFFSET &lt;N&gt;可以对结果集进行分页，每次查询返回结果集的一部分； 分页查询需要先确定每页的数量和当前页数，然后确定LIMIT和OFFSET的值。 聚合查询 如果我们要统计一张表的数据量，例如，想查询students表一共有多少条记录，难道必须用SELECT * FROM students查出来然后再数一数有多少行吗？ 这个方法当然可以，但是比较弱智。对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。 仍然以查询students表一共有多少条记录为例，我们可以使用SQL内置的COUNT()函数查询： 12SELECT COUNT(*) FROM students; COUNT(*)表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(*)。 通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果： 12SELECT COUNT(*) num FROM students; COUNT(*)和COUNT(id)实际上是一样的效果。另外注意，聚合查询同样可以使用WHERE条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等： 12SELECT COUNT(*) boys FROM students WHERE gender = &#x27;M&#x27;; 除了COUNT()函数外，SQL还提供了如下聚合函数： 函数 说明 SUM 计算某一列的合计值，该列必须为数值类型 AVG 计算某一列的平均值，该列必须为数值类型 MAX 计算某一列的最大值 MIN 计算某一列的最小值 注意，MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。 要统计男生的平均成绩，我们用下面的聚合查询： 12SELECT AVG(score) average FROM students WHERE gender = &#x27;M&#x27;; 要特别注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL： 每页3条记录，如何通过聚合查询获得总页数？ SELECT CEILING(COUNT(*) &#x2F; 3) FROM students; 分组如果我们要统计一班的学生数量，我们知道，可以用SELECT COUNT(*) num FROM students WHERE class_id = 1;。如果要继续统计二班、三班的学生数量，难道必须不断修改WHERE条件来执行SELECT语句吗？ 对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询： 12SELECT COUNT(*) num FROM students GROUP BY class_id; 执行这个查询，COUNT()的结果不再是一个，而是3个，这是因为，GROUP BY子句指定了按class_id分组，因此，执行该SELECT语句时，会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。 但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把class_id列也放入结果集中： 12SELECT class_id, COUNT(*) num FROM students GROUP BY class_id; 这下结果集就可以一目了然地看出各个班级的学生人数。我们再试试把name放入结果集： 12SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id; 不出意外，执行这条查询我们会得到一个语法错误，因为在任意一个分组中，只有class_id都相同，name是不同的，SQL引擎不能把多个name的值放入一行记录中。因此，聚合查询的列中，只能放入分组的列。 练习请使用一条SELECT查询查出每个班级的平均分： 12SELECT class_id, avg(score) from students group by class_id 请使用一条SELECT查询查出每个班级男生和女生的平均分： 12SELECT class_id,gender, avg(score) from students group by class_id,gender; 多表查询SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：SELECT * FROM &lt;表1&gt; &lt;表2&gt;。 例如，同时从students表和classes表的“乘积”，即查询数据，可以这么写： 12select * from students,classes 这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。 这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。 你可能还注意到了，上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理 要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名： 123456789SELECT students.id sid, students.name, students.gender, students.score, classes.id cid, classes.name cnameFROM students, classes; 注意，多表查询时，要使用表名.列名这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用表名.列名这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点： 123456789SELECT a.id sid, a.name, a.gender, a.score, b.id cid, b.name cnameFROM students a, classes b; 注意到FROM子句给表设置别名的语法是FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;。这样我们用别名s和c分别表示students表和classes表。 多表查询也是可以添加WHERE条件的，我们来试试： 12345678910SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cnameFROM students s, classes cWHERE s.gender = &#x27;M&#x27; AND c.id = 1; 这个查询的结果集每行记录都满足条件s.gender = &#39;M&#39;和c.id = 1。添加WHERE条件后结果集的数量大大减少了。 小结使用多表查询可以获取M x N行记录； 多表查询的结果集可能非常巨大，要小心使用。 连接查询 连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。 例如，我们想要选出students表的所有学生信息，可以用一条简单的SELECT语句完成： 1select * from students; 但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。 现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。 这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现： 1234select s.id ,s.name,s.class_id,c.name classname,s.gender, s.scorefrom students sinner join classes con s.class_id = c.id; 注意INNER JOIN查询的写法是： 先确定主表，仍然使用FROM &lt;表1&gt;的语法； 再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法； 然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接； 可选：加上WHERE子句、ORDER BY等子句。 使用别名不是必须的，但可以更好地简化查询语句。 那什么是内连接（INNER JOIN）呢？先别着急，有内连接（INNER JOIN）就有外连接（OUTER JOIN）。我们把内连接查询改成外连接查询，看看效果： 12345SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sRIGHT OUTER JOIN classes cON s.class_id = c.id; 执行上述RIGHT OUTER JOIN可以看到，和INNER JOIN相比，RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如name、gender、score都为NULL。 这也容易理解，因为根据ON条件s.class_id = c.id，classes表的id&#x3D;4的行正是“四班”，但是，students表中并不存在class_id&#x3D;4的行。 有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是： INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_fdid包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。 RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。 LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id&#x3D;5，由于classes表并不存在id&#x3D;5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL： 12345SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sLEFT OUTER JOIN classes cON s.class_id = c.id; 最后，我们使用FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL： 12345SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sFULL OUTER JOIN classes cON s.class_id = c.id; 对于这么多种JOIN查询，到底什么使用应该用哪种呢？其实我们用图来表示结果集就一目了然了。 假设查询语句是： 1SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2; 我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录： LEFT OUTER JOIN是选出左表存在的记录： RIGHT OUTER JOIN是选出右表存在的记录： FULL OUTER JOIN则是选出左右表都存在的记录： 小结JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上； INNER JOIN是最常用的一种JOIN查询，它的语法是SELECT ... FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件...&gt;； JOIN查询仍然可以使用WHERE条件和ORDER BY排序。 INSERT 当我们需要向数据库表中插入一条新记录时，就必须使用INSERT语句。 INSERT语句的基本语法是： 1INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...); 例如，我们向students表插入一条新记录，先列举出需要插入的字段名称，然后在VALUES子句中依次写出对应字段的值： 123INSERT INTO students (class_id, name, gender, score) VALUES (2, &#x27;大牛&#x27;, &#x27;M&#x27;, 80);-- 查询并观察结果:SELECT * FROM students; 注意到我们并没有列出id字段，也没有列出id字段对应的值，这是因为id字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在INSERT语句中也可以不出现。 要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。也就是说，可以写INSERT INTO students (score, gender, name, class_id) ...，但是对应的VALUES就得变成(80, &#39;M&#39;, &#39;大牛&#39;, 2)。 还可以一次性添加多条记录，只需要在VALUES子句中指定多个记录值，每个记录是由(...)包含的一组值： 12345INSERT INTO students (class_id, name, gender, score) VALUES (1, &#x27;大宝&#x27;, &#x27;M&#x27;, 87), (2, &#x27;二宝&#x27;, &#x27;M&#x27;, 81);SELECT * FROM students; 小结使用INSERT，我们就可以一次向一个表中插入一条或多条记录。 UPDATE 如果要更新数据库表中的记录，我们就必须使用UPDATE语句。 UPDATE语句的基本语法是： 1UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...; 例如，我们想更新students表id=1的记录的name和score这两个字段，先写出UPDATE students SET name=&#39;大牛&#39;, score=66，然后在WHERE子句中写出需要更新的行的筛选条件id=1： 12update students set name=&#x27;大牛&#x27; ,score=66where id=4; 注意到UPDATE语句的WHERE条件和SELECT语句的WHERE条件其实是一样的，因此完全可以一次更新多条记录： 1UPDATE students SET name=&#x27;小牛&#x27;, score=77 WHERE id&gt;=5 AND id&lt;=7; 在UPDATE语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分： 12update students set score:=score+10 where score&lt;80 其中，SET score=score+10就是给当前行的score字段的值加上了10。 如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新。 最后，要特别小心的是，UPDATE语句可以没有WHERE条件，例如： 1UPDATE students SET score=60; 这时，整个表的所有记录都会被更新。所以，在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。 MySQL在使用MySQL这类真正的关系数据库时，UPDATE语句会返回更新的行数以及WHERE条件匹配的行数。 例如，更新id=1的记录时： 123mysql&gt; UPDATE students SET name=&#x27;大宝&#x27; WHERE id=1;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 MySQL会返回1，可以从打印的结果Rows matched: 1 Changed: 1看到。 当更新id=999的记录时： 123mysql&gt; UPDATE students SET name=&#x27;大宝&#x27; WHERE id=999;Query OK, 0 rows affected (0.00 sec)Rows matched: 0 Changed: 0 Warnings: 0 MySQL会返回0，可以从打印的结果Rows matched: 0 Changed: 0看到。 小结使用UPDATE，我们就可以一次更新表中的一条或多条记录。 DELETE 如果要删除数据库表中的记录，我们可以使用DELETE语句。 DELETE语句的基本语法是： 1DELETE FROM &lt;表名&gt; WHERE ...; 例如，我们想删除students表中id=1的记录，就需要这么写： 12delete from students where id=1; 注意到DELETE语句的WHERE条件也是用来筛选需要删除的行，因此和UPDATE类似，DELETE语句也可以一次删除多条记录： 1delete from studebts where id in(4,5,6) 如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除。 最后，要特别小心的是，和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据： 1DELETE FROM students; 这时，整个表的所有记录都会被删除。所以，在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。 MySQL在使用MySQL这类真正的关系数据库时，DELETE语句也会返回删除的行数以及WHERE条件匹配的行数。 例如，分别执行删除id=1和id=999的记录： 12345mysql&gt; DELETE FROM students WHERE id=1;Query OK, 1 row affected (0.01 sec)mysql&gt; DELETE FROM students WHERE id=999;Query OK, 0 rows affected (0.01 sec) 小结使用DELETE，我们就可以一次删除表中的一条或多条记录。 PL&#x2F;SQL程序设计附：代码中使用的数据库在文章尾给出 什么是PL&#x2F;SQL?PL&#x2F;SQL是 Procedure Language &amp; Structured Query Language 的缩写。PL&#x2F;SQL是对SQL语言存储过程语言的扩展。 指在SQL命令语言中增加了过程处理语句（如分支、循环等），使SQL语言具有过程处理能力。 把SQL语言的数据操纵能力与过程语言的数据处理能力结合起来，使得PLSQL面向过程但比过程语言简单、高效、灵活和实用。 PL&#x2F;SQL的优点或特征1 有利于客户&#x2F;服务器环境应用的运行 2 适合于客户环境 3 过程化 4 模块化 5 运行错误的可处理性 6 提供大量内置程序包 PL&#x2F;SQL 可用的SQL语句PL&#x2F;SQL是ORACLE系统的核心语言，现在ORACLE的许多部件都是由PL&#x2F;SQL写成。在PL&#x2F;SQL中可以使用的SQL语句有：INSERT，UPDATE，DELETE，SELECT INTO，COMMIT，ROLLBACK，SAVEPOINT。提示：在 PL&#x2F;SQL中只能用 SQL语句中的 DML 部分，不能用 DDL 部分，如果要在PL&#x2F;SQL中使用DDL(如CREATE table 等)的话，只能以动态的方式来使用。ORACLE 的 PL&#x2F;SQL 组件在对 PL&#x2F;SQL 程序进行解释时，同时对在其所使用的表名、列名及数据类型进行检查。PL&#x2F;SQL 可以在SQL*PLUS 中使用。PL&#x2F;SQL 可以在高级语言中使用。PL&#x2F;SQL可以在ORACLE的开发工具中使用(如：SQL Developer或Procedure Builder等)。其它开发工具也可以调用PL&#x2F;SQL编写的过程和函数，如Power Builder 等都可以调用服务器端的PL&#x2F;SQL过程。 PL&#x2F;SQL程序结构及组成 变量和常量说明 第一个PL&#x2F;SQL程序123456set serveroutput on; //打開輸出declare beginDBMS_OUTPUT.PUT_LINE(&#x27;我的第一個pl/sql程序&#x27;);end; 引用型变量eg: 123456789101112--引用型变量: 查询并打印empno為7521的ename和jobdeclare--定义变量保存ename和job pename emp.ename%type; pjob emp.job%type; begin --查询 select ename,job into pename,pjob from emp where empno=7521; DBMS_OUTPUT.PUT_LINE(pename||&#x27;的job是&#x27;||pjob); end; 记录型变量123456789-- 记录型变量：查询并打印empno為7521的ename和jobdeclare emp_rec emp%rowtype;begin select * into emp_rec from emp where empno=7521; DBMS_OUTPUT.PUT_LINE(emp_rec.ename||&#x27;的job是&#x27;||emp_rec.job);end; if语句判断输入的是正数还是负数 1234567891011121314--接受键盘输入--变量num：是一个地址值，在该地址上保存了输入的值accept num PROMPT &#x27;亲输入一个数字：&#x27;;declare pnumber number :=&amp;num;begin if pnumber=0 then DBMS_OUTPUT.PUT_LINE(&#x27;输入的是0&#x27;); ELSIF pnumber&gt;0 then dbms_output.put_line(&#x27;输入的是正数&#x27;); ELSE dbms_output.put_line(&#x27;输入的是负数&#x27;); end if;end; 求两个数的和1234567891011121314151617----如果要在屏幕上输出信息，需要将serveroutput开关打开set serveroutput on-- 例6：求两个数得和-- 接收键盘输入accept num1 prompt &#x27;请输入第一个数&#x27;accept num2 prompt &#x27;请输入第二个数&#x27;declare --定义变量保存输入得数字 pnum1 number :=&amp;num1; pnum2 number :=&amp;num2; psum number :=0;begin psum :=pnum1+pnum2; DBMS_OUTPUT.PUT_LINE(pnum1||&#x27;+&#x27;||pnum2||&#x27;=&#x27;||psum);end; 求1加到n的和使用while1234567891011121314--求1加到n的和使用whileaccept n prompt&#x27;请输入n&#x27;;declare n number :=&amp;n; i number :=0; ans number :=0;begin while i&lt;n loop ans:=ans+i; i:=i+1; end loop; dbms_output.put_line(ans);end; 求1加到n的和使用do while12345678910111213141516171819--如果要在屏幕上输出信息，需要将serveroutput开关打开set serveroutput on-- 使用do while:求 1 加到 n 的和(循环)-- 接收键盘输入accept num prompt &#x27;请输入一个数&#x27;declare --定义变量保存输入 的数字 pnum number := &amp;num; pn number :=1; psum number :=0;begin loop exit when pn&gt;pnum; psum :=psum+pn; pn :=pn+1; end loop; -- 循环结束打印 dbms_output.put_line(&#x27;1加到&#x27;||pnum||&#x27;的和为&#x27;||psum);end; 求1加到n的和使用for123456789101112131415161718--如果要在屏幕上输出信息，需要将serveroutput开关打开set serveroutput on-- 使用for:求 1 加到 n 的和(循环)-- 接收键盘输入accept num prompt &#x27;请输入一个数&#x27;declare --定义变量保存输入 的数字 pnum number := &amp;num; psum number :=0;begin for I in 1..pnum --for循环的I直接使用，不用定义。1..100表示1到100的意思。不能有分号。 loop psum :=psum+I; end loop; -- 循环结束打印 dbms_output.put_line(&#x27;1加到&#x27;||pnum||&#x27;的和为&#x27;||psum);end; 给SALESMAN涨10%的工资，给ANALYST涨5%的工资(游标)1、显式游标处理需四个PL&#x2F;SQL步骤： 2、显式游标属性%FOUND 布尔值属性，当最近一次读记录时成功返回，则返回TURE %NOTFOUND 布尔值属性，与%FOUND相反 %ISOPEN 布尔值属性，当游标已打开时返回TURE %ROWCOUNT 数字型属性，返回已从游标中读取的记录数 1234567891011121314151617181920212223-- 给SALESMAN涨10%的工资，给ANALYST涨5%的工资declare pjob emp.job %TYPE; psal emp.sal %type; --cursor c1 is select emp.job,emp.sal from emp; --定义游标begin open c1; --打开游标 fetch c1 into pjob,psal; --取一个 while c1 % found loop if pjob=&#x27;SALESMAN&#x27; then psal:=psal+psal*0.1; dbms_output.put_line(psal); ELSIF pjob=&#x27;ANALYST&#x27; then psal:=psal+psal*0.05; dbms_output.put_line(psal); else dbms_output.put_line(&#x27;不需要改&#x27;); end if; fetch c1 into pjob,psal; end loop; close c1; --关闭光标end; 3、游标的for循环 打印出 所有的员工的工资:salary: xxx（使用for循环） 123456789declare psal emp.sal %TYPE; cursor c1 is select emp.sal from emp;begin for i in c1 loop dbms_output.put_line(i.sal); end loop;end; 使用游标打印员工的姓名和薪水1234567891011121314--使用游标打印员工的姓名和薪水declare psal emp.sal %TYPE; pname emp.ename %type; cursor c1 is select emp.ename,emp.sal from emp;begin open c1; fetch c1 into pname, psal; while c1 % found loop dbms_output.put_line(pname||&#x27;的工资是&#x27;||psal); fetch c1 into pname,psal; end loop; close c1;end; 使用带参数的游标打印员工的姓名和薪水12345678910111213141516--如果要在屏幕上输出信息，需要将serveroutput开关打开set serveroutput on-- 带参数的游标 打印指定部门的员工的姓名和薪水declare cursor c1( pno number) is select emp.ename,emp.sal from emp where deptno = pno; pname emp.ename %type; psal emp.sal %type;begin open c1(10); loop FETCH c1 into pname,psal; exit when c1 %notfound; dbms_output.put_line(pname||&#x27;的工资是&#x27;||to_char(psal,&#x27;L9,999.99&#x27;)); end loop; close c1;end; 打印指定部门的员工信息12345678910111213141516171819--打印指定部门的员工信息set serveroutput on;accept ptnonum prompt &#x27;请输入要查询的部门号：&#x27;;declare tnonum emp.deptno %type :=&amp;ptnonum; cursor c1(dnomun number) is select ename,sal,job,empno from emp where deptno=dnomun; pname emp.ename %TYPE; psal emp.sal %type; pjob emp.job %type; pempno emp.empno %type;begin open c1(tnonum); loop FETCH c1 into pname,psal,pjob,pempno; exit when c1 %notfound; dbms_output.put_line(&#x27;职位为&#x27;||pjob ||&#x27;的&#x27;||pempno||pname||&#x27;的工资为&#x27;||psal); end loop;end; 系统例外的使用 系统列外 演示系统列为被0除123456789101112131415-- 系统列外 演示系统列为被0除declare pnum number;begin pnum:=2/0; EXCEPTION when zero_divide then dbms_output.put_line(&#x27;0不能做分母&#x27;); when value_error then dbms_output.put_line(&#x27;算数或转换错误&#x27;); when others then dbms_output.put_line(&#x27;其他错误&#x27;);end; 用户自定义例外第一章 绪论考试范围： 数据、数据库、数据库系统的定义与应用、数据库的体系结构、数据库用户与管理员、数据管理技术的发展 基本要求： 掌握数据、数据库、DBA、DBS等基本概念、数据库系统的体系结构。 了解数据管理管理技术的发展、应用领域和发展方向。 数据：是事物的符号表示， 数据的含义是信息，数据是信息的载体，信息是数据的内涵。 数据库：是长期存放在计算机内，有组织，可共享的数据集合。 数据库管理系统（DBMS）：是数据库系统的核心组成部分， 数据库系统（DBS）：是计算机系统中引入数据库后的系统组成，有数据库（DB），操作系统（OS），数据库管理系统（DBMS），应用开发工具，应用系统，用户，数据库管理员（DBA）。 ​ 数据管理管理技术的发展：人工管理阶段、文件系统阶段、数据库系统阶段 数据库系统结构：外模式（用户级）、模式（概念级）、内模式（物理级） ​ 外模式：一个数据库可以有多个外模式，同一外模式可以为一个用户的多个应用系统所用，但一个应用系统只能有一个外模式， ​ 模式：一个数据库系统只能有一个模式 二级映射： 为了实现数据库三级层次的联系和转换，在三级模式之间提供了二级映射 ​ 外模式&#x2F;模式映射 ​ 模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构， ​ 模式&#x2F;内模式映射 附：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482---------------------------------------------------------- File created -十二月-22-2020 ------------------------------------------------------------------------------------------------------------------ DDL for Table BONUS--------------------------------------------------------CREATE TABLE &quot;BONUS&quot; ( &quot;ENAME&quot; VARCHAR2(10), &quot;JOB&quot; VARCHAR2(9), &quot;SAL&quot; NUMBER, &quot;COMM&quot; NUMBER);---------------------------------------------------------- DDL for Table DEPT--------------------------------------------------------CREATE TABLE &quot;DEPT&quot; ( &quot;DEPTNO&quot; NUMBER(2, 0), &quot;DNAME&quot; VARCHAR2(14), &quot;LOC&quot; VARCHAR2(13));---------------------------------------------------------- DDL for Table EMP--------------------------------------------------------CREATE TABLE &quot;EMP&quot; ( &quot;EMPNO&quot; NUMBER(4, 0), &quot;ENAME&quot; VARCHAR2(10), &quot;JOB&quot; VARCHAR2(9), &quot;MGR&quot; NUMBER(4, 0), &quot;HIREDATE&quot; DATE, &quot;SAL&quot; NUMBER(7, 2), &quot;COMM&quot; NUMBER(7, 2), &quot;DEPTNO&quot; NUMBER(2, 0));---------------------------------------------------------- DDL for Table SALGRADE--------------------------------------------------------CREATE TABLE &quot;SALGRADE&quot; ( &quot;GRADE&quot; NUMBER, &quot;LOSAL&quot; NUMBER, &quot;HISAL&quot; NUMBER);----------------------------------------------------- DATA FOR TABLE BONUS-- FILTER = none used---------------------------------------------------REM INSERTING into BONUS----------------------------------------------------- END DATA FOR TABLE BONUS-------------------------------------------------------------------------------------------------------- DATA FOR TABLE DEPT-- FILTER = none used---------------------------------------------------REM INSERTING into DEPTINSERT INTO dept ( deptno, dname, loc) VALUES ( 10, &#x27;ACCOUNTING&#x27;, &#x27;NEW YORK&#x27;);INSERT INTO dept ( deptno, dname, loc) VALUES (20, &#x27;RESEARCH&#x27;, &#x27;DALLAS&#x27;);INSERT INTO dept ( deptno, dname, loc) VALUES ( 30, &#x27;SALES&#x27;, &#x27;CHICAGO&#x27;);INSERT INTO dept ( deptno, dname, loc) VALUES ( 40, &#x27;OPERATIONS&#x27;, &#x27;BOSTON&#x27;);----------------------------------------------------- END DATA FOR TABLE DEPT-------------------------------------------------------------------------------------------------------- DATA FOR TABLE EMP-- FILTER = none used---------------------------------------------------REM INSERTING into EMPINSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES (7369, &#x27;SMITH&#x27;, &#x27;CLERK&#x27;, 7902, to_timestamp(&#x27;17-12月-80 12.00.00.000000000 上午&#x27;, &#x27;DD-MON-RR HH.MI.SS.FF AM&#x27;), 800, NULL, 20);INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES ( 7499, &#x27;ALLEN&#x27;, &#x27;SALESMAN&#x27;, 7698, to_timestamp(&#x27;20-2月 -81 12.00.00.000000000 上午&#x27;, &#x27;DD-MON-RR HH.MI.SS.FF AM&#x27;), 1600, 300, 30);INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES ( 7521, &#x27;WARD&#x27;, &#x27;SALESMAN&#x27;, 7698, to_timestamp(&#x27;22-2月 -81 12.00.00.000000000 上午&#x27;, &#x27;DD-MON-RR HH.MI.SS.FF AM&#x27;), 1250, 500, 30);INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES ( 7566, &#x27;JONES&#x27;, &#x27;MANAGER&#x27;, 7839, to_timestamp(&#x27;02-4月 -81 12.00.00.000000000 上午&#x27;, &#x27;DD-MON-RR HH.MI.SS.FF AM&#x27;), 2975, NULL, 20);INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES ( 7654, &#x27;MARTIN&#x27;, &#x27;SALESMAN&#x27;, 7698, to_timestamp(&#x27;28-9月 -81 12.00.00.000000000 上午&#x27;, &#x27;DD-MON-RR HH.MI.SS.FF AM&#x27;), 1250, 1400, 30);INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES ( 7698, &#x27;BLAKE&#x27;, &#x27;MANAGER&#x27;, 7839, to_timestamp(&#x27;01-5月 -81 12.00.00.000000000 上午&#x27;, &#x27;DD-MON-RR HH.MI.SS.FF AM&#x27;), 2850, NULL, 30);INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES ( 7782, &#x27;CLARK&#x27;, &#x27;MANAGER&#x27;, 7839, to_timestamp(&#x27;09-6月 -81 12.00.00.000000000 上午&#x27;, &#x27;DD-MON-RR HH.MI.SS.FF AM&#x27;), 2450, NULL, 10);INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES ( 7788, &#x27;SCOTT&#x27;, &#x27;ANALYST&#x27;, 7566, to_timestamp(&#x27;19-4月 -87 12.00.00.000000000 上午&#x27;, &#x27;DD-MON-RR HH.MI.SS.FF AM&#x27;), 3000, NULL, 20);INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES ( 7839, &#x27;KING&#x27;, &#x27;PRESIDENT&#x27;, NULL, to_timestamp(&#x27;17-11月-81 12.00.00.000000000 上午&#x27;, &#x27;DD-MON-RR HH.MI.SS.FF AM&#x27;), 5000, NULL, 10);INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES ( 7844, &#x27;TURNER&#x27;, &#x27;SALESMAN&#x27;, 7698, to_timestamp(&#x27;08-9月 -81 12.00.00.000000000 上午&#x27;, &#x27;DD-MON-RR HH.MI.SS.FF AM&#x27;), 1500, 0, 30);INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES ( 7876, &#x27;ADAMS&#x27;, &#x27;CLERK&#x27;, 7788, to_timestamp(&#x27;23-5月 -87 12.00.00.000000000 上午&#x27;, &#x27;DD-MON-RR HH.MI.SS.FF AM&#x27;), 1100, NULL, 20);INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES ( 7900, &#x27;JAMES&#x27;, &#x27;CLERK&#x27;, 7698, to_timestamp(&#x27;03-12月-81 12.00.00.000000000 上午&#x27;, &#x27;DD-MON-RR HH.MI.SS.FF AM&#x27;), 950, NULL, 30);INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES ( 7902, &#x27;FORD&#x27;, &#x27;ANALYST&#x27;, 7566, to_timestamp(&#x27;03-12月-81 12.00.00.000000000 上午&#x27;, &#x27;DD-MON-RR HH.MI.SS.FF AM&#x27;), 3000, NULL, 20);INSERT INTO emp ( empno, ename, job, mgr, hiredate, sal, comm, deptno) VALUES ( 7934, &#x27;MILLER&#x27;, &#x27;CLERK&#x27;, 7782, to_timestamp(&#x27;23-1月 -82 12.00.00.000000000 上午&#x27;, &#x27;DD-MON-RR HH.MI.SS.FF AM&#x27;), 1300, NULL, 10);----------------------------------------------------- END DATA FOR TABLE EMP-------------------------------------------------------------------------------------------------------- DATA FOR TABLE SALGRADE-- FILTER = none used---------------------------------------------------REM INSERTING into SALGRADEINSERT INTO salgrade ( grade, losal, hisal) VALUES ( 1, 700, 1200);INSERT INTO salgrade ( grade, losal, hisal) VALUES ( 2, 1201, 1400);INSERT INTO salgrade ( grade, losal, hisal) VALUES ( 3, 1401, 2000);INSERT INTO salgrade ( grade, losal, hisal) VALUES ( 4, 2001, 3000);INSERT INTO salgrade ( grade, losal, hisal) VALUES ( 5, 3001, 9999);----------------------------------------------------- END DATA FOR TABLE SALGRADE------------------------------------------------------------------------------------------------------------- Constraints for Table EMP--------------------------------------------------------ALTER TABLE &quot;EMP&quot; ADD CONSTRAINT &quot;PK_EMP&quot; PRIMARY KEY ( &quot;EMPNO&quot; ) ENABLE;---------------------------------------------------------- Constraints for Table DEPT--------------------------------------------------------ALTER TABLE &quot;DEPT&quot; ADD CONSTRAINT &quot;PK_DEPT&quot; PRIMARY KEY ( &quot;DEPTNO&quot; ) ENABLE;------------------------------------------------------------------------------------------------------------------ Ref Constraints for Table EMP--------------------------------------------------------ALTER TABLE &quot;EMP&quot; ADD CONSTRAINT &quot;FK_DEPTNO&quot; FOREIGN KEY ( &quot;DEPTNO&quot; ) REFERENCES &quot;DEPT&quot; ( &quot;DEPTNO&quot; ) ENABLE;-----------------------SELECT enameFROM emp; 参考：廖雪峰的官方网站 Jepson6669 PL&#x2F;SQL程序设计（四）—— 游标"},{"title":"Excel数据整理与分析","path":"posts/1.html","text":"Excel数据整理与分析 应用层工作流程知识点部分需要掌握以下基本知识点:Excel的基本工作流程及工作簿、工作表、行与列、鼠标状态、单元格的相关参数。为后面章节打牢基础! 基本工作流程数据的存储—-》 数据的处理———》数据的分析———》数据的呈现 名词解析 enter image description here 工作簿即一个Excel文件； 工作表分为当前活动工作表和非活动工作表； 如Sheet1 是当前活动工作表；其他的是非活动工作表 Alt text 一个工作簿可容纳255个工作表； 行与列CTRL+Down 可下滑至最后一行，即1048576行； CTRL+Right 可右滑至最右列，文件-选项-公式-R1C1引用样式勾选-确定，可看到有16384列； 单元格每个单元格可村32767个字符 选项卡 enter image description here 选项-自定义功能区 可以更改 编辑栏选项卡-视图可选择显示与否编辑栏 名称框 enter image description here 可对一个区域命名； 鼠标三大状态 选挥柄： 用于选择单元格区域 移动柄：用于移动或配合ctrH键盘复制单元格区域 填充柄：复制、填充单元格区域，包括数据、公式等，双击有惊喜! 实例：一.快速添加序号1.序号栏输入1 2； enter image description here 2.选中1 2这两框，鼠标移到右下角。向下拖动 Alt text 二.快速复制属性 单元格 回顾笔记整理1、Excel的基本 工作流程是数据存储数据整理-数据分析-数据呈现2、一个工作簿默认最多能建255个工作表，内存大的可以更多3、一个工作表有1048576行、16384列”4、一个工作表约172亿个单元格，-个单元格能存放32767个字符5、鼠标三大状态:选择柄、移动柄、填充柄。双击填充柄快速填充需要临近列有数据。下一节我们将学习1.2 Excel规范制表之经典的三表结构"},{"title":"win编程常用快捷键","path":"posts/7362.html","text":"常用快捷键 一、 pycharm常用快捷键编辑类： Ctrl + D 复制选定的区域或行Ctrl + Y 删除选定的行Ctrl + Alt + L 代码格式化Ctrl + Alt + O 优化导入（去掉用不到的包导入）Ctrl + 鼠标 简介&#x2F;进入代码定义Ctrl + &#x2F; 行注释 、取消注释 Ctrl + 左方括号 快速跳到代码开头Ctrl + 右方括号 快速跳到代码末尾Shift + F10 运行Shift + F9 调试 查找&#x2F;替换类： Ctrl + F 当前文件查找Ctrl + R 当前文件替换Ctrl + Shift + F 全局查找Ctrl + Shift + R 全局替换 运行类： Shift + F10 运行Shift + F9 调试Alt + Shift + F10 运行模式配置Alt + Shift + F9 调试模式配置 调试类： F8 单步调试（一行一行走）F7 进入内部Shift + F8 退出Ctrl + F8 在当前行加上断点&#x2F;断点开关Ctrl + Shift + F8 查看所有断点 导航类： Ctrl + N 快速查找类（也可查找当前工程中的文件，以文件名查找）Double Shift 任意位置查找 二、submit text3常用快捷键Ctrl+D 选词 （反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑）Ctrl+G 跳转到相应的行Ctrl+J 合并行（已选择需要合并的多行时）Ctrl+L 选择整行（按住-继续选择下行）Ctrl+M 光标移动至括号内开始或结束的位置Ctrl+T 词互换Ctrl+U 软撤销Ctrl+P 查找当前项目中的文件和快速搜索；输入 @ 查找文件主标题&#x2F;函数；或者输入 : 跳转到文件某行；Ctrl+R 快速列出&#x2F;跳转到某个函数Ctrl+K Backspace 从光标处删除至行首Ctrl+K+B 开启&#x2F;关闭侧边栏Ctrl+KK 从光标处删除至行尾Ctrl+K+T 折叠属性Ctrl+K+U 改为大写Ctrl+K+L 改为小写Ctrl+K+0 展开所有Ctrl+Enter 插入行后（快速换行）Ctrl+Tab 当前窗口中的标签页切换 Ctrl+Shift+A 选择光标位置父标签对儿Ctrl+Shift+D 复制光标所在整行，插入在该行之前ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找Ctrl+Shift+K 删除整行Ctrl+Shift+L 鼠标选中多行（按下快捷键），即可同时编辑这些行Ctrl+Shift+M 选择括号内的内容（按住-继续选择父括号）Ctrl+Shift+P 打开命令面板Ctrl+Shift+&#x2F; 注释已选择内容Ctrl+Shift+↑可以移动此行代码，与上行互换Ctrl+Shift+↓可以移动此行代码，与下行互换Ctrl+Shift+[ 折叠代码Ctrl+Shift+] 展开代码Ctrl+Shift+Enter 光标前插入行 Ctrl+PageDown 、Ctrl+PageUp 文件按开启的前后顺序切换 Ctrl+Z 撤销Ctrl+Y 恢复撤销Ctrl+F2 设置&#x2F;取消书签Ctrl+&#x2F; 注释整行（如已选择内容，同“Ctrl+Shift+&#x2F;”效果）Ctrl+鼠标左键 可以同时选择要编辑的多处文本 Shift+鼠标右键（或使用鼠标中键）可以用鼠标进行竖向多行选择Shift+F2 上一个书签Shift+Tab 去除缩进Alt+Shift+1（非小键盘）窗口分屏，恢复默认1屏Alt+Shift+2 左右分屏-2列Alt+Shift+3 左右分屏-3列Alt+Shift+4 左右分屏-4列Alt+Shift+5 等分4屏Alt+Shift+8 垂直分屏-2屏Alt+Shift+9 垂直分屏-3屏 Ctrl+Shift+分屏序号 将当前焦点页分配到分屏序号页 Alt+. 闭合当前标签Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑 Tab 缩进 自动完成F2 下一个书签F6 检测语法错误F9 行排序(按a-z)F11 全屏模式"},{"title":"CSN实验室管理系统本地配置","path":"posts/3d8b.html","text":"SVN使用软件下载：1．TortoiseSVN-1.9.6.27867-x64-svn-1.9.6.msi（svn客户端） 软件下载地址：http://subversion.apache.org/packages.html 打开网页拉到最后，看到以下的软件下载下来 2．LanguagePack_1.9.6.27867-x64-zh_CN.msi（TortoiseSVN 的汉化包） 接下来是TortoiseSVN汉化包，跟TortoiseSVN同一个页面要点击https://tortoisesvn.net/downloads.html 安装：好了，接下来是具体的安装过程，安装顺序是 1．TortoiseSVN-1.9.6.27867-x64-svn-1.9.6.msi（svn客户端） 这个比较简单，一直next 就行 安装之后如果在电脑文件空白处右击，出现以下情况就是安装成功 2．LanguagePack_1.9.6.27867-x64-zh_CN.msi（TortoiseSVN 的汉化包） 以上svn客户端安装完成并且汉化成功 链接至CSN服务器本地仓库对应远程仓库即SVN服务器，本地仓库就是用于存放各种文档、程序的一个文件夹，在自己或别人编辑完后可通过SVN更新操作把最新版本的文件下载到本地仓库，或者通过SVN提交操作把自己的更改推送到服务器以方便他人获取（SVN更新、提交操作下文会有详细的介绍）。 适当文件目录下新建一文件夹（以Test为例） 在新建本地仓库后需要右键该文件夹选择“SVN 检出”并在弹出的对话框中输入远程仓库地址以绑定SVN服务器（比如：远程仓库 https://172.22.9.219:8443/svn/csn ），然后点击确定，再在弹出登录框中，输入自己 的SVN账号、密码即可。 1234为项目开发环境修改为 https://172.22.9.219:8443/svn/csn用户名 20lczu密码 20lczu 输入账号和密码后会开始下载 目录结构： .svn是配置文件，一般不做改动 csn_lab_web是项目前端文件 csn-lab-manage-system是项目后端文件 修改文件后在Test根目录下提交 （20级同学没有修改提交权限） 另一个用户在check后就可以看到改动的文档有红色标记（无标记的重启一次） 前端配置Node.js 安装配置向大家介绍在 Windows 上安装 Node.js 的方法。 本安装教程以 Node.js v4.4.3 LTS(长期支持版本)版本为例。 Node.js 安装包及源码下载地址为：https://nodejs.org/en/download/。 你可以根据不同平台系统选择你需要的 Node.js 安装包。 Node.js 历史版本下载地址：https://nodejs.org/dist/ 本文实例以 v0.10.26 版本为例，其他版本类似， 安装步骤： 步骤 1 : 双击下载后的安装包 v0.10.26，如下所示 步骤 2 : 点击以上的Run(运行) 步骤 3 : 勾选接受协议选项，点击 next（下一步） 按钮 : 步骤 4 : Node.js默认安装目录为 “C:\\Program Files\\nodejs&quot; , 你可以修改目录，并点击 next（下一步）： 步骤 5 : 点击树形图标来选择你需要的安装模式 , 然后点击下一步 next（下一步） 步骤 6 :点击 Install（安装） 开始安装Node.js。你也可以点击 Back（返回）来修改先前的配置。 然后并点击 next（下一步）： 安装过程： 点击 Finish（完成）按钮退出安装向导。 检测PATH环境变量是否配置了Node.js，点击win+R 输入”cmd” &#x3D;&gt; 输入命令”path”，输出如下结果： 123456PATH=C:\\oraclexe\\app\\oracle\\product\\10.2.0\\server\\bin;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;c:\\python32\\python;C:\\MinGW\\bin;C:\\Program Files\\GTK2-Runtime\\lib;C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin;C:\\Program Files\\nodejs\\;C:\\Users\\rg\\AppData\\Roaming\\npm 我们可以看到环境变量中已经包含了C:\\Program Files\\nodejs\\ 检查Node.js版本 前端运行打开用svn下载的前端文件 打开文件 路径栏输入 cmd在当前目录下打开cmd 输入代码： npm run dev 访问图中链接即可 目前功能界面： ​ ​"},{"title":"CSN实验室管理系统kif组指南","path":"posts/ead6.html","text":"前端开发工具：Hbuilder X [https://www.dcloud.io/hbuilderx.html]: 编辑界面： 前端开发是做什么的？老实说，这问题我倾向于复制粘贴网上答案来应付了事。可想想逢年过节时，亲朋好友们百分百会问到这个问题，我就说一下吧。 敷衍的A：“做网站，搞网页开发的”。 偏科的B：“做UI设计的，做微信公众号的”。 装逼的C：“改变世界的”。 认真的D：“前端开发有许多方向，比如网站重构，UI设计，web应用开发，物联前端，前端AR…(省略一千字)”。 兼容性最强的万能答案：“写代码的，对，就是传说中的程序员！坐办公室用电脑的！”。 .前端开发有钱途吗？当然有，做啥没前途？乞讨乞到极致，也能乞成千万富翁。 一般来说，刚入门的新人，工资都高不到哪儿去，从1k到1w都有。注意，是刚入门，不是刚入行！管理层以下，绝大多数情况都是技术实力正比于薪资！ 互联网发达地区的薪资水平会高一截，如北京上海深圳广州杭州，互联网公司会比其他行业公司的薪资水平高一截。同等能力下，牛逼的小公司比大公司的薪资要高一点。 前端有三大基础JavaScript、CSS、HTML。光HTML就不是上述方法能掌握的，更遑论JavaScript？JavaScript是门直译型的语言，是面向对象的。对象是啥，一只喵星人一个手机一个你就是一个对象。当然，JavaScript里的对象是代码组成的，而在JavaScript里，几乎一切都是对象。 但凡是对象，那肯定是复杂的。你复杂吗？为什么复杂？对象的复杂性，很大程度取决于它自身与其依赖的周围环境。人在陆地上可以活得好好的，扔进水里，能活几分钟？水陆环境的不同，增加了人的复杂些。换成你手机也一样，把它丢进火里或水里试试。 这跟JavaScript有什么关系？ 没关系。 才怪。JavaScript是脚本语言，是条寄生虫，不寄生在宿主身上就没生命力的东西。它的宿主是什么？浏览器 or Node。 本质上，浏览器和Node都给JavaScript提供了运行时的环境，所以，这个东西，才是JavaScript的幕后老板。我们称之为JavaScript Interpreter，当然，不止这么一种叫法，还有什么Redering Engine等等，总之，它们都可以将JavaScript代码翻译成机器码，供计算机认识与使用。 没有灵魂的人，跟死人没什么两样。 JavaScript被翻译成机器码后，就有了灵魂，活过来了。 你看，JavaScript其实也是个对象。这么复杂的东西，光看书看视频听人说，能真正懂它吗？不能。这些行为最多帮我们知道它，了解它的知识体系与底层原理，顺便拓展一下眼界。要真正懂它，得不断地去使用它，以各种方式去使用它。 就像你跟一个姑娘谈恋爱，光看照片看她日志有什么用，你要牵她的手，亲吻她，拥抱她，爱她，跟她交流，做各种羞羞的事，才会真正懂她。不是么？ JavaScript尚且如此，包含它的整个前端还用说吗？ Just do it！ 从哪里开始前端的第一步？废话了一堆，来点干货。首先，回答问题前，我们来趟时空旅行。 1993年，超文本标记语言HTML（Hyper Text Markup Language）第一版面世，它只支持超链接的纯文本html文档。纯到什么地步？纯文本！超链接！没了。 纯文本是什么概念？在你的电脑桌面新建一个txt文档，在里面写上 hello world保存文档为html类型。然后双击打开它，你就可以在浏览器里看到hello world了！ 这就是纯文本html文档，纯的不能再纯的一个网页。 超链接呢？以记事本方式打开刚才的文档，把hello world替换成 1&lt;a href=&quot;http://www.baidu.com&quot;&gt;hello world&lt;/a&gt; 保存。双击打开这文档，你会在浏览器里看到带下划线的hello world，点击它，如果你能上网，那么毫无疑问，它会跳转到百度的首页。这么一个简单的文档，居然可以链接到百度，神奇吗？这就是超链接。链接互联网上的所有。 时间往前走。 1994年，层叠样式表CSS（Cascading Style Sheets）问世，这时它还没成为标准，直到1996才有第一版标准。CSS做了什么？回答这个问题得先知道HTML干了什么。HTML定义了文档的类型与内容。CSS，则决定了这些内容该如何展现。如果把HTML文档比喻成一幅纸画，那么CSS就是造物主的神力，它可以让纸画上的猫咪隐身，也可以让纸画上的鲜花变换颜色，甚至能让里面的小鸟飞出来，让高山变成平地，让沧海变成桑田。梦幻吧。 打开刚才的文档，把内容替换成 &lt;a href=&quot;http://www.baidu.com&quot; style=&quot;color: red&quot;&gt;hello world&lt;/a&gt;保存。双击打开它，你会在浏览器里看到红色的hello world。这里，style引入了CSS样式，color给这些文字打开了颜色的大门，red，涌入了进来，把它们染成了红色。 1996年，JavaScript第一版诞生。只有HTML与CSS的世界太单调，鸟会飞，却无法互相交流，猫咪看不到老鼠，老鼠也看不到猫，它们过着孤独的生活。这样的世界不真实，于是，JavaScript来了。JavaScript赋予了这些生命思考、感知与交流的能力，从此这世界变得无比精彩，无数文明诞生与消亡，演绎宇宙洪荒。 再次打开我们的文档，把内容替换成 &lt;a href=&quot;http://www.baidu.com&quot; style=&quot;color: red&quot;&gt;hello world&lt;/a&gt; 123&lt;script&gt;alert(&#x27;ni hao&#x27;);&lt;/script&gt; 保存。双击打开它，你会在浏览器里看到一个弹出的提示框，上面写着，ni hao。这里，script引入了JavaScript代码，alert表示弹出一个提示框，括号里的是提示的内容。没错，人类，你被浏览器发现了！它在向你打招呼！ 好了。 回到开始的问题上来，在哪开始前端的第一步？ 如果你刚才跟着我敲了一遍例子，那么你已经踏出了第一步。接下来的学习，是把HTML，CSS，JavaScript的所有基础知识快速泛读一遍（不求甚解，只求心中有个印象，大概知道都有些什么知识，真正要了解那些知识，应该放在后面的实践中学习，如此，效率极高），你可以在W3C或者菜鸟上面翻阅这些资料，或者在MND里阅读更详细的内容。相信MDN以后会是你经常光顾的一个地方，它就像前端的百科全书，网络图书馆，你想要的了解的，基本都能在里找到。 这个过程，集中精力不受干扰，可能需要花费大约2~3个小时的时间。 菜鸟教程https://www.runoob.com/ 主要学习板块，Js涉及到逻辑方面 菜鸟教程提供了在线编程环境，可以在这里面运行代码 项目开发中需要哪一部分就来找哪一部分的内容 快速入门B站教程（仅供参考，可以去网站上搜索适合自己的视频教程） https://www.bilibili.com/video/BV1ds411r7o7?from=search&amp;seid=15360288197946478063 H5C3+移动布局 https://www.bilibili.com/video/BV14J4114768JavaScript系列 https://www.bilibili.com/video/BV1Sy4y1C7ha在线考试方案https://www.freecodecamp.org/learn 点击开始注册 选择喜欢的方式登录，有github 账号的用github账号，无的用Email登录，qq邮箱都可以 然后登录qq邮箱输入验证码 注册成功后登陆 界面是全英文界面，题目看不懂的可以用百度翻译 freecodecamp首页freecodecamp首页一下的推荐大家用来练手 好吧？？？？？ 写完前面的时候我又找到了这个网站的中文社区 https://www.freecodecamp.one/ 就在这个中文的社区做吧"},{"title":"玩机汇总（五）：第三方刷机教程","path":"posts/c9ee.html","text":"刷第三方ROM教程1.解锁BL(已解锁可忽视)解锁工具https://www.lanzous.com/i5oszda(解锁会删除数据,自己记得备份) 准备工作，一台驱动正常的电脑，正常完整的数据线，一台拥有解锁资格的realme手机 1.打开深度测试APP，点击进入深度测试（fastboot）此时手机进入fastboot 2.下载好adb工具包，并且找到对应手机型号的twrp。 2.给twrp的img镜像和vbmeta.img（8kb大小）放入adb工具包。 3.给twrp重命名为（ twrp.img ）。 4.插上数据线连接好手机，打开adb工具包，打开cmd here.exe命令窗口 5.复制命令fastboot flashing unlock到命令窗口 如果手机出现反应询问是否解锁，用音量键选择到第二个UNLOCK THE BOOTLOADER，电源键确认 然后手机自动格式化data分区，然后静静等待开机，选择语言 到此bl解锁完成 如果没有输入命令手机无反应，应该是以下两个问题 1.驱动问题（比较常见） 解决办法：自行下载驱动，没有驱动搞什么机（手动滑稽） 2.usb接口 解决办法： 1.usb接口分为usb2.0 usb3.0更换usb接口即可解决 2.如果所有usb接口都试过仍然无法解决，可以给中间转接一下。淘宝上很多转接头 教程适用于所有realme手机 如果成功就接着往下看吧 2.进入fastboot模式使用电脑adb输入指令fastboot flashing unlock(不行下这个https://www.lanzous.com/i5ovblc) FASTBOOT如果没有自带怎么打开?部分电脑可以直接在cmd输入以下指令cd J:\\Phone\\OPPO RealmeX标准版一键刷recovery工具不行的去下载刷机软件或者找有cmd的fastboot刷机压缩包 3.刷入第三方recovery,TWRP刷入VB1.接着上一步， 2.拔掉数据线关闭命令窗口 3.手机进入fastboot，然后插好数据线，再次打开命令窗口 4.复制命令fastboot –disable-verity –disable-verification flash vbmeta vbmeta.img到命令窗口，回车键确认，不要自做聪明删掉中间的空格符号等，请完整复制粘贴 到此VB刷入成功 然后接着向下看 刷入twrp1.刷入VB成功后，不要开机，不要关闭命令窗口，不要拔掉数据线 2.复制fastboot flash recovery twrp.img粘贴到命令窗口（请完整复制） 手机按音量减，上面的绿色文字START变成红色文字recovery mode这时按电源键确认。手机会重启到twrp 如果仍然为官方recovery请你检查你的手机与电脑连接是否正常，或者之前刷入过twrp 1.进入twrp后会弹出键盘，这时解密data分区，输入锁屏密码即可 2.解密成功后下一个界面直接滑动下面的滑块，不需要管上面的文字，因为我说了你也不一定懂（滑稽）直接滑动滑块就行了，到这个界面。 到此twrp刷入成功 4.进行四清以TWRP为例,把Dalvik.system.data.cache打钩,清除(如果刷完重启一直进rec或者一直重启，现在可以把能在rec的清除选项把能清的都清了)注:部分电脑在手机清除完数据无法打开手机目录,只需重启手机即可解决问题如果进rec没有自动帮你挂载文件,自己去挂载挂载第1,2个即可 把自己要刷的rom放进手机储存即可进行刷机 开机有谷歌验证的话 重启到recovery模式,清除cache和Dalvik,重启即可 想解锁system分区有解锁不了1.直接解决办法,刷机2.不一定在一些软件可用的解锁办法→1.root后打开mt管理器2.选择system文件夹,按住会有属性,点击,在权限那行点击更改3.把用户组的写打钩,点击确定即可 可以使用syslock查看system分区是否解锁 不推荐新手线刷教程:例:群文件MIUI11包一秒刷完1.解压刷机包2.把里面的system.img vendor.img boot.img 复制到fastboot工具文件夹3.确保手机与电脑的连接,输入以下指令fastboot flash vendor vendor.imgfastboot flash system system.imgfastboot flash boot boot.img完成后即可重启"},{"title":"玩机汇总（六）：MIUI主题拆包","path":"posts/f25.html","text":"开始教程（电脑）： 一：总概括1. 主题包大概所包含常用的模块：如下图： 2. 常用模块介绍：（1）.boots文件夹—开机动画。 （2）.fonts文件夹—字体。 （3）.preview文件夹—该主题的截图介绍。 （4）.wallpaper文件夹—锁屏壁纸和桌面壁纸。 （5）.clock_2*4模块—桌面时间样式。 （6）.com.android.contacts模块—拨号键盘样式。 （7）.com.android.mms模块—短信界面（气泡、字体颜色等）。 （8）.com.android.settings模块—设置（自定义设置名字、设置内容图标等）。 （9）.com.android.systemui模块—状态栏（背景、开关图标、自定义电池后文字、纵横排开关个数，自定义信号、WIFI、电池、蓝牙、静音、闹钟等图标）。 （10）.com.android.thememanger模块—主题中心（自定义主题商店的名字、背景、修改导入本地主题按钮名称等）。 （11）.com.android.updater模块—系统升级（系统更新背景图、自定义更新按钮名字等）。 （12）.com.miui.home模块—桌面布局（修改图标布局、图标大小等）。 （13）.com.android.securitycenter模块—安全中心（背景图）。 （14）.com.android.touchassistant模块—悬浮球（自定义悬浮球样式、颜色）。 （15）.com.tencent.mobileqq模块—默认QQ主题（修改QQ默认主题样式）。 （16）. description.xml****模块—主题信息（设计师名字、主题名字、主题介绍）。 （17）. framework-miui-res模块—全局背景（设置背景，短信背景、音量图、搜索栏背景图等）。 （18）.icons模块—图标 （19）. Lockscreen****模块—锁屏样式 3.所需工具：（1）.打开MTZ主题包工具：WINR压缩或者360压缩（选择MTZ文件右键选择压缩打开，里面的模块则用ctrl+enter组合键打开）。注：我用的360压缩！！！ *（2）.XML代码修改工具：***notepad++**（百度搜索下载）。 （3）.图片编辑器：PS或者其他（光影魔术手）。 *（4）.点九图软件：***Nine-PatchEditor 小技巧：****手机应用你需要修改的主题，电脑或手机打开主题文件对应着看！ 二．模块详细修改介绍（想替换的素材直接复制粘贴进主题包对应位置替换即可！名称或图片格式或大小相同即可。） （1）. boots文件夹—开机动画，如图：（都是用很多张图片组成开机动画） 附上网上开机动画制作教程（教程仅供参考）：http://www.miui.com/thread-571473-1-1.html http://www.xiaomi.cn/content-20-6690-1.html （2）. fonts文件夹—字体（打开后字体为ttf格式） （3）. preview文件夹—该主题的截图（格式：png）介绍，如图： 注：这只是随意的主题介绍图，主题商店的主题介绍图，名称都是对应的，区别请自己下载主题商店的主题拆包研究！ （4）. wallpaper文件夹—锁屏壁纸和桌面壁纸（格式：jpg） （5）. clock_2*4模块—桌面时间样式（一般没什么可以改的，有好看的时钟样式，直接替换就行） （6）. com.android.contacts模块—拨号键盘样式 注：拨号键盘背景图名称：dialer_background.9.png&#x2F; dialer_bottom_bar_bg.9.png （7）.com.android.mms模块—短信界面（气泡、字体颜色等） （8）.com.android.settings模块—设置（自定义设置名字、设置内容图标等） （9）. com.android.systemui模块—状态栏（背景、开关图标、自定义电池后文字、纵横排开关个数，自定义信号、WIFI、电池、蓝牙、静音、闹钟等图标） 信号，WiFi，电池等通知图标所在文件夹： 状态栏全背景图名字：notification_panel_bg.png 状态栏半背景图名字：notification_list_bg.9.png 清理背景图名字：recent_task_bg.9.png 注：需要修改的内容直接复制粘贴进去替换就行！ （10）.com.android.thememanger模块—主题中心（自定义主题商店的名字、背景、修改导入本地主题按钮名称等） 背景图名字：theme_window_background.9.png （11）.com.android.updater模块—系统升级（系统更新背景图、自定义更新按钮名字等）。 （12）.com.miui.home模块—桌面布局（修改图标布局、图标大小等） （13）.com.android.securitycenter模块—安全中心（背景图）。 （14）.com.android.touchassistant模块—悬浮球（自定义悬浮球样式、颜色）。 附上颜色代码查询表：http://yusi123.com/1090.html （16）. description.xml****模块—主题信息（设计师名字、主题名字、主题介绍）。 （17）. framework-miui-res模块—全局背景（设置背景，短信背景、音量图、搜索栏背景图等）。 （18）.icons模块—图标 （19）. Lockscreen****模块—锁屏样式 注：这个没什么好说的，好看的锁屏直接替换！！！ ​ 来自： 小米主题框架交流群：【Ⅰ群：534025609、Ⅱ群：107086533】 **—Mr.**阿傑！"},{"title":"个人博客搭建（1）：Hexo搭建个人博客部署到Github","path":"posts/a167.html","text":"本文介绍Hexo搭建个人博客部署到Github Hexo 是一个轻量、快速，简单和强大的博客框架，当我们需要发布博文的时候，只需要将写好的文章（MarkDown文件）放入本地的 \\source\\_posts 文件夹，然后再推送上去就行了，原理就是当我们在执行 hexo g 命令时，.md 文件就会被转化成 HTML 文件， 安装Hexo利用 npm 命令即可安装。在任意位置点击鼠标右键，选择Git Bash 输入命令：`npm install -g hexo ` -g是指全局安装hexo。 注：如果被”墙“，可使用淘宝 NPM 镜像 ` $ npm install -g cnpm --registry=https://registry.npm.taobao.org ` 使用淘宝NPM安装Hexo ` $ cnpm install -g hexo-cli ` 与原先的npm完全一样，只是命令改为cnpm,一样等待hexo安装完成出现的WARN可以不用理会继续输入以下命令 ` $ cnpm install hexo --save ` 检验` $ hexo -v ` 初始化Hexo创建文件夹 在Hexo文件下，右键运行Git Bash，输入命令：` hexo init ` 在_config.yml,进行基础配置 这里只列举了部分，其他可以根据自己要求更改 主题主题下载 可以选择更多主题，然后在Hexo文件夹下 Git Bash ` git clone https://github.com/iissnan/hexo-theme-nextthemes/next （next为主题名字），来获得更多主题 ` 并在_config.yml中更改 本地浏览博客 分别输入 如下命令： ` hexo g hexo s ` 更多命令 在浏览器输入：localhost：4000 ，就可以进行访问 写文章在我们放置博客文件的文件夹Hexo中，source&#x2F;_posts&#x2F;目录下存放着所有博文的Markdown文件，初始化只有一个hello-world.md文件。我们可以在Git Bash中创建新博文： ` hexo new &lt;title&gt; ` 在_posts目录下会生成相应的.md文件，接下来我们可以编辑该文件，直接写博文。（注意使用Markdown语法） 文章中头部内容 ` title: typora-vue-theme主题介绍 date: 2018-09-07 09:25:00 author: kif img: /source/images/xxx.jpg top: true cover: true coverImg: /images/1.jpg password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 toc: false mathjax: false summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories: Markdown tags: - Typora - Markdown --- itle Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 写完博文后，执行即可在博客中更新。 hexo g hexo d 如果要删除博文，则直接把_posts目录下相应的.md文件删除，再执行上述命令即可。 PS：关于在博文中插入图片 可以把图片统一放置在source/images目录下，然后在使用时用下述方式引用。 ![](/images/image.jpg) ` 部署到Github上申请Github账号new repository 然后点击 Create repository 在_config.yml进行配置 仓库地址 安装hexo-deployer-git自动部署发布工具` npm install hexo-deployer-git --save ` 发布到Github`hexo c hexo g hexo d"},{"title":"个人博客搭建（5）：网页页尾鱼塘效果美化","path":"posts/f393.html","text":""},{"title":"个人博客搭建（4）：matery 主题调教（持续更新...）","path":"posts/f390.html","text":"介绍：项目地址：hexo-theme-matery 是一个采用 Material Design 和响应式设计的 Hexo 博客主题。 主页： 下载：当你看到这里的时候，应该已经有一个自己的 Hexo 博客了。如果还没有的话，不妨使用 Hexo 和 Markdown 来写博客和文章。 点击 这里 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。 当然你也可以在你的 themes 文件夹下使用 Git clone 命令来下载: git clone https://github.com/blinkfox/hexo-theme-matery.git`&lt;/pre&gt; 会得到如下文件 ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814190654.png) # [](#配置 &quot;配置&quot;)配置 ## [](#切换 &quot;切换&quot;)切换 修改 Hexo **根目录下的 `_config.yml`** （注意区分更目录下的config和主题文件下的config）的 `theme` 的值：`theme: hexo-theme-matery` （如果你重命名下载的文件的话就改为重命名后的名字，此教程已重命名为matery） ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814190510.png) ## [](#新建分类-categories-页 &quot;新建分类 categories 页&quot;)新建分类 categories 页 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814210041.png) categories即主页顶部”分类：点击所要跳转的页面 `categories` 页是用来展示所有分类的页面，如果在你的博客 `source` 目录下还没有 `categories/index.md` 文件，那么你就需要新建一个，命令如下： &lt;pre&gt;`hexo new page &quot;categories&quot;`&lt;/pre&gt; 编辑你刚刚新建的页面文件 `/source/categories/index.md`，写入以下内容： &lt;pre&gt;`--- title: categories date: 2018-09-30 17:25:30 type: &quot;categories&quot; layout: &quot;categories&quot; ---`&lt;/pre&gt; ## [](#新建标签-tags-页 &quot;新建标签 tags 页&quot;)新建标签 tags 页 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814210005.png) `about` 页是用来展示**关于我和我的博客**信息的页面，如果在你的博客 `source` 目录下还没有 `about/index.md` 文件，那么你就需要新建一个，命令如下： &lt;pre&gt;`hexo new page &quot;about&quot;`&lt;/pre&gt; 编辑你刚刚新建的页面文件 `/source/about/index.md`，至少需要以下内容： &lt;pre&gt;`--- title: about date: 2018-09-30 17:25:30 type: &quot;about&quot; layout: &quot;about&quot; ---`&lt;/pre&gt; ## [](#新建留言板-contact-页 &quot;新建留言板 contact 页&quot;)新建留言板 contact 页 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814205915.png) `contact` 页是用来展示**留言板**信息的页面，如果在你的博客 `source` 目录下还没有 `contact/index.md` 文件，那么你就需要新建一个，命令如下： &lt;pre&gt;`hexo new page &quot;contact&quot;`&lt;/pre&gt; 编辑你刚刚新建的页面文件 `/source/contact/index.md`，至少需要以下内容： &lt;pre&gt;`--- title: contact date: 2018-09-30 17:25:30 type: &quot;contact&quot; layout: &quot;contact&quot; ---`&lt;/pre&gt; ## [](#新建友情链接-friends-页 &quot;新建友情链接 friends 页&quot;)新建友情链接 friends 页 `friends` 页是用来展示**友情链接**信息的页面，如果在你的博客 `source` 目录下还没有 `friends/index.md` 文件，那么你就需要新建一个，命令如下： &lt;pre&gt;`hexo new page &quot;friends&quot;`&lt;/pre&gt; 编辑你刚刚新建的页面文件 `/source/friends/index.md`，至少需要以下内容： &lt;pre&gt;`--- title: friends date: 2018-12-12 21:25:30 type: &quot;friends&quot; layout: &quot;friends&quot; ---`&lt;/pre&gt; 同时，在你的博客 `source` 目录下新建 `_data` 目录，在 `_data` 目录中新建 `friends.json` 文件， ![image-20200814202349576](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814202349.png) 文件内容如下所示： &lt;pre&gt;`[&#123; &quot;avatar&quot;: &quot;https://s1.ax1x.com/2020/06/23/NUr8pQ.jpg&quot;, &quot;name&quot;: &quot;kif&quot;, &quot;introduction&quot;: &quot;就是本人啦！&quot;, &quot;url&quot;: &quot;https://kifroom.icu/&quot;, &quot;title&quot;: &quot;前去学习&quot; &#125;, &#123; &quot;avatar&quot;: &quot;头像地址&quot;, &quot;name&quot;: &quot;名字&quot;, &quot;introduction&quot;: &quot;介绍&quot;, &quot;url&quot;: &quot;网址&quot;, &quot;title&quot;: &quot;前去学习&quot; &#125;]`&lt;/pre&gt; 后期添加就在这儿添加就可以了 ### [](#友链信息声明： &quot;友链信息声明：&quot;)友链信息声明： 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814212249.png) `/source/friends/index.md`文件内填写即可 ## [](#新建-404-页 &quot;新建 404 页&quot;)新建 404 页 如果在你的博客 `source` 目录下还没有 `404.md` 文件，那么你就需要新建一个 编辑你刚刚新建的页面文件 `/source/404.md`，至少需要以下内容： &lt;pre&gt;`--- title: 404 date: 2018-09-30 17:25:30 type: &quot;404&quot; layout: &quot;404&quot; description: &quot;Oops～，我崩溃了！找不到你想要的页面 :(&quot; ---`&lt;/pre&gt; 这是默认的404，之后会介绍加入不受主题渲染的网页，届时可以自己写喜欢的404网页 效果： ![](https://cdn.jsdelivr.net/gh/wkif/ImageHosting/img/20200814205755.png) ## [](#菜单导航配置 &quot;菜单导航配置&quot;)菜单导航配置 ### [](#配置基本菜单导航的名称、路径url和图标icon &quot;配置基本菜单导航的名称、路径url和图标icon.&quot;)配置基本菜单导航的名称、路径url和图标icon. 1.菜单导航名称可以是中文也可以是英文(如：`Index`或`主页`) 2.图标icon 可以在[Font Awesome](https://fontawesome.com/icons) 中查找 &lt;pre&gt;`menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle Friends: url: /friends icon: fas fa-address-book`&lt;/pre&gt; ### [](#二级菜单配置方法 &quot;二级菜单配置方法&quot;)二级菜单配置方法 如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作 1.在需要添加二级菜单的一级菜单下添加`children`关键字(如:`About`菜单下添加`children`) 2.在`children`下创建二级菜单的 名称name,路径url和图标icon. 3.注意每个二级菜单模块前要加 `-`. 4.注意缩进格式 &lt;pre&gt;`menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle-o Friends: url: /friends icon: fas fa-address-book Medias: icon: fas fa-list children: - name: Musics url: /musics icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Books url: /books icon: fas fa-book - name: Galleries url: /galleries icon: fas fa-image`&lt;/pre&gt; 执行 `hexo clean &amp;amp;&amp;amp; hexo g` 重新生成博客文件，然后就可以在文章中对应位置看到你用`emoji`语法写的表情了。 ## [](#配置gitalk评论 &quot;配置gitalk评论&quot;)配置gitalk评论 效果： ![](https://cdn.jsdelivr.net/gh/wkif/ImageHosting/img/20200814205633.png) 教程：[个人博客搭建（2）:配置gitalk评论](https://kifroom.icu/posts/4.html) ## [](#代码高亮 &quot;代码高亮&quot;)代码高亮 由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 [hexo-prism-plugin](https://github.com/ele828/hexo-prism-plugin) 的 Hexo 插件来做代码高亮，安装命令如下： &lt;pre&gt;`npm i -S hexo-prism-plugin`&lt;/pre&gt; 然后，修改 Hexo 根目录下 `_config.yml` 文件中 `highlight.enable` 的值为 `false`，并新增 `prism` 插件相关的配置，主要配置如下： &lt;pre&gt;`highlight: enable: false prism_plugin: mode: &#39;preprocess&#39; # realtime/preprocess theme: &#39;tomorrow&#39; line_number: false # default false custom_css:`&lt;/pre&gt; ## [](#搜索 &quot;搜索&quot;)搜索 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814210129.png) 本主题中还使用到了 [hexo-generator-search](https://github.com/wzpan/hexo-generator-search) 的 Hexo 插件来做内容搜索，安装命令如下： &lt;pre&gt;`npm install hexo-generator-search --save`&lt;/pre&gt; 在 Hexo 根目录下的 `_config.yml` 文件中，新增以下的配置项： &lt;pre&gt;`search: path: search.xml field: post`&lt;/pre&gt; ## [](#中文链接转拼音（建议安装） &quot;中文链接转拼音（建议安装）&quot;)中文链接转拼音（建议安装） 如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 `SEO`，且 `gitment` 评论对中文链接也不支持。我们可以用 [hexo-permalink-pinyin](https://github.com/viko16/hexo-permalink-pinyin) Hexo 插件使在生成文章时生成中文拼音的永久链接。 安装命令如下： &lt;pre&gt;`npm i hexo-permalink-pinyin --save`&lt;/pre&gt; 在 Hexo 根目录下的 `_config.yml` 文件中，新增以下的配置项： &lt;pre&gt;`permalink_pinyin: enable: true separator: &#39;-&#39; # default: &#39;-&#39;`&lt;/pre&gt;&gt; **注**：除了此插件外，[hexo-abbrlink](https://github.com/rozbo/hexo-abbrlink) 插件也可以生成非中文的链接。 ## [](#文章字数统计插件（建议安装） &quot;文章字数统计插件（建议安装）&quot;)文章字数统计插件（建议安装） 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814210200.png) 如果你想要在文章中显示文章字数、阅读时长信息，可以安装 [hexo-wordcount](https://github.com/willin/hexo-wordcount)插件。 安装命令如下： &lt;pre&gt;`npm i --save hexo-wordcount`&lt;/pre&gt; 然后只需在本主题下的 `_config.yml` 文件中，将各个文章字数相关的配置激活即可： &lt;pre&gt;`postInfo: date: true update: false wordCount: false # 设置文章字数统计为 true. totalCount: false # 设置站点文章总字数统计为 true. min2read: false # 阅读时长. readCount: false # 阅读次数.`&lt;/pre&gt; ## [](#添加emoji表情支持（可选的） &quot;添加emoji表情支持（可选的）&quot;)添加emoji表情支持（可选的） 本主题新增了对`emoji`表情的支持，使用到了 [hexo-filter-github-emojis](https://npm.taobao.org/package/hexo-filter-github-emojis) 的 Hexo 插件来支持 `emoji`表情的生成，把对应的`markdown emoji`语法（`::`,例如：`:smile:`）转变成会跳跃的`emoji`表情，安装命令如下： &lt;pre&gt;`npm install hexo-filter-github-emojis --save`&lt;/pre&gt; 在 Hexo 根目录下的 `_config.yml` 文件中，新增以下的配置项： &lt;pre&gt;`githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis:`&lt;/pre&gt; ## [](#添加-RSS-订阅支持（可选的） &quot;添加 RSS 订阅支持（可选的）&quot;)添加 RSS 订阅支持（可选的） 本主题中还使用到了 [hexo-generator-feed](https://github.com/hexojs/hexo-generator-feed) 的 Hexo 插件来做 `RSS`，安装命令如下： &lt;pre&gt;`npm install hexo-generator-feed --save`&lt;/pre&gt; 在 Hexo 根目录下的 `_config.yml` 文件中，新增以下的配置项： &lt;pre&gt;`feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: &#39; &#39; order_by: -date`&lt;/pre&gt; 执行 `hexo clean &amp;amp;&amp;amp; hexo g` 重新生成博客文件，然后在 `public` 文件夹中即可看到 `atom.xml` 文件，说明你已经安装成功了。 ## [](#添加-DaoVoice-在线聊天功能（可选的） &quot;添加 DaoVoice 在线聊天功能（可选的）&quot;)添加 [DaoVoice](http://www.daovoice.io/) 在线聊天功能（可选的） 前往 [DaoVoice](http://www.daovoice.io/) 官网注册并且获取 `app_id`，并将 `app_id` 填入主题的 `_config.yml` 文件中。 ## [](#添加-Tidio-在线聊天功能（可选的） &quot;添加 Tidio 在线聊天功能（可选的）&quot;)添加 [Tidio](https://www.tidio.com/) 在线聊天功能（可选的） 前往 [Tidio](https://www.tidio.com/) 官网注册并且获取 `Public Key`，并将 `Public Key` 填入主题的 `_config.yml` 文件中。 ## [](#修改页脚 &quot;修改页脚&quot;)修改页脚 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814210231.png) 页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 `/layout/_partial/footer.ejs` 文件中，包括站点、使用的主题、访问量等。 ## [](#修改社交链接 &quot;修改社交链接&quot;)修改社交链接 在主题的 `_config.yml` 文件中，默认支持 `QQ`、`GitHub` 和邮箱等的配置，你可以在主题文件的 `/layout/_partial/social-link.ejs` 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： &lt;pre&gt;`&amp;lt;% if (theme.socialLink.github) &#123; %&amp;gt; &amp;lt;a href=&quot;&amp;lt;%= theme.socialLink.github %&amp;gt;&quot; class=&quot;tooltipped&quot; target=&quot;_blank&quot; data-tooltip=&quot;访问我的GitHub&quot; data-position=&quot;top&quot; data-delay=&quot;50&quot;&amp;gt; &amp;lt;i class=&quot;fab fa-github&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;% &#125; %&amp;gt;`&lt;/pre&gt; 其中，社交图标（如：`fa-github`）你可以在 [Font Awesome](https://fontawesome.com/icons) 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fab fa-facebook Twitter: fab fa-twitter Google-plus: fab fa-google-plus Linkedin: fab fa-linkedin Tumblr: fab fa-tumblr Medium: fab fa-medium Slack: fab fa-slack Sina Weibo: fab fa-weibo Wechat: fab fa-weixin QQ: fab fa-qq Zhihu: fab fa-zhihu 注意: 本主题中使用的 Font Awesome 版本为 5.11.0。 修改打赏的二维码图片效果： 在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 配置音乐播放器（可选的）效果： 要支持音乐播放，在主题的 _config.yml 配置文件中激活music配置即可： `# 是否在首页显示音乐 music: enable: true title: # 非吸底模式有效 enable: true show: 听听音乐 server: netease # require music platform: netease, tencent, kugou, xiami, baidu type: playlist # require song, playlist, album, search, artist id: 503838841 # require song id / playlist id / album id / search keyword fixed: false # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠`> `server`可选`netease`（网易云音乐），`tencent`（QQ音乐），`kugou`（酷狗音乐），`xiami`（虾米音乐）， `baidu`（百度音乐）。 `type`可选`song`（歌曲），`playlist`（歌单），`album`（专辑），`search`（搜索关键字），`artist`（歌手） &lt;pre&gt;`id`获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，`playlist`的`id`&lt;/pre&gt; 即为这串数字。 ## [](#文章-Front-matter-介绍 &quot;文章 Front-matter 介绍&quot;)文章 Front-matter 介绍 ### [](#Front-matter-选项详解 &quot;Front-matter 选项详解&quot;)Front-matter 选项详解 `Front-matter` 选项中的所有内容均为**非必填**的。但我仍然建议至少填写 `title` 和 `date` 的值。 &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;配置选项&lt;/th&gt; &lt;th&gt;默认值&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&lt;tr&gt; &lt;td&gt;title&lt;/td&gt; &lt;td&gt;`Markdown` 的文件标题&lt;/td&gt; &lt;td&gt;文章标题，强烈建议填写此选项&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;date&lt;/td&gt; &lt;td&gt;文件创建时的日期时间&lt;/td&gt; &lt;td&gt;发布时间，强烈建议填写此选项，且最好保证全局唯一&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;author&lt;/td&gt; &lt;td&gt;根 `_config.yml` 中的 `author`&lt;/td&gt; &lt;td&gt;文章作者&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;img&lt;/td&gt; &lt;td&gt;`featureImages` 中的某个值&lt;/td&gt; &lt;td&gt;文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: `http://xxx.com/xxx.jpg`&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;top&lt;/td&gt; &lt;td&gt;`true`&lt;/td&gt; &lt;td&gt;推荐文章（文章是否置顶），如果 `top` 值为 `true`，则会作为首页推荐文章&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;cover&lt;/td&gt; &lt;td&gt;`false`&lt;/td&gt; &lt;td&gt;`v1.0.2`版本新增，表示该文章是否需要加入到首页轮播封面中&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;coverImg&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;`v1.0.2`版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;password&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 `password` 的值，该值必须是用 `SHA256` 加密后的密码，防止被他人识破。前提是在主题的 `config.yml` 中激活了 `verifyPassword` 选项&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;toc&lt;/td&gt; &lt;td&gt;`true`&lt;/td&gt; &lt;td&gt;是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 `config.yml` 中激活了 `toc` 选项&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;mathjax&lt;/td&gt; &lt;td&gt;`false`&lt;/td&gt; &lt;td&gt;是否开启数学公式支持 ，本文章是否开启 `mathjax`，且需要在主题的 `_config.yml` 文件中也需要开启才行&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;summary&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;categories&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;tags&lt;/td&gt; &lt;td&gt;无&lt;/td&gt; &lt;td&gt;文章标签，一篇文章可以多个标签&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;keywords&lt;/td&gt; &lt;td&gt;文章标题&lt;/td&gt; &lt;td&gt;文章关键字，SEO 时需要&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;reprintPolicy&lt;/td&gt; &lt;td&gt;cc_by&lt;/td&gt; &lt;td&gt;文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; &gt; **注意**: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 `Front-matter` 示例。 ### [](#最简示例 &quot;最简示例&quot;)最简示例 &lt;pre&gt;`--- title: typora-vue-theme主题介绍 date: 2018-09-07 09:25:00 ---`&lt;/pre&gt; ### [](#最全示例 &quot;最全示例&quot;)最全示例 &lt;pre&gt;`--- title: typora-vue-theme主题介绍 date: 2020-09-07 09:25:00 author: kif img: /source/images/xxx.jpg top: true cover: true coverImg: /images/1.jpg password: 123456 toc: false mathjax: false summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories: Markdown tags: - Typora - Markdown ---`&lt;/pre&gt; ## [](#页尾鱼塘效果美化 &quot;页尾鱼塘效果美化&quot;)页尾鱼塘效果美化 效果： ![1](https://cdn.jsdelivr.net/gh/wkif/ImageHosting/img/20200814204700.gif) 教程：[个人博客搭建：网页页尾鱼塘效果美化](https://kifroom.icu/posts/63210.html) ## [](#修改导航栏颜色以及透明效果 &quot;修改导航栏颜色以及透明效果&quot;)修改导航栏颜色以及透明效果 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814210442.png) 打开`themes/matery/source/css/matery.css`文件，大约在250行，有一个`.bg-color`属性，修改其属性值即可，代码如下： &lt;pre class=&quot;line-numbers language-css&quot;&gt;`&lt;span class=&quot;token selector&quot;&gt;&lt;span class=&quot;token class&quot;&gt;.bg-color&lt;/span&gt; &lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;token property&quot;&gt;background-image&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;linear-gradient&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;to right, &lt;span class=&quot;token hexcode&quot;&gt;#4cbf30&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0%&lt;/span&gt;, &lt;span class=&quot;token hexcode&quot;&gt;#0f9d58&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; //修改成自己喜欢的颜色值 &lt;span class=&quot;token property&quot;&gt;opacity&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0.8&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; //透明效果 值范围 &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;~&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;，看情况自己修改 &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; ## [](#鼠标点击文字特效 &quot;鼠标点击文字特效&quot;)鼠标点击文字特效 实现方法，引入js文件，在主题文件下的`/source/js/`下新建`click_show_text.js`，其代码如下： &lt;pre class=&quot;line-numbers language-javascript&quot;&gt;`&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a_idx &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;document&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;$&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;body&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;e&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;富强&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;民主&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;文明&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;和谐&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;自由&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;平等&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;公正&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;法治&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;爱国&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;敬业&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;诚信&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;友善&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; $i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&amp;lt;span/&gt;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;a_idx&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; a_idx &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a_idx &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;%&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;pageX&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; e&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;pageY&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; $i&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;z-index&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;top&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;left&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;position&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;absolute&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;font-weight&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;bold&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;color&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;#FF0000&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;body&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;$i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; $i&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;animate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;top&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;180&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;opacity&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; $i&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;delay()&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;.buryit&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;removeAttr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;onclick&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; ## [](#添加天气小插件 &quot;添加天气小插件&quot;)添加天气小插件 首先去中国天气官网：[[https://cj.weather.com.cn/plugin/pc，](https://cj.weather.com.cn/plugin/pc，) [配置自己的插件，选择自定义插件—&amp;gt;自定义样式——&amp;gt;生成代码，然后会生成一段代码，复制粘贴到`themes/matery/layout/layout.ejs`即可。 ## [](#关于我页面添加个人简历 &quot;关于我页面添加个人简历&quot;)关于我页面添加个人简历 打开`theme/matery/layout/about.ejs`文件，大约在13行。有一个``标签，找出其对应结尾的标签，大约在61行左右，然后在新增如下代码： &lt;pre class=&quot;line-numbers language-html&quot;&gt;`&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;card&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;card-content&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;card-content article-card-content&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;title center-align&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;data-aos&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;zoom-in-up&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;i&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;fa fa-address-book&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;i&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&amp;nbsp;&quot;&gt;&amp;amp;nbsp;&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;&amp;nbsp;&quot;&gt;&amp;amp;nbsp;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;%-&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;__(&#39;个人简历&#39;)&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;articleContent&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;data-aos&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;fade-up&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;%-&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;page.content&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; 注意粘贴的位置和空格要正确，这里的位置随你自己设置，你也可以把简历作为第一个card，然后`/source/about/index.md`下面写上你的简历了（就像写博客一样）。 ## [](#添加鼠标点击烟花爆炸效果 &quot;添加鼠标点击烟花爆炸效果&quot;)添加鼠标点击烟花爆炸效果 效果： ![2](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814210735.gif) 首先在`themes/matery/source/js`目录下新建`fireworks.js`文件，打开这个网址[传送门](https://links.jianshu.com/go?to=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2Fbaifeng66%2Fcdn%401.1%2Fsource%2Fjs%2Ffireworks.js)，将内容复制粘贴到`fireworks.js`即可。 然后再`themes/matery/layout/layout.ejs`文件内添加下面的内容： &lt;pre class=&quot;line-numbers language-javascript&quot;&gt;`&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;canvas &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fireworks&quot;&lt;/span&gt; style&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;canvas&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;script type&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; src&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;script&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;script type&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; src&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/js/fireworks.js&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;script&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; 然后`hexo clean &amp;amp;&amp;amp; hexo g &amp;amp;&amp;amp; hexo s`即可，就可以看到效果了。 ## [](#添加樱花飘落效果 &quot;添加樱花飘落效果&quot;)添加樱花飘落效果 在`themes/matery/source/js`目录下新建`sakura.js`文件，打开这个网址[传送门](https://links.jianshu.com/go?to=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2Fbaifeng66%2Fcdn%401.1%2Fsource%2Fjs%2Fsakura.js)，将内容复制粘贴到sakura.js即可。 然后再`themes/matery/layout/layout.ejs`文件内添加下面的内容： &lt;pre class=&quot;line-numbers language-javascript&quot;&gt;`&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;script type&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;//只在桌面版网页启用特效&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; windowWidth &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;window&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;windowWidth &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;768&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#123;&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;/js/sakura.js&quot;&gt;&amp;lt;\\/script&gt;&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&#125;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;script&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; ## [](#添加鼠标彩虹星星掉落跟随效果 &quot;添加鼠标彩虹星星掉落跟随效果&quot;)添加鼠标彩虹星星掉落跟随效果 在`themes/matery/source/js`目录下新建`cursor.js`文件，打开这个网址[传送门](https://links.jianshu.com/go?to=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2Fbaifeng66%2Fcdn%401.1%2Fsource%2Fjs%2Fcursor.js)，将内容复制粘贴到cursor.js即可。 然后再`themes/matery/layout/layout.ejs`文件内添加下面的内容： &lt;pre class=&quot;line-numbers language-javascript&quot;&gt;`&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;script src&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/js/cursor.js&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;script&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; ## [](#添加雪花飘落效果 &quot;添加雪花飘落效果&quot;)添加雪花飘落效果 在`themes/matery/source/js`目录下新建`snow.js`文件，打开这个网址[传送门](https://links.jianshu.com/go?to=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2Fbaifeng66%2Fcdn%401.1%2Fsource%2Fjs%2Fsnow.js)，将内容复制粘贴到cursor.js即可。 然后再`themes/matery/layout/layout.ejs`文件内添加下面的内容： &lt;pre class=&quot;line-numbers language-javascript&quot;&gt;`&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;script src&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;/js/snow.js&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;script&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; ## [](#文章生成永久链接 &quot;文章生成永久链接&quot;)文章生成永久链接 主题默认的文章链接配置是 &lt;pre class=&quot;line-numbers language-yaml&quot;&gt;`&lt;span class=&quot;token key atrule&quot;&gt;permalink&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;year/&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;month/&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;day/&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;title&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; 这种生成的链接地址很长，文章版权的链接地址会出现一大串字符编码，一点也不好看。因此需要修改文章生成链接的格式。 **注：设置之后之前的文章评论就没了** 首先再根目录下执行下面的命令： &lt;pre class=&quot;line-numbers language-bash&quot;&gt;`&lt;span class=&quot;token function&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; hexo-abbrlink --save&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; 然后再站点配置文件下添加如下配置： &lt;pre class=&quot;line-numbers language-yaml&quot;&gt;`&lt;span class=&quot;token key atrule&quot;&gt;abbrlink&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token key atrule&quot;&gt;alg&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; crc16 &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;#算法： crc16(default) and crc32&lt;/span&gt; &lt;span class=&quot;token key atrule&quot;&gt;rep&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; hex &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;#进制： dec(default) and hex: dec #输出进制：十进制和十六进制，默认为10进制。丨dec为十进制，hex为十六进制&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; 再将站点配置文件的`permalink`的值修改为： &lt;pre class=&quot;line-numbers language-yaml&quot;&gt;`&lt;span class=&quot;token key atrule&quot;&gt;permalink&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; posts/&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;abbrlink.html &lt;span class=&quot;token comment&quot; spellcheck=&quot;true&quot;&gt;# 此处可以自己设置，也可以直接使用 :/abbrlink&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;`&lt;/pre&gt; 生成完后，原md文件的Front-matter 内会增加`abbrlink` 字段，值为生成的ID 。这个字段确保了在我们修改了`Front-matter` 内的博客标题title或创建日期date字段之后而不会改变链接地址。 ## [](#添加Live2d看板娘 &quot;添加Live2d看板娘&quot;)添加Live2d看板娘 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814211201.png) 插件：hexo-helper-live2d github仓库：[https://github.com/EYHN/hexo-helper-live2d](https://github.com/EYHN/hexo-helper-live2d)** ### [](#1-安装插件 &quot;1.安装插件&quot;)1.安装插件 运行命令`npm install --save hexo-helper-live2d` ### [](#2-选择模型 &quot;2.选择模型&quot;)2.选择模型 **可到 [https://huaji8.top/post/live2d-plugin-2.0/](https://huaji8.top/post/live2d-plugin-2.0/) 预览效果。** **命令为:`npm install live2d-widget-model-模型名`，模型为可参考上面的预览内容。** ### [](#3-配置 &quot;3.配置&quot;)3.配置 站点更目录的配置文件`_config.yml`或者是主题的配置文件中添加： &lt;pre&gt;`# Live2D ## https://github.com/EYHN/hexo-helper-live2d live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-tororo # 模型：https://huaji8.top/post/live2d-plugin-2.0/ display: position: left width: 150 height: 350 mobile: show: true admin: deployCommand: &#39;hexo-pubish.bat&#39;`&lt;/pre&gt; **_注意这里的use参数是上面安装的那个模型全名_** ### [](#取消看板娘 &quot;取消看板娘&quot;)取消看板娘 将配置中的`enable`设置成`false`即可。 ### [](#卸载插件 &quot;卸载插件&quot;)卸载插件 运行命令下载插件，删除配置信息： 1.卸载模型：npm uninstall live2d-widget-model-模型名 2.卸载live2d插件：npm uninstall hexo-helper-live2d 3.去掉站点_config.yml下的配置信息即可。 ## [](#添加实时发布说说页面（Artitalk） &quot;添加实时发布说说页面（Artitalk）&quot;)添加实时发布说说页面（Artitalk） 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814212059.png) 教程： ## [](#自定义不使用主题模板渲染的独立页面 &quot;自定义不使用主题模板渲染的独立页面&quot;)自定义不使用主题模板渲染的独立页面 效果： ![](https://gitee.com/wkkif/PicGoimg/raw/master/img/20200814212511.png) 用途：加入一些不用主题的页面，如404页面，新建一个导航页，具有自己独立的样式，可以放一些自己的作品，相册什么的，以下就介绍这种独立页面的实现方法。 使用 Hexo 提供的跳过渲染配置，在博客根目录的配置文件 `_config.yml` 里找到 `skip_render` 关键字，在后面添加想要跳过渲染的页面，比如我们创建 `\\source\\about\\index.html`， 配置文件填写：`skip_render: about\\**`，那么就表示 `\\source\\about` 里所有的文件将跳过渲染，里面的文件将会被直接复制到 public 文件夹，此时就会得到一个独立的 about 页面；官方文档：[https://hexo.io/docs/configuration](https://hexo.io/docs/configuration) 如： &lt;pre&gt;`# 屏蔽渲染 skip_render: - &quot;404.md&quot; - &quot;Nobaidu/**&quot; 这里面对404.html页面屏蔽渲染，对Nobaidu文件夹下的html文件屏蔽渲染 参考文章： hexo-theme-matery 【Hexo】Hexo 主题 Matery 配置 Hexo+yilia添加Live2d看板娘"},{"title":"Win好软推荐","path":"posts/3a62.html","text":"这期推荐一些个人在电脑使用中用到的提高工作（游戏）效率的好软件 前排提醒：所有软件资源均来自网络。 关闭Win自带definderwindows 10中自带杀毒软件Windows Defender，但是对于下面分向的大多是第三方软件，自带的杀毒软件往往会删掉软件，使用者或者不喜欢安装杀毒软件的用户怎么关闭它成为了难题，这篇文章会告诉你如何临时关闭windows defender或者永久关闭它。 1.选择“开始”按钮 ，然后选择“设置” &gt;“更新和安全” &gt;“Windows 安全中心”。打开了Windows Defender操作界面，依次打开“病毒和威胁防护”-“病毒和威胁防护设置” 2.在“病毒和威胁防护”设置界面，关闭“实时保护”，关闭“云提供的保护”，关闭“自动提交样本”这三项。 如果按钮是灰色无法修改，那么可能你的第三方软件已通过其他方式为您已经关闭了。 之后可以安装火绒等管家替代definder管理电脑。 解压工具解压工具是用来解压压缩包， 压力太大不适合用这个，建议去捏方便面 Winrar[WinRAR]是一款强大的压缩文件管理器，它提供了RAR和ZIP文件的完整支持，能解压ARJ、CAB、LZH、ACE、TAR、GZ、UUE、BZ2、JAR、ISO格式文件。 下面的大部分软件会用Zip压缩包的形式分享，所以下载下挺方便的 下载链接： https://wws.lanzous.com/iYmNvfjqeqf 使用自带解压工具解压教程： https://jingyan.baidu.com/article/a378c960d0cb10b328283002.html 下载解压后会得到一下文件 双击打开EXE后缀文件即可运行 之后解压压缩包会自动使用此软件 去广告弹窗广告火绒去除电脑弹窗广告首选 火绒 呀！ 下载链接 点击下载安装，免费版在弹窗拦截方面已经很厉害了， 打开方式： 对于没有自动识别的弹窗也可以使用截图拦截功能，在弹窗出现的时候，使用此功能选择弹窗，对其拦截！ 之后就再也不担心突然弹出令人尴尬的广告了。 浏览器广告这里推荐浏览器使用 电脑自带的 Microsoft Edge或者 谷歌浏览器（Chrome），火狐浏览器（Firefox） 这三款浏览器比较简约，其余360 UC浏览器之类的都是用的他们的浏览器内核，是对这几个浏览器的包装，而且这三款浏览器可以安装一款神器—游猴插件 游猴里面的好多插件可以使电脑拥有好多功能，例如破解付费vip视屏，去广告，这部分在后面再提。 这里给大家推荐的软件是 ADGUARD作为号称是世界上最高级的广告拦截程序！Adguard Premium 是摆脱恼人广告，在线跟踪，保护您远离恶意软件的最佳方式。AdGuard 使您网络冲浪更快速，更安全，更安逸！ AdGuard for Windows PC版 不只是一款广告拦截软件，它还组合了可获取最佳网络体验所需功能的多用途工具。其可拦截广告和危险网站，加速网页载入，保护儿童的在线安全。轻松阻挡 (比“隐藏过滤”更高效更彻底) 广告、减少页面加载时间、富媒体或其他非标准类型的广告，在对网页垃圾信息进行屏蔽后可加快页面载入速度。同时 Adguard 还支持反钓鱼并对反恶意软件以及网站进行过滤。 官方网站 购买价格： 网络下载链接 使用教程： 下载后解压在一固定目录下,此软件是免安装版，所以删除后就不能用了哦。 解压打开后会有如下文件 双击打开AdguardPortable.exe 启用保护 打开设置 安装浏览器助手就可以在浏览器里除掉广告了 打开浏览器就可以在右上角看到这个图标 电脑管家提到电脑管家，可能大家首先想到360电脑管家或者腾讯的，但在使用中大家会发现当下载360电脑管家之后过几天你就拥有了360浏览器，360解压等等360全家桶，这种捆绑式很让人头疼，甚至于卸载都卸载不干净。这里给大家推荐两款专业的软件。 wisecare 365官网 网络资源 https://wws.lanzous.com/iLVDRfjjjqd 激活教程 解压之后会得到如下文件 注册信息txt里面提供了一些激活码 当现实未激活时，可以用这些激活码激活 软件提供了很多功能 其中 计划任务可以定时清理电脑垃圾 Ccleaner官网：https://www.ccleaner.com/ccleaner CCleaner pro 是由英国 Piriform 工作室开发的最著名，且广受好评的系统清理优化及隐私保护软件，也是该工作室的主打和首发产品，支持自定义清理规则，增强了应用程序清理范围和效果。可以有效清除各种系统垃圾文件及应用程序垃圾，同时具备系统优化功能，可以对临时文件夹、历史记录、注册表冗余条目等进行垃圾清理，附带启动项管理、软件卸载功能。不含任何间谍软件和垃圾程序。支持包括简体中文在内的31国语言界面! CCleaner pro 是一款免费的系统优化和隐私保护工具。主要用来清除Windows系统不再使用的垃圾文件，以腾出更多硬盘空间。它的另一大功能是清除使用者的上网记录。 感谢th_sjy大神的修改和分享，特点如下： 去除了无用文件、语言文件夹，去除了版本检测、自动更新，去除了许可证验证，集成了许可证文件无需注册运行即为专业版。不再卡顿、不再提示新版本更新、许可证永久有效。 此破解版绿色原生便携，配置信息不写注册表！ 技术员增强版和专业增强版相比，技术员增强版清理功能更多，而且多了很多自定义选项。 Professional 为专业版、Business 为商业版、Technician 为技术员版。 网络资源 浏览器这部分前面也提到了 推荐浏览器使用 电脑自带的 Microsoft Edge或者 谷歌浏览器（Chrome），火狐浏览器（Firefox） 谷歌浏览器（Chrome）下载：https://www.google.cn/chrome/index.html 浏览器除了前面提到的游猴以外，还可以安装很多扩展程序，下载扩展程序可以到chrome网上应用店 打开方法： chrome网上应用店网址：https://chrome.google.com/webstore/category/extensions?hl=zh-CN 下面给大家推荐一些扩展程序： 1.AdGuard浏览器助手Beta 1.0.13计划这个就是前面ADGUARD的插件 2.哔哩哔哩助手: bilibili.com 综合辅助扩展1.2.21下载：哔哩哔哩助手 点击添加到Chrome即可 功能： 点击浏览器右上角图标即可设置 3.Momentum 1.17. 41下载：Momentum 1.17. 41 功能： 大家新标签页时显示更美观的标签页 音乐下载全网付费音乐免费下载软件，前排提醒，低调使用 MusicTools下载地址 搜索后可免费下载 软件设置里设置下载目录，下载的歌曲会存在目录下 护眼软件FluxPortable 4.118 f.lux是款功能简单实用的电脑护眼神器，这款软件非常的小巧，是您眼睛的健康专家，使您的眼睛受到的辐射减少，软件主要的功能就是为了帮助用户快速的调节您的电脑显示屏的亮度，而且换是根据室内的光线来进行快速的调节，使您的眼睛一直处于舒服的状态等，当然我还是推荐Iris护眼神器，大家可以在网站搜索获取这个软件 网络资源：https://wws.lanzous.com/iVus0fjlcxa 解压后会得到如下文件 双击打开FluxPortable.exe PDF文件浏览器PDFelement一款功能强大的pdf阅读器，解锁多种功能，方便电脑打开教材文件学习 网络资源：https://cloud.189.cn/t/iAnmQ3jI7nyu 免安装版本，下载之后打开exe文件即可 工具集utools强烈安利！！集成了好多工具，方便使用 uTools是一个极简、插件化、跨平台的现代化桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。 通过快捷键（默认alt+space）就可以快速呼出这个搜索框。它相当聪明，可以支持输入、拖拽、自动粘贴等作为输入源，相应的插件也早已准备就绪，统一的设计风格和操作方式，助你高效的得到结果。 当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。 官网：https://u.tools/ 使用方法： 使用快捷键 ALT + 空格键快速打开，在输入框里输入小工具名 如“剪贴板” ，按enter打开 点击右边图标可以打开主面板，可以安装插件工具 本地文件搜索软件everthing下载链接：https://www.voidtools.com/zh-cn/ 当我们要找某一个文件却忘记放到哪儿的时候，一般会使用自带的搜索工具（当然上个Utools也有搜索的功能，可以选择那个） 但这个方法搜索速度非常慢 Everthing搜索： 明显速度快了好多。 哔哩哔哩哔哩uwp是第三方开发者开发的哔哩哔哩玩的uwp应用，界面个人感觉很清新，功能也相对完整，之前一般都是在浏览器上看，现在用上这个uwp感觉还可以 下载：https://wws.lanzous.com/i5QcXeehm7e 使用： 下载后会得到以下文件 打开 60520B029E250.4264454043325_1.3.8.0_x64__5aa7k9th7aafp.appx 就可以开始安装 设置里面可以切换模式，提供了两种模式"},{"title":"个人博客搭建（3）:Typora+PicGo+Github/Gitee搭建免费稳定的图床","path":"posts/8bd5.html","text":"PicGo一个用于快速上传图片并获取图片URL链接的工具 PicGo官网：PicGo下载：仓库地址按照官方安装方法安装 注：在安装的时候安装目录千万不能选C:\\Program Files\\下的任何地方，因为PicGo无法解析这一路径，如果你不知道安装在哪里的话，选择仅为我安装，否则在设置Typora时会出现错误： Github仓库图床新建Public Github仓库创建Repository点击”New repository”按钮，仓库名字随意 新生成一个Personal access tokens生成一个Token用于操作GitHub repositorySettings --&amp;gt; Developer Settings --&amp;gt; Personal access tokens ![Personal access tokens&#96;](https://cdn.jsdelivr.net/gh/wkif/ImageHosting/kif_img&#x2F;20200721123456.png) 生成Token 会生成如上图的一串token，这串token之后不会再显示，所以第一次看到的时候，可以建个文本文件保存，忘记了只有重新生成，每次都不一样。 PicGo配置配置Github图床填写说明 仓库名：按照“账户名&#x2F;仓库名的格式填写”，比如我的是wkif&#x2F;ImageHosting 分支名：填写masterTOKEN：Token粘贴在这里路径：可留空，如需自己填写记得末尾加上&#x2F;设定自定义域名：自定义域名的作用是在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上，这里我用到了jsdeliver 的免费CDN加速，自定义域名需要按照这样去填写：https://cdn.jsdelivr.net/账户名/仓库名/master，比如我的是：https://cdn.jsdelivr.net/gh/wkif/ImageHosting Typora配置PicGo下载Typora下载地址 配置 验证设置是否正确 错误解决错误1： failed to launch PicGo app: Command failed: C:\\Program Files\\PicGo\\PicGo.exe &#39;C:\\Program&#39; �����ڲ����ⲿ���Ҳ���ǿ����еĳ��� ���������ļ��� 前面提到的安装的问题，不要放在c盘下 错误2： &#96; Failed to fetch &#96; way: gitee的后续在写吧！"},{"title":"vs code 开发微信小程序","path":"posts/f738.html","text":"这里推荐大家使用号称“宇宙第一IDE”的编辑器——vscode。安装方法看博客上一篇文章，主要介绍一下几个vscode插件，在vscode中搜索插件关键字点击安装即可。 小程序助手让vscode 提供对 .wxss .wxml 文件后缀的支持 minapp支持微信小程序标签、属性的智能补全，并且提示中包含文档内容（同时支持原生小程序、mpvue 和 wepy 框架，并提供 snippets）。 wechat-snippet这个插件主要的功能就是代码辅助，代码片段自动完成，可以作为上个插件的补充。 wxml这款插件用于将wxml代码进行高亮显示，并且提供代码格式化的功能，可将代码格式化为较易阅读的样式。 vscode wxml提供微信小程序代码的提示对wxml文件进行格式化 wechat-snippet 有了上面这几款插件，便可以开始高效地撸代码了。至于代码的调试以及效果的查看，当然还是得打开微信开发者工具。将编辑器隐藏，调试工具调到最大，快速找到元素的位置，修改样式，Ctrl+S，提交代码，一顿操作猛如虎。 下面这是我的界面，可以把微信开发程序仅打开模拟器，放在右边，左边用vscode写好代码后，鼠标点击到 右边，ctrl+r刷新就可以看到效果了。"},{"title":"shmily","path":"posts/984a.html","text":"shmilySometimes some little things can teach us a lot. My grandparents were married for over half a century, and played their own special game from the time they had met each other. The goal of their game was to write the word”shmily”in a surprise place for the other to find. They took turns leaving”shmily”around the house, and as soon as one of them discovered it, it was their turn to hide it once more. They dragged”shmily”with their fingers through the sugar and flour containers to await whoever was preparing the next meal. They smeared it in the dew on the windows overlooking the patio where my grandma always fed us warm, homemade pudding with blue food coloring.”Shmily”was written in the steam left on the mirror after a hot shower, where it would reappear bath after bath. At one point, mygrandmothereven unrolled an entire roll of toilet paper to leave”shmily”on the very last sheet. There was no end to the places”shmily”would pop up. Little notes with”shmily”scribbled hurriedly were found on dashboards and car seats, or taped to steering wheels. The notes were stuffed inside shoes and left under pillows.”Shmily”was written in the dust upon the mantel and traced in the ashes of thefireplace. Thismysteriousword was as much a part of my grandparents’house as the furniture. It took me a long time before I was able to fullyappreciatemy grand-parents’game.Skepticismhas kept me from believing in true love-one that is pure and enduring. However, I never doubted my grandparents’relationship. They had love down pat.It was more than their flirtatious little games; it was a way of life. Their relationship was based on a devotion andpassionateaffectionwhich not everyone is lucky to experience. Grandma and Grandpa hold hands every chance they could. They stole kisses as they bumped into each other in their tiny kitchen. They finished each other’s sentences and shared the dailycrosswordpuzzle and word jumble.. My grandma whispered to me about how cute my grandpa was, how handsome and old he had grown to be. She claimed that she really knew”how to pick’em.”Before every meal they bowed their heads and gave thanks, marveling at theirblessings: a wonderful family, good fortune, and each other. But there was a dark cloud in my grandparents’life: my grandmother had breast cancer. The disease had first appeared ten years earlier. As always, Grandpa was with her every step of the way. He comforted her in their yellow room, painted that way so that she could always be surrounded by sunshine, even when she was too sick to go outside. Now the cancer was again attacking her body. With the help of a cane and my grandfather’s steady hand, they went to church every morning. But my grandmother grew steadily weaker until, finally, she could not leave the house anymore. For a while, Grandpa would go to church alone, praying to God to watch over his wife. Then one day, what we all dreaded finally happened. Grandma was gone.”Shmily.”It was scrawled in yellow on the pink ribbons of my grandmother’s funeral bouquet. As the crowd thinned and the last mourners turned to leave, my aunts, uncles, cousins and other family members came forward and gathered around Grandma one last time. Grandpa stepped up to my grandmother’s casket and, taking a shaky breath and then he began to sing to her. Through his tears , the song came, deep and slow. Thank you，grandpa and grandma，for letting me see. S-h-m-i-l-y: See How Much I Love You. By Laura Jeanne Allen 知道我有多爱你我的祖父和祖母结婚已逾半个世纪，然而多少年来，他们彼此间不倦地玩着一个特殊的游戏：在一个意想不到的地方写下“Shmily”这个词留待对方来发现。他们轮换着在屋前房后留下“Shmily”，一经对方发现，就开始新的一轮。 他们用手指在糖罐和面箱里写下“Shmily”，等着准备下一餐饭的对方来发现；他们在覆着霜花的玻璃上写下“Shmily”；一次又一次的热水澡后，总可以看见雾气蒙罩的镜子上留下的“Shmily”。 有时，祖母甚至会重卷一整卷卫生纸，只为了在最后一片纸上写下“Shmily”。 没有“Shmily”不可能出现的地方。仓促间涂写的“Shmily”会出现在汽车坐垫上，或是一张贴在方向盘轴心的小纸条上。这一类的字条会被塞进鞋子里或是压在枕下。 “Shmily”会被书写在壁炉台面的薄尘上，或是勾画在炉内的灰底上。这个神秘的词，像祖父母的家具一样成了他们房间的一部分。 直到很久以后，我才能完全理解祖父母之间游戏的意义。年轻时我不懂得爱——那种纯洁且历久弥坚的爱。然而，我从未怀疑过祖父母之间的感情。他们彼此深爱。他们的小游戏已远非调情消遣，那是一种生活方式。他们之间的感情是基于一种深挚的爱和献身精神，不是每一个人都能体验到的。 祖父和祖母一有机会就彼此执手相握。他们在小厨房里错身而过时偷吻；他们说完彼此的半截句子；他们一起玩拼字和字谜游戏。祖母常忘情地对我耳语祖父有多可爱迷人，依然还是那么帅气。她骄傲地宣称自己的确懂得“如何选择”。每次餐前他们垂首祈祷时，感谢他们受到的诸多福佑：一个幸福的家庭、好运道和拥有彼此。 可是一片乌去遮蔽了祖父母的家：祖母的癌恶化了。首次发现是在10年前。跟以往一样，祖父总是跟祖母肩并肩地走过人生艰难之旅的每一步。为了安慰祖母，祖父将他们的卧房喷涂成黄色，这样在祖母病重不能出屋时，亦能感到周围的阳光。 起先，在祖父坚实的手臂和拐杖的帮扶下，他们每天清晨一起去教堂散步和默祷。但随着祖母日见虚弱，终于，祖父只能独自去教堂，祈求上帝看顾他的妻子。 然而那一天，我们担心忧惧的事终于还是发生了，祖母去世了。 “Shmily”写在祖母葬礼上花束的黄色缎带上。当人群散去，叔伯、姑姑和其他的家庭成员又走上前来最后一次围聚在祖母身旁。祖父步向祖母的灵柩，用颤抖的声音轻轻的唱起“知道我有多么爱你……”透过悲伤的泪，这歌声低沉轻柔地飘入耳来……我终于明白了他们特殊小游戏的意义“S— h— m— I— l— y”：“See how much I love you（知道我多么爱你）”。 因悲伤而颤栗着，我永远无法忘记那一刻.谢谢你们，祖父祖母，是你们让我懂得了什么是爱 。来自：https://baike.baidu.com/item/shmily/130197"},{"title":"vs code下载安装","path":"posts/4812.html","text":"本文介绍Win上安装vs code方法 首先下载vscode安装软件下载链接 选择vscode版本（根据自己的操作系统选择相应的版本） 傻瓜式安装，一直下一步，直接到完成 环境变量（这步骤也是默认的，因为改编辑器是微软提供的，会自动配置path） 安装成功（到此步骤已经安装成功了，下面的部署式配置VSCode和简单的使用） 将默认英文改成中文步骤１.Ctrl+Shift+P打开搜索框输入Configure Display Language命令 修改完成之后，CTRL＋Ｓ保存 步骤２：要查找的语言在“扩展”视图（Ctrl + Shift + X）中搜索语言包步骤３：重启vscode就可以了，重启之后，就变成中文版"},{"title":"个人博客搭建（2）:配置gitalk评论","path":"posts/7a4f.html","text":""},{"title":"总会有人陪你奇奇怪怪","path":"posts/d474.html","text":"讲起爱情，其实爱情刚开始都是你情我愿，是共喝一杯奶茶都觉得很甜，是说不完的话，也是聊不完的天。 渐渐地，就算是特意为对方准备了惊喜，也从对方眼睛里明显看到没有了期待。我们开始怀疑，难道爱情里的耐心也有保质期。 时间一到，联系变成负担，关心变成干扰，就连一举一动，都透着我在等着你回报的意味。 也许都市人繁忙的生活，简短的爱情就像电影《他其实没那么喜欢你》说的那样： 有手机、有快速拨号、甚至有语音拨号，有时压根没想打电话，电话就从裤兜里拨出去了，为什么没有时间打电话。 如果真的喜欢你就不会忘记，如果忘记说明他不在乎你失望。 “忙”就是恋爱上的大规模杀伤性武器，是“混蛋”的同义词，混蛋就是用忙敷衍你的那个人。 或许我们可以活在聊天记录营造的美好里，活在他还爱我只是他太忙了的想象里，但是这个仅由自己一己之力撑起来的美梦，一戳就破。 就像以前看失恋三十三天的时候，记得《失恋33天》里面有一句台词我很喜欢： 感谢命运让我们这样结束，不用对我觉得抱歉，我不稀罕你的抱歉，我不稀罕你说的亏欠，我要的就是这样对等的关系。 一段感情里，在起点时我们彼此相爱，到结尾时，互为仇敌，你不仁我不义。我要你知道，我们始终势均力敌。 成年人的感情，进退都应该把握分寸。 如果余生你不主动找我，我这辈子都不会再与你有交集。 但只要你与我说话，我看见了一定秒回，或者你说想见我，就算是刀山火海也要以最快的速度出现在你的面前。 所以，承认吧，我们要的并不是聊天记录维持的爱情。 承认我们都做到了爱对方这件事，却终究没能做好陪对方一起走下去的准备。 就像如今的网恋可以讲是当下流行的一种社交吧。无论是青春懵懂的学生，还是已经踏足社会的成年人，都会接触到网恋一词。 喜怒哀乐都只能透过手机传达，我感觉欠缺一种爱情里的实在，有时候挂住对方如果透过手机来表达总比见一面欠点真情流露。网恋我支持但思念还是要靠见面。被惦记是幸福的所以想念就要去见对方。 就像前些日子，在网上看到一个特别温馨的小故事： 楼道有一则广告，广告词写着“太阳能维修”，下面有人用笔接了一句：“月亮可更换”。 路过的女生觉得这句话可爱，便把它分享给了喜欢的男孩，没想到男孩很快回复她：“星星不闪包退换”。 那一刻，我好像忽然明白了一个道理：人这一辈子，遇到爱遇到性都不稀罕，稀罕的是遇到了解。 就好像比起穿得漂不漂亮，他更在意你穿得舒不舒服；比起一昧追问你的情绪低落缘由，他会轻轻牵起你的手，虽然我不知道怎么回事，但我想先带你去吃饭，我会陪着你。 毕竟每个灵魂与生俱来都是孤独的，可总会遇到另一个能与之发生共鸣的灵魂，然后在尘世间相互慰藉。 这时候，你就会觉得，人间真的好值得。还记得在最近看的一档综艺节目里，重新解锁了当年偶像吴尊的另一面。 现实生活里，他幼稚又爱碎碎念，就连他的妻子林丽莹都吐槽说，你可以娘，但不要那么啰嗦。 后来这句话成为吴尊好友们调侃他的金句，他也不生气，还借此来打趣逗乐林丽莹。 生活平淡，其实真的没有那么多惊天动地的惊喜轮番上演，更多的时候，是对方为你做的一点点努力，堆积起来，换取命运手里的巧克力，带给你甜蜜和欢愉。 人这一辈子，会说很多很多的话，也会做很多很多的事，能遇到一个对你事事有回应，件件有着落的人，却不容易。 这样的人，他懂你的奇奇怪怪，也愿意陪你可可爱爱，愿你我都能遇到这样的人。 在这七月临近的日子，希望会遇见一个懂你的人，懂你的快乐和忧伤，懂你的心酸和无奈，能懂你的累，懂你的苦，懂你的倔强，也懂你的坚持。 不言不语，不是不说，只是不想说，无声无息，不是无心，只是没人懂。真正喜欢你的人不一定是最懂你的人，但他一定是最愿意去懂你的人。往后余生，找一个懂你的人，知你悲欢，解你忧愁。"},{"title":"C语言思维导图","path":"posts/4553.html","text":"注：转自：hirak0"},{"title":"Win 上安装Git和node.js","path":"posts/c402.html","text":"本文介绍Win上安装Gitd 和node.js方法个人安装的环境：（快速安装基本简单；下一步默认其实也可以；看图就懂） Windows10 64bit Git 2.13.0(下载 git网址 ： https://git-scm.com/download） 安装步骤安装https://cdn.jsdelivr.net/gh/wkif/CDN/img/git/1.png 路径选择 选择安装组件当然建议全选哈 组件 创建菜单文件夹 修改系统的环境变量 选择SSL的证书 https：（全称：Hyper Text Transfer Protocol over Secure Socket Layer）简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。 配置行尾结束符 配置终端仿真 大多数其他Cygwin&#x2F;MSYS终端一样，MinTTY也是基于pseudo终端(“pty”)设备的。但是MinTTY并不能完全替代windows的命令提示符。windows上自带简单的文本输出的原生态的命令提示符通常可以很好的工作，但交互性更好的诸如MinTTY这样的应用程序却可能出现故障——虽然通常都有应对方案。这就是为什么MinTTY不能完全替代windows自带的命令提示符 其他的配置–默认即可 等待安装测试 后续如果中文没有正常显示，请求鼠标右击选择“option”选项，更换语言即可中文 转自：作者：weir_will链接：https://www.jianshu.com/p/414ccd423efc来源：简书 node.js下载链接：https://nodejs.org/en/安装步骤：一路默认就行（安装路径根据自己需要更改） 验证软件正确安装同时按下Win键和R键（或者点击“开始菜单”-&gt;点击“运行”）,打开运行窗口,输入“cmd”然后输入以下命令，结果与下图相同则说明安装正确，若不正确可以卸载软件重新安装 git --version node -v npm -v"},{"title":"玩机汇总（一）：刷机常识，双清，BL，REC，TWRP","path":"posts/25c1.html","text":"本文介绍手机刷机常识，双清，BL，REC，TWRP 前排提示：本文转载自一加社区：http://www.oneplusbbs.com/thread-3851619-1-1.html 对于刷机里面一些概念的理解首先，小白们的手机出了问题，论坛里的大佬们提出了解决方法，小白们却还是不会操作，根目录是什么呢，双清又是啥？下面我就对一些操作做一些简单的解释： BL锁BL锁就是bootloader锁，BL从安卓问世以来一直存在，它的功能在我看来应该是限制用户刷第三方ROM和降级系统。在锁住bl的情况下，用户是根本不可能刷第三方ROM和第三方recovery的，最多也就是刷个基于官方的精简包。bl还有一个恶心的限制就是root，所有要root的机器，都必须解锁才能获取。那有人就问了，为什么以前的老机器和安卓4点几的机子都可以一键root呢，这是因为以前的机器bl锁等级低，我们可以利用bl锁的漏洞，绕过bl解锁。然而现在的系统BL等级比较高，自然就无法绕过BL锁去root了。 RECREC是Recovery的缩写，是每部安卓机出厂时自带的恢复模式，不过那都是官方的Recovery。Recovery就是像是电脑上的小型winPE系统，winPE可以在电脑上安装操作系统，或者做些备份、管理的工作。如果把手机比喻成房屋，那么地皮就像手机的硬件，房子像手机系统，建房子的各种工具就是就是Recovery了。官方Recovery只能用来刷入官方的系统，如果你想刷入别的系统，只能通过第三方Recovery来实现，但是，你平时所用到的在线升级也就是OTA升级，是基于官方Rec的，如果你刷入了第三方Rec，OTA升级就会失败。 TWRPTWRP是国外android爱好者开发的一个第三方REC，全名是：TeamWin Recovery Project，也是我们现在刷第三方ROM通常用到的REC。 双清` wipe data/factory reset：清除用户数据并恢复出厂设置 wipecache partition：清除系统缓存 ， 一般刷机前执行，具体看资源发布者的要求。` 三清` wipe data/factory reset：清除用户数据并恢复出厂设置 wipe cache partition：清除系统缓存 wipe dalvik cache：清除安卓虚拟机缓存 具体看资源发布者的要求。 ## [](#四清 \"四清\")四清 wipe data/factory reset：清除用户数据并恢复出厂设置 wipe cache partition：清除系统缓存 wipe dalvik cache：清除安卓虚拟机缓存 wipe system：清除系统 该操作可以更干净地刷入新系统，但并不建议也尽量不要四清，具体看资源发布者的要求。 在这里我要说一下，很多人会觉得四清五清等多清会让刷入的系统更干净，其实这是一种误区，这样子很容易引起手机卡信号基带异常，例如电信卡无法出现4G+等情况出现，内存卡异常等问题，很多人说刷机过后信号没了，就是刷机多清的问题，除了首次刷机需要格式化内存卡，刷回官方固件的时候会自动清卡以外，其他时候完全没必要多清。 System这个分区基本包含了整个安卓操作系统，包括安卓用户界面、和所有预装的系统应用程序。擦除这个分区，会删除整个安卓系统，但不会导致不能启动。你可以通过进入Recovery程序，安装一个新ROM，也就是新的安卓系统。双清三清四清会清空个人的用户数据包括 ：应用程序、短信信息、联系人、通讯录、应用数据等等…，但不会清空内置卡如 图片、音乐、个人文件等等（此话来源于DK大佬……懒得打直接复制了）。 ## [](#根目录 \"根目录 \")根目录 楼主想了一下，觉得有必要为小白们科普一下什么是根目录。根目录指逻辑驱动器的最上一级目录，它是相对子目录来说的。点开手机内部储存看到的就是手机的根目录，同理，在电脑上也是一样，打开“我的电脑”，双击C盘就进入C盘的根目录，双击D盘就进入D盘的根目录，点开游戏文件夹看到的就是游戏的根目录。 # [](#刷机过程和图文操作详解 \"刷机过程和图文操作详解\")刷机过程和图文操作详解 ## [](#如何在无需解BL锁不ROOT的情况下刷官方系统？ \"如何在无需解BL锁不ROOT的情况下刷官方系统？\")如何在无需解BL锁不ROOT的情况下刷官方系统？ 直接官方REC刷入官方ROM（全量包）：把官方刷机包放到手机根目录，进入设置-系统升级，点一下系统升级右上角的齿轮。选择本地升级，选择你刚才放入的官方刷机包，就跟平时升级一样的，不过降级建议恢复出厂设置。 ## [](#如何ROOT以及刷入第三方系统？ \"如何ROOT以及刷入第三方系统？\")如何ROOT以及刷入第三方系统？ 这两种操作的前提都是解BL锁和刷入第三方REC：TWRP。 第一次ROOT和刷机需要电脑，看到这里，如果你的手机没有解过BL锁而且身边没有电脑，那么你现在可以暂时放弃学习这篇帖子了。 ROOT：（第一次的话解BL锁→刷入第三方REC：TWRP，以后不用进行此操作）→把ROOT包放在手机根目录，长按音量减和电源键，进入REC（recovery mode）,也就是TWRP界面安装ROOT包。（注意，安卓8.0系统的ROOT包只能选Magisk。) 最常见的ROOT包有两种：supersu和Magisk。 如果想卸载，直接卡刷卸载包 刷入第三方系统：（第一次的话解BL锁→刷入第三方REC：TWRP，以后不用进行此操作）→把系统ROM包放在手机根目录，长按音量减和电源键，进入REC（recovery mode）,也就是TWRP界面，安装下载的系统ROM。"},{"title":"玩机汇总（三）：刷入第三方rec 与magisk、Edx安装","path":"posts/6255.html","text":"本文介绍手机第三方rec刷入和magisk、Edxp的安装有变砖风险。玩机有风险，搞机需谨慎。 前言什么是第三方rec？Recovery模式指的是一种可以对安卓机内部的数据或系统进行修改的模式（类似于windows PE或DOS）。在这个模式下我们可以刷入新的安卓系统，或者对已有的系统进行备份或升级，也可以在此恢复出厂设置，按类型分为官方的rec和第三方rec（CWM REC和TWRP REC。REC是Recovery的缩写，是每部安卓机出厂时自带的恢复模式，不过那都是官方的Recovery。官方Recovery只能用来刷入官方的系统，如小米rec 如果你想刷入别的系统，只能通过第三方Recovery来实现，但是，你平时所用到的在线升级也就是OTA升级，是基于官方Rec的，如果你刷入了第三方Rec，OTA升级就会失败。 TWRPTWRP是国外android爱好者开发的一个第三方REC，全名是：TeamWin Recovery Project，也是我们现在刷第三方ROM通常用到的REC。twrp官网 此教程是线刷rec教程 什么是magisk？官网：https://magiskmanager.com/ Magisk 是出自一位台湾学生 @topjohnwu 开发的 Android 框架，是一个通用的第三方 systemless 接口，通过这样的方式实现一些较强大的功能。看似很简单的一个框架，甚至与大名鼎鼎的 Xposed 框架在功能性上有点重复。很多人批评 Magisk的模块太少了，想替代 Xposed 根本不可能（在那个 Xposed Framework for Android 7.0 难产的时代，很多人将 Magisk 看是做是 Xposed 的替代品）。这是不正确的，因为 Magisk 从来没有想过要代替 Xposed ，Magisk 与 Xposed 是可以互相兼容的，你甚至可以通过 Magisk 来安装 Xposed（安装 Xposed 后就不能绕过 SafetyNet 了）。 Magisk 的厉害之处在于它实现了一种绕过 SafetyNet 使用 root 的方法。 实现原理：由于它是通过启动时在 boot 中创建钩子，把 &#x2F;data&#x2F;magisk.img 挂载到 &#x2F;magisk，构建出一个在 system 基础上能够自定义替换，增加以及删除的文件系统，所有操作都在启动的时候完成，实际上并没有对 &#x2F;system 分区进行修改（即 systemless 接口，以不触动 &#x2F;system 的方式修改 &#x2F;system）。 转自：作者：Mogeko丶链接：https://www.jianshu.com/p/393f5e51716e来源：简书 3.什么是Edxp?官网：https://github.com/ElderDrivers/EdXposed/releases/ Edxposed全称 Elder driver Xposed Framework，简称edxp.大名鼎鼎的xposed框架可以实现QQ抢红包，微信抢红包，防止消息撤回等功能。xposed也是所有android系统获取root后必装的东西。但可惜，自从android 7.0之后xposed的开发者rovo89基本就不维护了，针对android 8.0的版本草草发布了一个测试版本撒手不管了。现在越来越多的新机型出厂就是android 9.0系统，那么怎么才能继续使用xposed框架，如何才能继续快乐的抢红包呢？其实有办法！xposed虽然死了，但它却不再是唯一。比如今天我要提到的Edxposed框架，Edxposed全称 Elder driver Xposed Framework，简称edxp，Edxposed框架现在支持android 8.0 -android 9.0 ，如果是android 7.0或更早的版本，推荐使用xposed框架。针对框架的安装问题，官方推出了Magisk模块的安装方式，也就是提供了一个zip压缩包，在Magisk中安装重启即可。在安装edxposed的magisk模块之前，你需要先安装riru的magisk模块。本文主要是Magisk安装Edx。 参考：作者：coderstory《后Xposed时代: 一篇文章看懂如何安装和使用Edxposed》https://blog.coderstory.cn/guide-install-edxposed/ 刷入第三方rec下载准备准备：电脑 数据线 手机 所需工具来自 rom乐园 参考教程：http://www.romleyuan.com/lec/read?id=201 小米全机型TWRP一键刷机工具： 百度网盘下载：https://pan.baidu.com/s/1K0VuCxwwKT9OI3yCouV3Gg高速下载，请关注微信公众号：ROM乐园 回复关键字：全机型recovery下载 twrp机型下载地址汇总链接：https://pan.baidu.com/s/1zIZ9ObMiKwjlW3LvpOixMw提取码：9kam 刷入解压刷入RECOVERY工具并打开 彻底关闭手机，音量下和开机按键进入fastboot模式双击运行一键刷入RECOVERY.bat脚本 提示连接成功后，根据提示一步步刷完RECOVERY刷机完成后，会自动进入RECOVERY，或者提示进入RECOVERY方法 小米手机进入TWRP_Recovery教程：开机状态下，选择重启手机，按住音量山不松手，即可进入TWRP_Recovery 关机状态下，长开机键和音量上不松手，震动后松开开机按键，保持音量上 不松手，等待手机自带进入twrp界面 刷入magisk安装 Magisk 需要解锁 Bootloader 并刷入第三方 Recovery。所以每个品牌的手机都或多或少的有点不一样，这里只介绍一个标准的流程， 下载准备网站下载magisk包； 下面提供个人云盘的下载：magisk app:链接：https://pan.baidu.com/s/1YXTdIAbbp0xMoBT0UWFboA提取码：p15w magisk v20.4链接：https://pan.baidu.com/s/1q6kBqFDuAVIQeQ2KRji0sw提取码：mzd5 magisk卸载包 链接：https://pan.baidu.com/s/1UjigsfnuHwFpC1YkjNLrQQ提取码：6lg7 下载 APP 和magisk v20.4 就好了 方法首先将下好的magisk v20.4 包放入手机中 进入第三方 Recovery（以 twrp 为例） 安装刷机包 找到我让你放在硬盘中的那个包（后缀为 .zip） 滑动滑块，开始刷机 刷好后立即重启。 至此，magisk安装完毕。 模块 magisk安装之后可以安装很多模块实现对手机的功能扩展。具体的模块分享会专门出一个板块。 刷入 Edx下载准备：有了magisk之后安装Edxp相对比较简单，Edxp作为一个Magisk模块被刷入。以前需要刷入 Riru Core和Edx两个模块，但之后有大佬对模块进行了整合，这里分享的就是整合后的模块，用magisk输入后就可以了。 Magisk模块-EdXposed完整框架v2.7Y版链接：https://pan.baidu.com/s/1oxvrpwnWLQWzoQJKYroOUw提取码：a9dk 安装下载之后进入第三方rec ，找到模块安装重启之后一般就会出现 Edx的图标 至此，Edxp安装完毕。 模块Edxp 也有很多模块，模块分享会和Magisk模块一起发出。 后话magisk 和Edxp是我个人用的比较多的，当然市面上还有太极之类的玩机软件也不错，有想法的可以去试试。 此次教程参考转载了很多大佬的文章，主要在于自己表达水平不行，在此对这些大佬表示感谢。如有侵权，请联系我删除。"},{"title":"玩机汇总（二）：小米手机解锁与刷开发版","path":"posts/ee61.html","text":"本文记录我几年的玩机记录和经验，以小米手机的玩机经验为主有变砖风险。玩机有风险，搞机需谨慎。 手机解锁前言：手机解锁每个品牌都有不同的方法，华为的以前可以申请解锁码解锁，但之后直接关闭了解锁通道，所以华为手机可玩性不高。ov系一直没有开通root权限，oppo旗下子品牌realme（本人目前的手机）到有可以解锁的。魅族也有官方的解锁通道。本文以小米解锁为例。 解锁即解bl锁，解除bl锁后我们就可以自由的刷机与刷入rec了，而如果我们不解锁，我们就只能通过有限的刷机方式来刷机，譬如通过官方rec进行更新，但是官方rec只能刷官方指定的刷机包，而如果想要刷入第三方刷机包都需要解除bl锁。 解除bl锁的教程： 注意事项： 你必须要有小米账号，且小米账号在你的小米手机上登录了超过24个小时 你需要一台电脑，一个usb数据线，原装的最好。 如果你只是想刷开发版，可以下滑到刷开发版的教程，刷入开发版不需要解锁bl锁！ 解锁需要申请解锁码，申请后需要等待一到三个工作日，所以无法立即解锁。 解锁后会清除数据，请先备份数据！解锁后会清除数据，请先备份数据！解锁后会清除数据，请先备份数据！解锁后会清除数据，请先备份数据！解锁后会清除数据，请先备份数据！ 下载解锁工具进入MIUI论坛，网址： 小米解锁地址 点击立即解锁 下载解锁工具到电脑，解压 miflash_unlock.exe 就是解锁程序。 开启开发者模式打开手机，进入设置–我的设备–全部参数 多次点击MIUI版本，知道弹窗显示“已进入开发者模式” 回退到设置主界面 点开“更多设置” 点击开发者选项（这里前面没有多次点击MIUI开启的话是没有这个选项的） 开启开发者选项和USB调试 这里插一句,这里有个设备解锁状态是可以看是否账号与手机绑定的，如果没有绑定，绑定后要24h后才能解锁 连接手机解锁把手机关机，同时按住开机键和音量下键（音量减键）； 按住7s后，手机会亮屏，如果屏幕是这个内容 说明你已经进入Bootloader模式了。 这时候，把手机用usb数据线连接到电脑上。 打开解压工具，找到miflash_unlock，双击运行 同意免责条款后登陆小米账号 之后会验证是否支持解锁 之后点击解锁就好了 刷入开发版miui下载刷机包下载地址：MIUI下载 选择对应手机版本（以小米6为例）下载开发版安装包将手机连接电脑，划出状态栏，选择正在通过USB充电（如果在这之前你更改过设置，也有可能会是正在通过USB传输照片&#x2F;传输文件）打开此电脑，选择你的手机 找到downloaded_rom文件夹，并打开把你下载的开发版刷机包复制到downloaded_rom文件夹里，断开手机与电脑的连接。 并保证手机有50%以上的电量。打开设置–我的设备 选择MIUI版本，在MIUI版本界面点击右上角 选择手动选择刷机包，找到downloaded_rom，选择你的ROM，刷机即可。 参考：小米手机解锁与刷开发版教程 - 八重樱的文章 - 知乎https://zhuanlan.zhihu.com/p/62107666"},{"title":"玩机汇总（四）：magisk模块和Edxp模块分享","path":"posts/6ff5.html","text":"本文介绍magisk模块和Edxp模块分享，均为网络资源为尊重原作者劳动成果，最大程度保证模块来自原作者分享网页在此对各个大佬表示感谢，如有问题，请联系我删除。 前排提示：每个模块对每个手机兼容性无法保证，模块之间也有可能会有冲突，有变砖风险。玩机有风险，搞机需谨慎。 magisk 模块MM管理器-2018.09.16 汉化作者：链接：https://pan.baidu.com/s/14ZeKBRdC9DJly00FwkTXpg提取码：27wk功能：可在rec模式卸载已安装模块，可用来救砖。（高版本的第三方rec已具备此功能） 小米 mixAlpha 机型模块作者：酷安 坏叔叔_hi网址（作者原分享网址）：https://www.lanzous.com/i9yvlkf?t功能：将手机型号修改为 MixAlpha 更多机型模块可以在酷安侯旭Hxv主页寻找 AD 影视 Hosts1.2作者：依然的爱网址：链接：https://pan.baidu.com/s/15-J1saudJheohBFJZpWyOg提取码：zr37功能：屏蔽各类广告包括(各大视频网站,运营商劫持广告，大部分APP广告),hosts规则均来自于网络搜索,github,人工抓取及酷友提供，使用时请关闭其他hosts模块,请关闭systemless hosts模块(如果有)。 Magisk-超级快充2.0作者：链接：链接：https://pan.baidu.com/s/1Nj0ngsQkjMGeT0PvmWGllA提取码：p7m4功能：快充 Magisk-毒液 完整版（适合开机慢）作者：链接：https://pan.baidu.com/s/14fz045q_CbY3bGgyvD7WDg提取码：a6nd功能：改变开机动画 Magisk-黑域启动插件作者：链接：https://pan.baidu.com/s/1LeyI462PzAHSndWNelg9UQ提取码：2spa Magisk_浪漫雅圆+Sleek+Google(综合字体)作者：链接：https://pan.baidu.com/s/1rpOyQKVmI9dQIVwCC2ER4Q提取码：hq66功能：修改系统字体 充电90％自动暂停作者：链接：https://pan.baidu.com/s/1Lgk4keO6oRAcMZIqLaxZ6Q提取码：jrtk功能：充电90％自动暂停 其他个人收集模块链接：https://pan.baidu.com/s/1AdRqJlDClp0qKn9njXejzg提取码：r87o 链接：https://pan.baidu.com/s/1Wx6CnfhOSTURk_72uf1mQg提取码：53tv ！！玩机有风险，搞机需谨慎。！！ Edxp模块edxp 上有模块下载，也可以去edxp上下载 哔哩漫游作者：iAcn&#x2F;djytw&#x2F;yujincheng08哔哩漫游 (BiliRoaming) - http://repo.xposed.info/module/me.iacn.biliroaming功能：解除B站番剧区域限制港澳台CDN加速缓存番剧支持国际版和概念版自定义主题色关闭青少年模式弹窗显示评论区楼层概念版添加直播入口不以小程序形式分享 网易云音乐插件作者：Specher网易云音乐插件 - http://repo.xposed.info/module/com.specher.music163功能：一个网易云音乐的Xposed插件。目前功能：自动签到、跳过启动广告、本地数据修改、美化功能。最佳适配4.3.X，理论任意版本通用 云村清洁工作者：xmodule.org云村清洁工app是一款非常好用的网易云插件，需要XP框架，搭配食用非常舒服，避免提示应用升级重要：使用的是七牛云镜像下载，请勿在xposed install内下载！！！！请直接用浏览器访问： https://repo.xposed.info/module/me.zjns.lovecloudmusic下载 1、禁止签到跳转商城；2、去除启动页，评论区等位置广告；3、伪装成谷歌版，避免提示升级。、 涉及到各种CD问题，不再更新。你可以关注微信公众号: xmodule 回复: 云村清洁工 下载我最新编译的版本 WeXposed （微X模块）作者：fkzhang http://repo.xposed.info/module/com.fkzhang.wechatxposed功能：-防止微信撤回消息 转发微信聊天里的图片和小视频到朋友圈 转发聊天里的多张图片（最多9张）到朋友圈 转发语音给朋友 转发收藏内容 转发朋友圈里的内容到自己的朋友圈 分享图片和小视频 屏蔽群聊成员 自动查找僵尸粉 批量删除好友 批量删除僵尸粉 自动回复 自定义表情最高限额 自动领取红包、转账 等等。。。 请谨慎使用自动领取红包功能！ QXposed （QX模块）作者：fkzhang http://repo.xposed.info/module/com.fkzhang.qqxposed功能：-防止QQ撤回消息-自动领取红包-控制骰子-支持TIM chimi作者：yonhhen链接：https://github.com/yonghen/chimi-/releases功能：MIUI主题破解 MIUI主题防恢复作者：夢月時歌链接https://www.wenshushu.cn/f/2s1mm0vm3bx功能：启MIUI主题破解模块，有效防止主题自动恢复默认。可用第三方主题，免费使用付费字体。"},{"title":"win桌面美化教程","path":"posts/74c4.html","text":"win桌面美化教程Win桌面美化教程在这记录下个人win 美化入坑的一些经验，主要是怕自己以后忘了怎么搞的 more 先上一波成品图 ​目录​1.文件rainmeter :链接：https://pan.baidu.com/s/1lgWzoQYrZwnBk1uUB2bgJA 提取码：35272.配置美化主要需要 win主题，rainmeter， 透明状态栏等等东西2.1 注意事项为避免造成错误，一般最好先关闭各种安全软件，创建系统还原点右击“我的电脑” 点击“属性”​点击“系统保护” 点击“创建” 随便输入，点击创建，等待一会就创建好了 创建系统还原点的目的是备份下之前的设置，以便以后想恢复的时候恢复 2.2 rainmeter 安装与使用Rainmeter是一款美化桌面的软件，可以加载各种桌面摆件：天气，时间，快捷方式，RSS，播放器，系统信息监控等安装并运行 Rainmeter 程序，即可双击雨滴皮肤运行，部分雨滴皮肤是文件夹式的，复制到C:\\Users\\用户名\\Documents\\Rainmeter\\Skins内，在任务栏托盘处找到白色小水滴的图标，双击打开配置面板，在左侧选择.ini文件，选择加载。比较占用系统资源，老爷机谨慎安装；新手在安装时不要选择便携模式，否则无法正常安装皮肤。下面是我收集到的一些插件包（资源来自网络，侵删）使用方法：解压到C:\\Users\\用户名\\Documents\\Rainmeter\\Skins目录下，在rainmeter 管理器里安装就好了，桌面上课一拖到任意位置 时钟插件 链接：https://pan.baidu.com/s/1S2tf6RUv2fK_-yVFQ-sdvQ 提取码：1tpe频谱和时间 链接：https://pan.baidu.com/s/1aIdue3BuPRKk_HgTnSkl-A 提取码：9kb9布卡娘 链接：https://pan.baidu.com/s/1ePNvoTSX1FvYkqx0dHB11A 提取码：iyko侧边栏 链接：https://pan.baidu.com/s/1YMuRB9hzRITqdmya_W2Nhw 提取码：egia皮肤 链接：https://pan.baidu.com/s/1nDnacaIoY9Tt7YPh1kzh2A 提取码：zaa82.3 透明化状态栏这个就是一个软件达到的效果软件名： TranslucentTB下载：链接：https://pan.baidu.com/s/14K4zASY82_TByhgTq9mDGA 提取码：axer2.4 然后就是一些好康的壁纸了！！链接：https://pan.baidu.com/s/1sxkKiuqJBbpJm6rTWP-PDg 提取码：m731魔法阵 链接：https://pan.baidu.com/s/1tD5ZI0-zIqnlfv18P__DEQ 提取码：6dkd 2.5 仿mac状态栏就是动图中那个东西，也只是一个软件达到的效果软件名:mydock链接：https://pan.baidu.com/s/1RDH85lhHjFxo2ye342vKLg 提取码：xljl—————————————–END——————————有时间的话在写一下自定义磁贴的"}]