{"title":"vue部分高级特性","uid":"71e2919efeb36c0c91f25d9483061d80","slug":"vue部分高级特性","date":"2021-07-16T05:22:00.000Z","updated":"2021-07-16T05:25:48.494Z","comments":true,"path":"api/articles/vue部分高级特性.json","keywords":null,"cover":[],"content":"<p>概述<br>文章将讲述指令、混入、高阶组件、函数式组件、@hook、异步组件等内容。如果文中有不当的地方欢迎指正哦！<br>特性以及部分原理<br>自定义指令（directive）<br>除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。有时候我们想对dom进行操作的时候，就可以使用自定义指令，比如设置标题样式并且让标题一直固定在页面上方，可以使用全局注册或者局部注册。然后你可以在模板中任何元素上使用新的 v-title property。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;全局注册\n&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;div v-title&gt;hello world&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;script&gt;\n    Vue.directive(&#39;title&#39;, &#123;\n        inserted: function (el) &#123;\n            console.log(el)\n            el.style.position &#x3D; &#39;fixed&#39; \n            el.style.top &#x3D; &#39;50px&#39; \n            el.style.left &#x3D; &#39;48%&#39; \n            el.style.color &#x3D; &#39;#409EFF&#39; \n        &#125;\n    &#125;)\n\n    new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n            message: &#39;hello!&#39;\n        &#125;\n    &#125;)\n&lt;&#x2F;script&gt;\n&lt;style&gt;\n   #app&#123;\n       height: 1000px\n   &#125; \n&lt;&#x2F;style&gt;\n&#x2F;&#x2F;局部注册\n  new Vue(&#123;\n    el: &#39;#app&#39;,\n    directives: &#123;\n        title: &#123;\n            inserted: function (el) &#123;\n                console.log(el)\n                el.style.position &#x3D; &#39;fixed&#39;\n                el.style.top &#x3D; &#39;50px&#39;\n                el.style.left &#x3D; &#39;48%&#39;\n                el.style.color &#x3D; &#39;#409EFF&#39;\n            &#125;\n        &#125;\n    &#125;\n  &#125;)\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://gitee.com/wkkif/PicGoimg/raw/master/img/20210716132337.png\" alt=\"image-20210716132337860\"></p>\n<h4 id=\"irective钩子函数参数\"><a href=\"#irective钩子函数参数\" class=\"headerlink\" title=\"irective钩子函数参数\"></a>irective钩子函数参数</h4><p>指令钩子函数会被传入以下参数：</p>\n<ul>\n<li>el：指令所绑定的元素，可以用来直接操作 DOM。</li>\n<li>binding：一个对象，包含以下 property：</li>\n</ul>\n<ol>\n<li>name：指令名，不包括 v- 前缀。</li>\n<li>value：指令的绑定值，例如：v-my-directive&#x3D;”1 + 1” 中，绑定值为 2。</li>\n<li>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</li>\n<li>expression：字符串形式的指令表达式。例如 v-my-directive&#x3D;”1 + 1” 中，表达式为 “1 + 1”。</li>\n<li>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。</li>\n<li>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。</li>\n</ol>\n<ul>\n<li>vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。</li>\n<li>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li>\n</ul>\n<p>我们打印下函数传入的参数，其实简单来说就是el就是绑定dom元素，binging指令：后所携带的具体内容，VNode就当还未生成的节点好了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;div v-title:arr&#x3D;&quot;message&quot;&gt;hello world&lt;&#x2F;div&gt;\nVue.directive(&#39;title&#39;, &#123;\n        inserted: function (el, binding, vnode) &#123;\n            console.log(el, binding, vnode)\n            el.style.position &#x3D; &#39;fixed&#39; \n            el.style.top &#x3D; &#39;50px&#39; \n            el.style.left &#x3D; &#39;48%&#39; \n            el.style.color &#x3D; &#39;#409EFF&#39; \n        &#125;\n    &#125;)\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://gitee.com/wkkif/PicGoimg/raw/master/img/20210716132408.png\" alt=\"image-20210716132408088\"></p>\n<h4 id=\"钩子函数\"><a href=\"#钩子函数\" class=\"headerlink\" title=\"钩子函数\"></a>钩子函数</h4><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p>\n<ul>\n<li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li>\n<li>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li>\n<li>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li>\n<li>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用</li>\n<li>unbind：只调用一次，指令与元素解绑时调用。</li>\n</ul>\n<p>我们可以测试下钩子函数的调用时机：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;div id&#x3D;&quot;txt&quot; v-title:data&#x3D;&quot;sum&quot;&gt;value: &#123;&#123;sum&#125;&#125;&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;script&gt;\n    new Vue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n            sum: 0\n        &#125;,\n        directives: &#123;\n            title: &#123;\n                bind: (el, bind) &#x3D;&gt; &#123; console.log(bind.value, &#39;a&#39;) &#125;,&#x2F;&#x2F; 第一次绑定元素时调用\n                inserted: (el, bind) &#x3D;&gt; &#123; console.log(bind.value, &#39;b&#39;) &#125;,&#x2F;&#x2F; 当被绑定的元素插入到 DOM 中时……\n                update: (el, bind) &#x3D;&gt; &#123; console.log(bind.value, &#39;c&#39;) &#125;,&#x2F;&#x2F; 所在组件VNode发生更新时调用\n                componentUpdated: (el, bind) &#x3D;&gt; &#123; console.log(bind.value, &#39;d&#39;) &#125;, &#x2F;&#x2F; 指令所在组件的 VNode 及其子 VNode 全部更新后调用\n                unbind: (el, bind) &#x3D;&gt; &#123; console.log(bind.value, &#39;e&#39;) &#125;    &#x2F;&#x2F; 只调用一次，指令与元素解绑时调用\n            &#125;\n        &#125;,\n        mounted() &#123;\n            console.log(this.sum, &#39;???&#39;)\n            let timer &#x3D; setInterval(() &#x3D;&gt; &#123;\n                this.sum++\n            &#125;, 200)\n            setTimeout(() &#x3D;&gt; &#123;\n                clearInterval(timer)\n            &#125;, 3000)\n        &#125;\n    &#125;)\n&lt;&#x2F;script&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://gitee.com/wkkif/PicGoimg/raw/master/img/20210716132434.png\" alt=\"image-20210716132434649\"></p>\n<h4 id=\"指令大致原理\"><a href=\"#指令大致原理\" class=\"headerlink\" title=\"指令大致原理\"></a>指令大致原理</h4><p>在页面渲染的过程中，分别有创建(create)、激活(avtivate)、更新(update)、移除(remove)、销毁(destroy)，在这些过程中，框架在每个时段都会调用相应的钩子函数，这些hooks中一部分的函数就包含了我们的指令。源码部分我了解的不多，给大家推荐一篇vue指令原理相关博文<a href=\"https://link.juejin.cn/?target=https://www.cnblogs.com/gerry2019/p/14940770.html%E3%80%82\">www.cnblogs.com/gerry2019/p…</a></p>\n<h3 id=\"混入\"><a href=\"#混入\" class=\"headerlink\" title=\"混入\"></a>混入</h3><p>官方是这样定义的：混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。其实就是vue实例的一个复用。实用场景：公共组件或者功能，例如获取用户白名单、菜单返回、公共基础table。 值得注意的点：</p>\n<ol>\n<li>当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。比如，数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时以组件数据优先。</li>\n<li>同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。</li>\n<li>值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var mixin &#x3D; &#123;\n  data: function () &#123;\n    return &#123;\n      message: &#39;hello&#39;,\n      foo: &#39;abc&#39;\n    &#125;\n  &#125;\n&#125;\n\nnew Vue(&#123;\n  mixins: [mixin],\n  data: function () &#123;\n    return &#123;\n      message: &#39;goodbye&#39;,\n      bar: &#39;def&#39;\n    &#125;\n  &#125;,\n  created: function () &#123;\n    console.log(this.$data)\n    &#x2F;&#x2F; &#x3D;&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125;\n  &#125;\n&#125;)\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h3><p>一个函数接受一个组件为参数，返回一个包装后的组件。其实在vue中，组件可以当做一个函数，那从本质上来说，高阶组件就是高阶函数（JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数）</p>\n<h4 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h4><p>举例一个最简单的高阶函数计算次方</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> function pow(x, y, f)&#123;\n    return f(x, y);\n  &#125;\n  pow(3, 3, Math.pow)\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在es6中也有很多高阶函数，如map、reduce、filter。</p>\n<h4 id=\"高阶组件的例子\"><a href=\"#高阶组件的例子\" class=\"headerlink\" title=\"高阶组件的例子\"></a>高阶组件的例子</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;div id&#x3D;&quot;app&quot;&gt;\n    &lt;hoc&gt;&lt;&#x2F;hoc&gt;\n&lt;&#x2F;div&gt;\n&lt;script&gt;\n    const view &#x3D; &#123;\n        template: &#96;&lt;span&gt;\n                    &lt;span&gt;test hoc ...&lt;&#x2F;span&gt;\n                    &lt;&#x2F;span&gt;&#96;,\n        props: [&quot;result&quot;, &quot;loading&quot;],\n    &#125;;\n    const test &#x3D; (wrapped, txt &#x3D; &#39;hello&#39;) &#x3D;&gt; &#123;\n        return &#123;\n            render(h) &#123;\n                const args &#x3D; &#123;\n                    props: &#123;\n                        result: this.result,\n                        loading: this.loading,\n                    &#125;,\n                &#125;;\n                const wrapper &#x3D; h(&quot;div&quot;, [\n                    h(wrapped, args),\n                    &#39;loading&#39;\n                ]);\n                return wrapper\n            &#125;\n        &#125;\n    &#125;\n    const hoc &#x3D; test(view, &#39;hui&#39;)\n    console.log(hoc);\n\n    new Vue(&#123;\n        el: &#39;#app&#39;,\n        components: &#123;\n            hoc\n        &#125;,\n        data: &#123;\n            sum: 0\n        &#125;\n    &#125;)\n&lt;&#x2F;script&gt;\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://gitee.com/wkkif/PicGoimg/raw/master/img/20210716132510.png\" alt=\"image-20210716132510491\"></p>\n<h4 id=\"值得注意的点\"><a href=\"#值得注意的点\" class=\"headerlink\" title=\"值得注意的点\"></a>值得注意的点</h4><ol>\n<li>高阶组件(HOC)应该是无副作用的纯函数，且不应该修改原组件,就是组件是一个新的组件，不会对原组件做修改。</li>\n<li>高阶组件(HOC)不关心你传递的数据(props)是什么，并且被包装组件(WrappedComponent)不关心数据来源</li>\n<li>高阶组件(HOC)接收到的 props 应该透传给被包装组件(WrappedComponent)</li>\n<li>在高阶组件中渲染函数向子组件中传递作用域插槽时候要注意上下文</li>\n</ol>\n<h3 id=\"动态组件-异步组件-递归组件\"><a href=\"#动态组件-异步组件-递归组件\" class=\"headerlink\" title=\"动态组件 异步组件 递归组件\"></a>动态组件 异步组件 递归组件</h3><h4 id=\"动态组件\"><a href=\"#动态组件\" class=\"headerlink\" title=\"动态组件\"></a>动态组件</h4><p>可以在同组件之间进行动态切换， 动态切换可以通过 Vue 的  元素加一个特殊的 is attribute 来实现：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!-- 组件会在 &#96;currentTabComponent&#96; 改变时改变 --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Dynamic Components Example&lt;&#x2F;title&gt;\n    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;style&gt;\n      .tab-button &#123;\n        padding: 6px 10px;\n        border-top-left-radius: 3px;\n        border-top-right-radius: 3px;\n        border: 1px solid #ccc;\n        cursor: pointer;\n        background: #f0f0f0;\n        margin-bottom: -1px;\n        margin-right: -1px;\n      &#125;\n      .tab-button:hover &#123;\n        background: #e0e0e0;\n      &#125;\n      .tab-button.active &#123;\n        background: #e0e0e0;\n      &#125;\n      .tab &#123;\n        border: 1px solid #ccc;\n        padding: 10px;\n      &#125;\n    &lt;&#x2F;style&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;dynamic-component-demo&quot; class&#x3D;&quot;demo&quot;&gt;\n      &lt;button\n        v-for&#x3D;&quot;tab in tabs&quot;\n        v-bind:key&#x3D;&quot;tab&quot;\n        v-bind:class&#x3D;&quot;[&#39;tab-button&#39;, &#123; active: currentTab &#x3D;&#x3D;&#x3D; tab &#125;]&quot;\n        v-on:click&#x3D;&quot;currentTab &#x3D; tab&quot;\n      &gt;\n        &#123;&#123; tab &#125;&#125;\n      &lt;&#x2F;button&gt;\n\n      &lt;component v-bind:is&#x3D;&quot;currentTabComponent&quot; class&#x3D;&quot;tab&quot;&gt;&lt;&#x2F;component&gt;\n    &lt;&#x2F;div&gt;\n\n    &lt;script&gt;\n      Vue.component(&quot;tab-home&quot;, &#123;\n        template: &quot;&lt;div&gt;Home component&lt;&#x2F;div&gt;&quot;\n      &#125;);\n      Vue.component(&quot;tab-posts&quot;, &#123;\n        template: &quot;&lt;div&gt;Posts component&lt;&#x2F;div&gt;&quot;\n      &#125;);\n      Vue.component(&quot;tab-archive&quot;, &#123;\n        template: &quot;&lt;div&gt;Archive component&lt;&#x2F;div&gt;&quot;\n      &#125;);\n\n      new Vue(&#123;\n        el: &quot;#dynamic-component-demo&quot;,\n        data: &#123;\n          currentTab: &quot;Home&quot;,\n          tabs: [&quot;Home&quot;, &quot;Posts&quot;, &quot;Archive&quot;]\n        &#125;,\n        computed: &#123;\n          currentTabComponent: function() &#123;\n            return &quot;tab-&quot; + this.currentTab.toLowerCase();\n          &#125;\n        &#125;\n      &#125;);\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"异步组件\"><a href=\"#异步组件\" class=\"headerlink\" title=\"异步组件\"></a>异步组件</h4><p>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Vue.component(&#39;async-example&#39;, function (resolve, reject) &#123;\n  setTimeout(function () &#123;\n    &#x2F;&#x2F; 向 &#96;resolve&#96; 回调传递组件定义\n    resolve(&#123;\n      template: &#39;&lt;div&gt;I am async!&lt;&#x2F;div&gt;&#39;\n    &#125;)\n  &#125;, 1000)\n&#125;)\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在vue-cli中在使用异步组件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const first &#x3D;()&#x3D;&gt;import(&#x2F;* webpackChunkName: &quot;group-foo&quot; *&#x2F; &quot;..&#x2F;components&#x2F;first.vue&quot;);\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"vue中部分钩子函数-hook\"><a href=\"#vue中部分钩子函数-hook\" class=\"headerlink\" title=\"vue中部分钩子函数(@hook)\"></a>vue中部分钩子函数(@hook)</h3><p>Vue 实例同时在其事件接口中提供了其它的方法。我们可以：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>通过 $on(eventName, eventHandler) 侦听一个事件</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>通过 $once(eventName, eventHandler) 一次性侦听一个事件</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>通过 $off(eventName, eventHandler) 停止侦听一个事件</p></blockquote>\n<p>你通常不会用到这些，但是当你需要在一个组件实例上手动侦听事件时，它们是派得上用场的。它们也可以用于代码组织工具。例如，你可能经常看到这种集成一个第三方库的模式。官网提供一个案例：在不使用beforeDestroy钩子清picker</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;案例一\nmounted: function () &#123;\n  var picker &#x3D; new Pikaday(&#123;\n    field: this.$refs.input,\n    format: &#39;YYYY-MM-DD&#39;\n  &#125;)\n\n  this.$once(&#39;hook:beforeDestroy&#39;, function () &#123;\n    picker.destroy()\n  &#125;)\n&#125;\n&#x2F;&#x2F;案例二\n&#x2F;&#x2F;在父组件在子组件渲染阶段做一些操作\n&lt;child\n  @hook:mounted&#x3D;&quot;handle&quot;\n  @hook:beforeUpdated&#x3D;&quot;xxx&quot;\n  @hook:updated&#x3D;&quot;xxx&quot;\n&#x2F;&gt;\nmethod () &#123;\n  handle() &#123;\n  &#x2F;&#x2F; do something...\n  &#125;\n&#125;,\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在vue生命周期中周期都有对应的钩子函数</p>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><p>插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：</p>\n<ul>\n<li>添加全局方法或者 property。如：vue-custom-element</li>\n<li>添加全局资源：指令&#x2F;过滤器&#x2F;过渡等。如 vue-touch</li>\n<li>通过全局混入来添加一些组件选项。如 vue-router</li>\n<li>添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。</li>\n<li>一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router</li>\n</ul>\n<p>自定义插件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">MyPlugin.install &#x3D; function (Vue, options) &#123;\n  &#x2F;&#x2F; 1. 添加全局方法或 property\n  Vue.myGlobalMethod &#x3D; function () &#123;\n    &#x2F;&#x2F; 逻辑...\n  &#125;\n\n  &#x2F;&#x2F; 2. 添加全局资源\n  Vue.directive(&#39;my-directive&#39;, &#123;\n    bind (el, binding, vnode, oldVnode) &#123;\n      &#x2F;&#x2F; 逻辑...\n    &#125;\n    ...\n  &#125;)\n\n  &#x2F;&#x2F; 3. 注入组件选项\n  Vue.mixin(&#123;\n    created: function () &#123;\n      &#x2F;&#x2F; 逻辑...\n    &#125;\n    ...\n  &#125;)\n\n  &#x2F;&#x2F; 4. 添加实例方法\n  Vue.prototype.$myMethod &#x3D; function (methodOptions) &#123;\n    &#x2F;&#x2F; 逻辑...\n  &#125;\n&#125;\n复制代码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n<p>作者：仅九<br>链接：<a href=\"https://juejin.cn/post/6985035199432097823\">https://juejin.cn/post/6985035199432097823</a></p>\n","text":"概述文章将讲述指令、混入、高阶组件、函数式组件、@hook、异步组件等内容。如果文中有不当的地方欢迎指正哦！特性以及部分原理自定义指令（directive）除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。有时候我们想对dom进行操作...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":15,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"Vue.js","slug":"Vue-js","count":1,"path":"api/tags/Vue-js.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#irective%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">irective钩子函数参数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">钩子函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E5%A4%A7%E8%87%B4%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">指令大致原理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%B7%E5%85%A5\"><span class=\"toc-text\">混入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">高阶组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">高阶函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">高阶组件的例子</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9\"><span class=\"toc-text\">值得注意的点</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6-%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6-%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">动态组件 异步组件 递归组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">动态组件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">异步组件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#vue%E4%B8%AD%E9%83%A8%E5%88%86%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-hook\"><span class=\"toc-text\">vue中部分钩子函数(@hook)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%92%E4%BB%B6\"><span class=\"toc-text\">插件</span></a>","author":{"name":"kif","slug":"blog-author","avatar":"https://kifimg.oss-cn-beijing.aliyuncs.com/imgforteachingdemo/20201127203438.png","link":"/","description":"时间再拉长一点，让我有时间收拾一下心情","socials":{"github":"https://github.com/wkif","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_54739682?type=blog","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"2021C.S.N夏令营VUE班级讲义","uid":"d930d8d84c4a2ee4a4d63f3e717c54e0","slug":"2021C-S-N夏令营VUE班级讲义","date":"2021-10-04T06:57:00.000Z","updated":"2022-03-30T15:58:07.539Z","comments":true,"path":"api/articles/2021C-S-N夏令营VUE班级讲义.json","keywords":null,"cover":"https://kifimg.oss-cn-beijing.aliyuncs.com/imgforhexo/20201127205150.jpg","text":"一、课程安排1.学前基础html、css、javascript、ajax 2.开发工具2.1 下载安装Vscode 前端VUE项目，原先的开发工具是HBuilderX（上手快捷，使用方便），但是随着项目规模的增大，随之而来的是维护和管理成本的不可控（手下码农或者是实习生随性而发的...","link":"","photos":[],"count_time":{"symbolsCount":"37k","symbolsTime":"34 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":15,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"C.S.N","slug":"C-S-N","count":3,"path":"api/tags/C-S-N.json"}],"author":{"name":"kif","slug":"blog-author","avatar":"https://kifimg.oss-cn-beijing.aliyuncs.com/imgforteachingdemo/20201127203438.png","link":"/","description":"时间再拉长一点，让我有时间收拾一下心情","socials":{"github":"https://github.com/wkif","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_54739682?type=blog","juejin":"","customs":{}}}},"next_post":{"title":"标准分类的IP地址","uid":"28d0a4fcfbc7fc3606b73b8705c12a98","slug":"标准分类的IP地址","date":"2021-06-22T06:28:00.000Z","updated":"2022-03-30T15:58:58.944Z","comments":true,"path":"api/articles/标准分类的IP地址.json","keywords":null,"cover":"https://kifimg.oss-cn-beijing.aliyuncs.com/imgforhexo/20201202142630.jpg","text":"一、标准分类的IP地址 每台计算机都要有IP地址，有了IP地址才能互相通信，计算机之间只能互相认识IP地址。IP地址可以理解为计算机的×××号。 （一）二进制和十进制数转换(★记住) 11111111→128＋64＋32＋16＋8＋4＋2＋1＝240＋15＝255 举例： 101...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":15,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"计算机网络","slug":"计算机网络","count":2,"path":"api/tags/计算机网络.json"}],"author":{"name":"kif","slug":"blog-author","avatar":"https://kifimg.oss-cn-beijing.aliyuncs.com/imgforteachingdemo/20201127203438.png","link":"/","description":"时间再拉长一点，让我有时间收拾一下心情","socials":{"github":"https://github.com/wkif","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_54739682?type=blog","juejin":"","customs":{}}}}}