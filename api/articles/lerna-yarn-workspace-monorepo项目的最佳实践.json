{"title":"lerna+yarn workspace+monorepo项目的最佳实践","uid":"8194451e25c86b4d1b6b68c34d396a48","slug":"lerna-yarn-workspace-monorepo项目的最佳实践","date":"2023-01-26T11:01:00.000Z","updated":"2023-01-26T11:06:33.710Z","comments":true,"path":"api/articles/lerna-yarn-workspace-monorepo项目的最佳实践.json","keywords":null,"cover":"https://kifimg.oss-cn-beijing.aliyuncs.com/img/202301261903204.png","content":"<h1 id=\"1-monorepo-管理\"><a href=\"#1-monorepo-管理\" class=\"headerlink\" title=\"1.monorepo 管理\"></a>1.monorepo 管理</h1><p>对于维护过多个<a href=\"https://so.csdn.net/so/search?q=package&spm=1001.2101.3001.7020\">package</a>(<strong>功能相近</strong>)的同学来说，都会遇到一个选择题，这些 package 是放在一个仓库里维护还是放在多个仓库里单独维护。Multirepo 是比较传统的做法，即每一个 package 都单独用一个仓库来进行管理。Monorepo 是管理项目代码的一个方式，指在一个项目仓库 (repo) 中管理多个模块&#x2F;包 (package)，不同于常见的每个模块建一个 repo。</p>\n<p>目前有不少大型开源项目采用了这种方式，如 <code>Babel</code>，<code>React</code>, <code>Meteor</code>, <code>Ember</code>, <code>Angular</code>,<code>Jest</code>, <code>Umijs</code>, <code>Vue</code>, 还有 <code>create-react-app</code>, <code>react-router</code> 等。几乎我们熟知的仓库，都无一例外的采用了 monorepo 的方式，可以看到这些项目的第一级目录的内容以脚手架为主，主要内容都在 packages 目录中、分多个 package 进行管理。</p>\n<p>目录结构如下:</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">├── packages\n<span class=\"token operator\">|</span>   ├── pkg1\n<span class=\"token operator\">|</span>   <span class=\"token operator\">|</span>   ├── package.json\n<span class=\"token operator\">|</span>   ├── pkg2\n<span class=\"token operator\">|</span>   <span class=\"token operator\">|</span>   ├── package.json\n├── package.json\n<span class=\"token number\">123456</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>monorepo 最主要的好处是<strong>统一的工作流</strong>和<strong>Code Sharing</strong>。比如我想看一个 pacakge 的代码、了解某段逻辑，不需要找它的 repo，直接就在当前 repo；当某个需求要修改多个 pacakge 时，不需要分别到各自的 repo 进行修改、测试、发版或者 npm link，直接在当前 repo 修改，统一测试、统一发版。只要搭建一套脚手架，就能管理（构建、测试、发布）多个 package。</p>\n<p>一图胜千言:</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyOThmNTYwZDgxZDg\" alt=\"img\"><br>当然到底哪一种管理方式更好，仁者见仁，智者见智。前者允许多元化发展（各项目可以有自己的构建工具、依赖管理策略、单元测试方法），后者希望集中管理，减少项目间的差异带来的沟通成本。</p>\n<p>虽然拆分子仓库、拆分子 npm 包是进行项目隔离的天然方案，但当仓库内容出现关联时，没有任何一种调试方式比源码放在一起更高效。</p>\n<p>结合 shop-service 门户的实际场景和业务需要，天然的 MonoRepo ! 一个理想的开发环境可以抽象成这样：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>“只关心业务代码，可以直接跨业务复用而不关心复用方式，调试时所有代码都在源码中。”</p></blockquote>\n<p>在前端开发环境中，多 Git Repo，多 npm 则是这个理想的阻力，它们导致复用要关心版本号，调试需要 npm link。而这些是 MonoRepo 最大的优势。</p>\n<p>上图中提到的利用相关工具就是今天的主角 Lerna ! Lerna 是业界知名度最高的 Monorepo 管理工具，功能完整。</p>\n<h1 id=\"2-Lerna\"><a href=\"#2-Lerna\" class=\"headerlink\" title=\"2. Lerna\"></a>2. Lerna</h1><p>Lerna 是一个管理多个 npm 模块的工具，是 Babel 自己用来维护自己的 Monorepo 并开源出的一个项目。优化维护多包的工作流，解决多个包互相依赖，且发布需要手动维护多个包的问题。</p>\n<h2 id=\"2-1-安装\"><a href=\"#2-1-安装\" class=\"headerlink\" title=\"2.1 安装\"></a>2.1 安装</h2><p>推荐全局安装，因为会经常用到 lerna 命令</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"><span class=\"token function\">npm</span> i -g lerna<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"2-2-初始化项目\"><a href=\"#2-2-初始化项目\" class=\"headerlink\" title=\"2.2 初始化项目\"></a>2.2 初始化项目</h2><pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">lerna init<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://kifimg.oss-cn-beijing.aliyuncs.com/img/202301261904362.png\" alt=\"img\"></p>\n<p>其中 package.json &amp; lerna.json 如下:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; package.json\n&#123;\n  &quot;name&quot;: &quot;root&quot;,\n  &quot;private&quot;: true, &#x2F;&#x2F; 私有的，不会被发布，是管理整个项目，与要发布到npm的解耦\n  &quot;devDependencies&quot;: &#123;\n    &quot;lerna&quot;: &quot;^3.15.0&quot;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; lerna.json\n&#123;\n  &quot;packages&quot;: [\n    &quot;packages&#x2F;*&quot;\n  ],\n  &quot;version&quot;: &quot;0.0.0&quot;\n&#125;\n12345678910111213141516<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"2-3-创建-npm-包\"><a href=\"#2-3-创建-npm-包\" class=\"headerlink\" title=\"2.3 创建 npm 包\"></a>2.3 创建 npm 包</h2><p>增加两个 packages</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">lerna create @mo-demo/cli\nlerna create @mo-demo/cli-shared-utils<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://kifimg.oss-cn-beijing.aliyuncs.com/img/202301261904303.png\" alt=\"img\"></p>\n<h2 id=\"2-4-增加模块依赖\"><a href=\"#2-4-增加模块依赖\" class=\"headerlink\" title=\"2.4 增加模块依赖\"></a>2.4 增加模块依赖</h2><p>分别给相应的 package 增加依赖模块</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">lerna <span class=\"token function\">add</span> chalk // 为所有 package 增加 chalk 模块\nlerna <span class=\"token function\">add</span> semver --scope @mo-demo/cli-shared-utils // 为 @mo-demo/cli-shared-utils 增加 semver 模块\nlerna <span class=\"token function\">add</span> @mo-demo/cli-shared-utils --scope @mo-demo/cli // 增加内部模块之间的依赖<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://kifimg.oss-cn-beijing.aliyuncs.com/img/202301261904194.png\" alt=\"img\"></p>\n<h2 id=\"2-5-发布\"><a href=\"#2-5-发布\" class=\"headerlink\" title=\"2.5 发布\"></a>2.5 发布</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">lerna publish<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://kifimg.oss-cn-beijing.aliyuncs.com/img/202301261904515.png\" alt=\"img\"></p>\n<h2 id=\"2-6-依赖包管理\"><a href=\"#2-6-依赖包管理\" class=\"headerlink\" title=\"2.6 依赖包管理\"></a>2.6 依赖包管理</h2><p>上述 1-5 步已经包含了 Lerna 整个生命周期的过程了，但当我们维护这个项目时，新拉下来仓库的代码后，需要为各个 package 安装依赖包。</p>\n<p>我们在第 4 步 lerna add 时也发现了，为某个 package 安装的包被放到了这个 package 目录下的 <code>node_modules</code> 目录下。这样对于多个 package 都依赖的包，会被多个 package 安装多次，并且每个 package 下都维护 <code>node_modules</code> ，也不清爽。于是我们使用 –hoist 来把每个 package 下的依赖包都提升到工程根目录，来降低安装以及管理的成本。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lerna bootstrap --hoist<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://kifimg.oss-cn-beijing.aliyuncs.com/img/202301261904358.png\" alt=\"img\"><br>为了省去每次都输入 –hoist 参数的麻烦，可以在 lerna.json 配置：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;\n  &quot;packages&quot;: [\n    &quot;packages&#x2F;*&quot;\n  ],\n  &quot;command&quot;: &#123;\n    &quot;bootstrap&quot;: &#123;\n      &quot;hoist&quot;: true\n    &#125;\n  &#125;,\n  &quot;version&quot;: &quot;0.0.1-alpha.0&quot;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>配置好后，对于之前依赖包已经被安装到各个 package 下的情况，我们只需要清理一下安装的依赖即可：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lerna clean<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><img src=\"https://kifimg.oss-cn-beijing.aliyuncs.com/img/202301261904400.png\" alt=\"img\"><br>然后执行 lerna bootstrap 即可看到 package 的依赖都被安装到根目录下的 <code>node_modules</code> 中了。</p>\n<h1 id=\"3-Lerna-Monorepo-最佳实践\"><a href=\"#3-Lerna-Monorepo-最佳实践\" class=\"headerlink\" title=\"3. Lerna + Monorepo 最佳实践\"></a>3. Lerna + Monorepo 最佳实践</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>lerna 不负责构建，测试等任务，它提出了一种集中管理 package 的目录模式，提供了一套自动化管理程序，让开发者不必再深耕到具体的组件里维护内容，在项目根目录就可以全局掌控，基于 npm scripts，使用者可以很好地完成组件构建，代码格式化等操作。接下来我们就来看看，如果基于 Lerna，并结合其它工具来搭建 Monorepo 项目的最佳实践。</p></blockquote>\n<p>目前最常见的 monorepo 解决方案是 Lerna 和 <a href=\"https://so.csdn.net/so/search?q=yarn&spm=1001.2101.3001.7020\">yarn</a> 的 workspaces 特性，基于 lerna 和 yarn workspace 的 monorepo 工作流。由于 yarn 和 lerna 在功能上有较多的重叠,我们采用 yarn 官方推荐的做法,用 yarn 来处理依赖问题，用 lerna 来处理发布问题。能用 yarn 做的就用 yarn 做吧</p>\n<h2 id=\"3-1-yarn-workspace\"><a href=\"#3-1-yarn-workspace\" class=\"headerlink\" title=\"3.1 yarn workspace\"></a>3.1 yarn workspace</h2><h3 id=\"3-1-1-搭建环境\"><a href=\"#3-1-1-搭建环境\" class=\"headerlink\" title=\"3.1.1 搭建环境\"></a>3.1.1 搭建环境</h3><ul>\n<li>普通项目：clone 下来后通过 yarn install,即可搭建完项目，有时需要配合 postinstall hooks,来进行自动编译，或者其他设置。</li>\n<li>monorepo: 各个库之间存在依赖，如 A 依赖于 B，因此我们通常需要将 B link 到 A 的 node_module 里，一旦仓库很多的话，手动的管理这些 link 操作负担很大，因此需要自动化的 link 操作，按照拓扑排序将各个依赖进行 link</li>\n</ul>\n<p>解决方式：通过使用 workspace，yarn install 会自动的帮忙解决安装和 link 问题</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yarn install # 等价于 lerna bootstrap --npm-client yarn --use-workspaces<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"3-1-2-清理环境\"><a href=\"#3-1-2-清理环境\" class=\"headerlink\" title=\"3.1.2 清理环境\"></a>3.1.2 清理环境</h3><p>在依赖乱掉或者工程混乱的情况下，清理依赖</p>\n<ul>\n<li>普通项目： 直接删除 node_modules 以及编译后的产物。</li>\n<li>monorepo： 不仅需要删除 root 的 node_modules 的编译产物还需要删除各个 package 里的 node_modules 以及编译产物</li>\n</ul>\n<p>解决方式：使用 lerna clean 来删除所有的 node_modules，使用 yarn workspaces run clean 来执行所有 package 的清理工作</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lerna clean # 清理所有的node_modules\nyarn workspaces run clean # 执行所有package的clean操作<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"3-1-3-安装-删除依赖\"><a href=\"#3-1-3-安装-删除依赖\" class=\"headerlink\" title=\"3.1.3 安装|删除依赖\"></a>3.1.3 安装|删除依赖</h3><ul>\n<li>普通项目： 通过 yarn add 和 yarn remove 即可简单姐解决依赖库的安装和删除问题</li>\n<li>monorepo: 一般分为三种场景<ul>\n<li>给某个 package 安装依赖：yarn workspace packageB add packageA 将 packageA 作为 packageB 的依赖进行安装</li>\n<li>给所有的 package 安装依赖: 使用 yarn workspaces add lodash 给所有的 package 安装依赖</li>\n<li>给 root 安装依赖：一般的公用的开发工具都是安装在 root 里，如 typescript,我们使用 yarn add -W -D typescript 来给 root 安装依赖</li>\n</ul>\n</li>\n</ul>\n<p>对应的三种场景删除依赖如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yarn workspace packageB remove packageA\nyarn workspaces remove lodash\nyarn remove -W -D typescript<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"3-1-4-项目构建\"><a href=\"#3-1-4-项目构建\" class=\"headerlink\" title=\"3.1.4 项目构建\"></a>3.1.4 项目构建</h3><ul>\n<li>普通项目：建立一个 build 的 npm script，使用 yarn build 即可完成项目构建</li>\n<li>monorepo:区别于普通项目之处在于各个 package 之间存在相互依赖，如 packageB 只有在 packageA 构建完之后才能进行构建，否则就会出错，这实际上要求我们以一种拓扑排序的规则进行构建。</li>\n</ul>\n<p>我们可以自己构建拓扑排序规则，很不幸的是 yarn 的 workspace 暂时并未支持按照拓扑排序规则执行命令,虽然该 rfc 已经被 accepted，但是尚未实现, 幸运的是 lerna 支持按照拓扑排序规则执行命令, –sort 参数可以控制以拓扑排序规则执行命令</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lerna run --stream --sort build<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"3-1-5-版本升级及发包\"><a href=\"#3-1-5-版本升级及发包\" class=\"headerlink\" title=\"3.1.5 版本升级及发包\"></a>3.1.5 版本升级及发包</h3><p>项目测试完成后，就涉及到版本发布，版本发布一般涉及到如下一些步骤</p>\n<ul>\n<li><strong>条件验证</strong>: 如验证测试是否通过，是否存在未提交的代码，是否在主分支上进行版本发布操作</li>\n<li><strong>version_bump</strong>:发版的时候需要更新版本号，这时候如何更新版本号就是个问题，一般大家都会遵循 semVer 语义，</li>\n<li><strong>生成 changelog</strong>: 为了方便查看每个 package 每个版本解决了哪些功能，我们需要给每个 package 都生成一份 changelog 方便用户查看各个版本的功能变化。</li>\n<li><strong>生成 git tag</strong>：为了方便后续回滚问题及问题排查通常需要给每个版本创建一个 git tag</li>\n<li><strong>git 发布版本</strong>：每次发版我们都需要单独生成一个 commit 记录来标记 milestone</li>\n<li><strong>发布 npm 包</strong>：发布完 git 后我们还需要将更新的版本发布到 npm 上，以便外部用户使用</li>\n</ul>\n<p>我们发现手动的执行这些操作是很麻烦的且及其容易出错，幸运的是 lerna 可以帮助我们解决这些问题</p>\n<p>yarn 官方并不打算支持发布流程，只是想做好包管理工具，因此这部分还是需要通过 lerna 支持</p>\n<p>lerna 提供了 publish 和 version 来支持版本的升级和发布, publish 的功能可以即包含 version 的工作，也可以单纯的只做发布操作。</p>\n<h2 id=\"3-2-优雅的提交\"><a href=\"#3-2-优雅的提交\" class=\"headerlink\" title=\"3.2 优雅的提交\"></a>3.2 优雅的提交</h2><h3 id=\"3-2-1-commitizen-amp-amp-cz-lerna-changelog\"><a href=\"#3-2-1-commitizen-amp-amp-cz-lerna-changelog\" class=\"headerlink\" title=\"3.2.1 commitizen &amp;&amp; cz-lerna-changelog\"></a>3.2.1 commitizen &amp;&amp; cz-lerna-changelog</h3><p><code>commitizen</code> 是用来格式化 git commit message 的工具，它提供了一种问询式的方式去获取所需的提交信息。</p>\n<p><code>cz-lerna-changelog</code> 是专门为 Lerna 项目量身定制的提交规范，在问询的过程，会有类似影响哪些 package 的选择。如下：</p>\n<p><img src=\"https://kifimg.oss-cn-beijing.aliyuncs.com/img/202301261904381.png\" alt=\"img\"><br>我们使用 <code>commitizen</code> 和 <code>cz-lerna-changelog</code> 来规范提交，为后面自动生成日志作好准备。</p>\n<p>因为这是整个工程的开发依赖，所以在根目录安装：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yarn add  -D commitizen\nyarn add  -D cz-lerna-changelog<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>安装完成后，在 <code>package.json</code> 中增加 config 字段，把 <code>cz-lerna-changelog</code> 配置给 <code>commitizen</code>。同时因为<code>commitizen</code>不是全局安全的，所以需要添加 scripts 脚本来执行 git-cz</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;\n  &quot;name&quot;: &quot;root&quot;,\n  &quot;private&quot;: true,\n  &quot;scripts&quot;: &#123;\n    &quot;commit&quot;: &quot;git-cz&quot;\n  &#125;,\n  &quot;config&quot;: &#123;\n    &quot;commitizen&quot;: &#123;\n      &quot;path&quot;: &quot;.&#x2F;node_modules&#x2F;cz-lerna-changelog&quot;\n    &#125;\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;commitizen&quot;: &quot;^3.1.1&quot;,\n    &quot;cz-lerna-changelog&quot;: &quot;^2.0.2&quot;,\n    &quot;lerna&quot;: &quot;^3.15.0&quot;\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>之后在常规的开发中就可以使用 <code>yarn run commit</code> 来根据提示一步一步输入，来完成代码的提交。</p>\n<h3 id=\"3-2-2-commitlint-amp-amp-husky\"><a href=\"#3-2-2-commitlint-amp-amp-husky\" class=\"headerlink\" title=\"3.2.2 commitlint &amp;&amp; husky\"></a>3.2.2 commitlint &amp;&amp; husky</h3><p>上面我们使用了 commitizen 来规范提交，但这个要靠开发自觉使用<code>yarn run commit</code> 。万一忘记了，或者直接使用 git commit 提交怎么办？答案就是在提交时对提交信息进行校验，如果不符合要求就不让提交，并提示。校验的工作由 commitlint 来完成，校验的时机则由 husky 来指定。husky 继承了 Git 下所有的钩子，在触发钩子的时候，husky 可以阻止不合法的 commit,push 等等。</p>\n<p>安装 commitlint 以及要遵守的规范</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yarn add -D @commitlint&#x2F;cli @commitlint&#x2F;config-conventional<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>在工程根目录为 commitlint 增加配置文件 <code>commitlint.config.js</code> 为<code>commitlint</code> 指定相应的规范</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">module.exports &#x3D; &#123;\n\textends: [&#39;@commitlint&#x2F;config-conventional&#39;]\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>安装 <code>husky</code></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yarn add -D husky<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>在 <code>package.json</code> 中增加如下配置</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&quot;husky&quot;: &#123;\n\t\t&quot;hooks&quot;: &#123;\n   \t\t&quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>“commit-msg”是 git 提交时校验提交信息的钩子，当触发时便会使用 commitlit 来校验。安装配置完成后，想通过 git commit 或者其它第三方工具提交时，只要提交信息不符合规范就无法提交。从而约束开发者使用 yarn run commit 来提交。</p>\n<h3 id=\"3-2-3-eslint-amp-amp-lint-staged\"><a href=\"#3-2-3-eslint-amp-amp-lint-staged\" class=\"headerlink\" title=\"3.2.3 eslint &amp;&amp; lint-staged\"></a>3.2.3 eslint &amp;&amp; lint-staged</h3><p>除了规范提交信息，代码本身肯定也少了靠规范来统一风格。</p>\n<p>安装</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"><span class=\"token function\">yarn</span> <span class=\"token function\">add</span>  -D standard lint-staged<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>eslint 就是整的一套 JavaScript（typescript） 代码规范，自带 linter &amp; 代码自动修正。自动格式化代码并修正，提前发现风格以及程序问题, 同时也支持 typescript 的代码规范校验，<code>eslintrc.json</code>配置：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;\n    &quot;extends&quot;: [\n        &quot;yayajing&quot;,\n        &quot;plugin:@typescript-eslint&#x2F;recommended&quot;\n    ],\n    &quot;parser&quot;: &quot;typescript-eslint-parser&quot;,\n    &quot;plugins&quot;: [&quot;@typescript-eslint&quot;],\n    &quot;rules&quot;: &#123;\n        &quot;eqeqeq&quot;:&quot;off&quot;,\n        &quot;@typescript-eslint&#x2F;explicit-function-return-type&quot;: &quot;off&quot;,\n        &quot;no-template-curly-in-string&quot;: &quot;off&quot;\n    &#125;\n  &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>lint-staged staged</code> 是 Git 里的概念，表示暂存区，<code>lint-staged</code> 表示只检查并矫正暂存区中的文件。一来提高校验效率，二来可以为老的项目带去巨大的方便。</p>\n<p>package.json 配置</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; package.json\n&#123;\n  &quot;name&quot;: &quot;root&quot;,\n  &quot;private&quot;: true,\n  &quot;scripts&quot;: &#123;\n    &quot;c&quot;: &quot;git-cz&quot;\n  &#125;,\n  &quot;config&quot;: &#123;\n    &quot;commitizen&quot;: &#123;\n      &quot;path&quot;: &quot;.&#x2F;node_modules&#x2F;cz-lerna-changelog&quot;\n    &#125;\n  &#125;,\n  &quot;husky&quot;: &#123;\n    &quot;hooks&quot;: &#123;\n      &quot;pre-commit&quot;: &quot;lint-staged&quot;,\n      &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;\n    &#125;\n  &#125;,\n  &quot;lint-staged&quot;: &#123;\n    &quot;*.ts&quot;: [\n      &quot;eslint --fix&quot;,\n      &quot;git add&quot;\n    ]\n  &#125;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;@commitlint&#x2F;cli&quot;: &quot;^8.1.0&quot;,\n    &quot;@commitlint&#x2F;config-conventional&quot;: &quot;^8.1.0&quot;,\n    &quot;commitizen&quot;: &quot;^3.1.1&quot;,\n    &quot;cz-lerna-changelog&quot;: &quot;^2.0.2&quot;,\n    &quot;husky&quot;: &quot;^3.0.0&quot;,\n    &quot;lerna&quot;: &quot;^3.15.0&quot;,\n    &quot;lint-staged&quot;: &quot;^9.2.0&quot;\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>安装完成后，在 <code>package.json</code> 增加 lint-staged 配置，如上所示表示对暂存区中的 js 文件执行 <code>eslint --fix</code> 校验并自动修复。那什么时候去校验呢，就又用到了上面安装的 husky ，husky 的配置中增加<code>pre-commit</code>的钩子用来执行 lint-staged 的校验操作。</p>\n<p>此时提交 ts 文件时，便会自动修正并校验错误。即保证了代码风格统一，又能提高代码质量。</p>\n<h2 id=\"3-3-发布自动生成日志\"><a href=\"#3-3-发布自动生成日志\" class=\"headerlink\" title=\"3.3 发布自动生成日志\"></a>3.3 发布自动生成日志</h2><p>有了之前的规范提交，自动生成日志便水到渠成了。再详细看下 <code>lerna publish</code> 时做了哪些事情：</p>\n<h3 id=\"3-3-1-lerna-version-更新版本\"><a href=\"#3-3-1-lerna-version-更新版本\" class=\"headerlink\" title=\"3.3.1 lerna version 更新版本\"></a>3.3.1 lerna version 更新版本</h3><ul>\n<li>找出从上一个版本发布以来有过变更的 package</li>\n<li>提示开发者确定要发布的版本号</li>\n<li>将所有更新过的的 package 中的 package.json 的 version 字段更新</li>\n<li>将依赖更新过的 package 的 包中的依赖版本号更新</li>\n<li>更新 lerna.json 中的 version 字段</li>\n<li>提交上述修改，并打一个 tag</li>\n<li>推送到 git 仓库</li>\n</ul>\n<p><img src=\"https://kifimg.oss-cn-beijing.aliyuncs.com/img/202301261905340.png\" alt=\"img\"></p>\n<h3 id=\"3-3-2-使用-npm-publish-将新版本推送到-npm\"><a href=\"#3-3-2-使用-npm-publish-将新版本推送到-npm\" class=\"headerlink\" title=\"3.3.2 使用 npm publish 将新版本推送到 npm\"></a>3.3.2 使用 npm publish 将新版本推送到 npm</h3><p><code>CHANGELOG</code> 很明显是和 version 一一对应的，所以需要在 lerna version 中想办法，查看 lerna version 命令的详细说明后，会看到一个配置参数 <code>--conventional-commits</code>。没错，只要我们按规范提交后，在 lerna version 的过程中会便会自动生成当前这个版本的 CHANGELOG。为了方便，不用每次输入参数，可以配置在 <code>lerna.json</code>中，如下：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">&#123;</span>\n  <span class=\"token property\">\"packages\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"packages/*\"</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"command\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token property\">\"bootstrap\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token property\">\"hoist\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token property\">\"conventionalCommits\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"ignoreChanges\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"**/*.md\"</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"0.0.1-alpha.1\"</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><code>lerna version</code> 会检测从上一个版本发布以来的变动，但有一些文件的提交，我们不希望触发版本的变动，譬如 .md 文件的修改，并没有实际引起 package 逻辑的变化，不应该触发版本的变更。可以通过 <code>ignoreChanges</code> 配置排除。如上。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzE4LzE2Y2EyYTM3NTQwN2Y0MzY\" alt=\"img\"><br>实际 <code>lerna version</code>很少直接使用，因为它包含在 <code>lerna publish</code> 中了，直接使用 <code>lerna publish</code>就好了。</p>\n<h2 id=\"3-4-完善的测试用例\"><a href=\"#3-4-完善的测试用例\" class=\"headerlink\" title=\"3.4 完善的测试用例\"></a>3.4 完善的测试用例</h2><p>monorepo 项目：测试有两种方式</p>\n<ul>\n<li>使用统一的 jest 测试配置这样方便全局的跑 jest 即可，好处是可以方便统计所有代码的测试覆盖率，坏处是如果 package 比较异构（如小程序，前端，node 服务端等），统一的测试配置不太好编写</li>\n<li>每个 package 单独支持 test 命令，使用 yarn workspace run test，坏处是不好统一收集所有代码的测试覆盖率</li>\n</ul>\n<p>如果采用 jest 编写测试用例，支持 typescript 的话，需要初始化配置 jest.config.js：</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token literal-property property\">preset</span><span class=\"token operator\">:</span> <span class=\"token string\">\"ts-jest\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">moduleFileExtensions</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"ts\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">testEnvironment</span><span class=\"token operator\">:</span> <span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"4-实践总结\"><a href=\"#4-实践总结\" class=\"headerlink\" title=\"4 实践总结\"></a>4 实践总结</h1><p>到这里，基本上已经构建了基于<code>lerna</code>和<code>yarn workspace</code>的 monorepo 项目的最佳实践了，该有的功能都有：</p>\n<ul>\n<li>完善的工作流</li>\n<li>typescript 支持</li>\n<li>风格统一的编码</li>\n<li>完整的单元测试</li>\n<li>一键式的发布机制</li>\n<li>完美的更新日志</li>\n</ul>\n<p>……</p>\n<p><strong>当然，构建一套完善的仓库管理机制，可能它的收益不是一些量化的指标可以衡量出来的，也没有直接的价值输出，但它能在日常的工作中极大的提高工作效率，解放生产力，节省大量的人力成本。</strong></p>\n<p>转载自：<a href=\"https://juejin.cn/post/6844903918279852046\">https://juejin.cn/post/6844903918279852046</a></p>\n","text":"1.monorepo 管理对于维护过多个package(功能相近)的同学来说，都会遇到一个选择题，这些 package 是放在一个仓库里维护还是放在多个仓库里单独维护。Multirepo 是比较传统的做法，即每一个 package 都单独用一个仓库来进行管理。Monorepo 是...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"开发笔记","slug":"开发笔记","count":3,"path":"api/categories/开发笔记.json"},{"name":"转载","slug":"开发笔记/转载","count":1,"path":"api/categories/开发笔记/转载.json"}],"tags":[{"name":"lerna","slug":"lerna","count":1,"path":"api/tags/lerna.json"},{"name":"workspace","slug":"workspace","count":1,"path":"api/tags/workspace.json"},{"name":"monorepo","slug":"monorepo","count":1,"path":"api/tags/monorepo.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-monorepo-%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">1.monorepo 管理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-Lerna\"><span class=\"toc-text\">2. Lerna</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">2.1 安装</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">2.2 初始化项目</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E5%88%9B%E5%BB%BA-npm-%E5%8C%85\"><span class=\"toc-text\">2.3 创建 npm 包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E5%A2%9E%E5%8A%A0%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">2.4 增加模块依赖</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-5-%E5%8F%91%E5%B8%83\"><span class=\"toc-text\">2.5 发布</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-6-%E4%BE%9D%E8%B5%96%E5%8C%85%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">2.6 依赖包管理</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-Lerna-Monorepo-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">3. Lerna + Monorepo 最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-yarn-workspace\"><span class=\"toc-text\">3.1 yarn workspace</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-1-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">3.1.1 搭建环境</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-2-%E6%B8%85%E7%90%86%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">3.1.2 清理环境</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-3-%E5%AE%89%E8%A3%85-%E5%88%A0%E9%99%A4%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">3.1.3 安装|删除依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-4-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA\"><span class=\"toc-text\">3.1.4 项目构建</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-5-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%8F%91%E5%8C%85\"><span class=\"toc-text\">3.1.5 版本升级及发包</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E4%BC%98%E9%9B%85%E7%9A%84%E6%8F%90%E4%BA%A4\"><span class=\"toc-text\">3.2 优雅的提交</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-1-commitizen-amp-amp-cz-lerna-changelog\"><span class=\"toc-text\">3.2.1 commitizen &amp;&amp; cz-lerna-changelog</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-2-commitlint-amp-amp-husky\"><span class=\"toc-text\">3.2.2 commitlint &amp;&amp; husky</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-3-eslint-amp-amp-lint-staged\"><span class=\"toc-text\">3.2.3 eslint &amp;&amp; lint-staged</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E5%8F%91%E5%B8%83%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">3.3 发布自动生成日志</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-1-lerna-version-%E6%9B%B4%E6%96%B0%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">3.3.1 lerna version 更新版本</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-2-%E4%BD%BF%E7%94%A8-npm-publish-%E5%B0%86%E6%96%B0%E7%89%88%E6%9C%AC%E6%8E%A8%E9%80%81%E5%88%B0-npm\"><span class=\"toc-text\">3.3.2 使用 npm publish 将新版本推送到 npm</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-%E5%AE%8C%E5%96%84%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B\"><span class=\"toc-text\">3.4 完善的测试用例</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">4 实践总结</span></a></li></ol>","author":{"name":"kif","slug":"blog-author","avatar":"https://kifimg.oss-cn-beijing.aliyuncs.com/imgforteachingdemo/20201127203438.png","link":"/","description":"时间再拉长一点，让我有时间收拾一下心情","socials":{"github":"https://github.com/wkif","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_54739682?type=blog","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端面试题目","uid":"4bd7150fd9e4dc678a3c2ce6062a159a","slug":"前端面试题目","date":"2022-03-31T00:42:00.000Z","updated":"2022-05-05T13:37:24.415Z","comments":true,"path":"api/articles/前端面试题目.json","keywords":null,"cover":"https://kifimg.oss-cn-beijing.aliyuncs.com/imgforhexo/202203310851324.jpg","text":"html基础1.自定义列表&lt;!DOCTYPE html> &lt;html lang=\"zh\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width...","link":"","photos":[],"count_time":{"symbolsCount":"133k","symbolsTime":"2:01"},"categories":[],"tags":[{"name":"面试","slug":"面试","count":1,"path":"api/tags/面试.json"}],"author":{"name":"kif","slug":"blog-author","avatar":"https://kifimg.oss-cn-beijing.aliyuncs.com/imgforteachingdemo/20201127203438.png","link":"/","description":"时间再拉长一点，让我有时间收拾一下心情","socials":{"github":"https://github.com/wkif","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_54739682?type=blog","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"js 数组详细操作方法及解析","uid":"24deb55255063425129571f44dab3ef2","slug":"js-数组详细操作方法及解析","date":"2023-01-10T03:18:00.000Z","updated":"2023-01-10T03:23:08.955Z","comments":true,"path":"api/articles/js-数组详细操作方法及解析.json","keywords":null,"cover":"https://kifimg.oss-cn-beijing.aliyuncs.com/img/202301101122188.png","text":"创建一个数组: // 字面量方式: // 这个方法也是我们最常用的，在初始化数组的时候 相当方便 var a = [3, 11, 8]; // [3,11,8]; // 构造器: // 实际上 new Array === Array,加不加new 一点影响都没有。 var a =...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"转载","slug":"转载","count":1,"path":"api/categories/转载.json"},{"name":"学习笔记","slug":"转载/学习笔记","count":1,"path":"api/categories/转载/学习笔记.json"}],"tags":[{"name":"javascript","slug":"javascript","count":7,"path":"api/tags/javascript.json"},{"name":"数组","slug":"数组","count":1,"path":"api/tags/数组.json"}],"author":{"name":"kif","slug":"blog-author","avatar":"https://kifimg.oss-cn-beijing.aliyuncs.com/imgforteachingdemo/20201127203438.png","link":"/","description":"时间再拉长一点，让我有时间收拾一下心情","socials":{"github":"https://github.com/wkif","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_54739682?type=blog","juejin":"","customs":{}}}}}