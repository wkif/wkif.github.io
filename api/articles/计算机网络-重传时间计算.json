{"title":"计算机网络--重传时间计算","uid":"e70ac243ed96ebe126ae5c93419396bc","slug":"计算机网络-重传时间计算","date":"2021-06-22T05:48:00.000Z","updated":"2022-03-30T16:05:12.921Z","comments":true,"path":"api/articles/计算机网络-重传时间计算.json","keywords":null,"cover":"https://kifimg.oss-cn-beijing.aliyuncs.com/imgforhexo/202203310005647.png","content":"<p>我们都知道，TCP发送方在规定时间内没有收到确认就要重传已发送的报文段（里面有一个超时计数器），这个逻辑很简单，但是这个超时计数器的值每次都是不一样的，也就是说：重传时间的选择是不一样的，它是如何确定的呢？？？</p>\n<p>TCP下层是互联网环境，发送的报文段可能只经过一个高速率的局域网，也可能经过多个低速率的网络，并且每个IP数据报所选择的路由还可能不同。如果把超时重传时间设置太短，就会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传时间设置的太长，那么网络空闲时间会增大，极大的降低了网络的效率</p>\n<p>到底应该设置为多大呢？？？？</p>\n<p>TCP采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间RTT。TCP保留了RTT的一个加权平均往返时间RTTs（这又成为平滑的往返时间，S表示Smoothed。因为进行的是加权平均，因此获得的结果更加平滑，也就是让我们计算出的结果更加合理）。每回的第一次测量到RTT样本时，RTTs值就取为所测量到的RTT样本值，但以后每次测量到一个新的RTT样本，就按下面的公式重新计算一次RTTs：</p>\n<p>           <img src=\"https://gitee.com/wkkif/PicGoimg/raw/master/img/20210622135042.png\" alt=\"image-20210622135042562\"></p>\n<p>在上式中：（阿尔法 的值介于0到1，若很接近0，则表示旧的RTTs值和新的RTTs值相比变化不大，也就是说，新的RTT样本不太影响RTTs; 若很接近1，则表明新的RTTs值，受当前采集的RTT样本影响较大，跟上次的RTTs差距大）</p>\n<p>RFC 2988：推荐的阿尔法值为1&#x2F;8,也就是0.125 （这种方式得出的值更为平滑）</p>\n<p>显然：超时计数器设置的超时重传时间RTO（Retransmission Time-Out）应略大于上面计算的结果。同样的：</p>\n<p>RFC  2988：建议使用下面的公式计算RTO：</p>\n<p>          <img src=\"https://gitee.com/wkkif/PicGoimg/raw/master/img/20210622135115.png\" alt=\"image-20210622135115160\"></p>\n<p>RTTd是RTT的偏差的加权平均值，与RTTs和新的RTT样本之差有关。RFC 2988建议这样计算RTTd。当第一次测量时，RTTd值取为RTT样本值的一半。在以后的测量中，则使用下式计算加权平均RTTd：</p>\n<p>          <img src=\"https://gitee.com/wkkif/PicGoimg/raw/master/img/20210622135139.png\" alt=\"image-20210622135139430\"></p>\n<p>这里的（贝塔）是一个小于1的系数，它的推荐值是1&#x2F;4，即就是0。125</p>\n<p>好了，通过上面这些东西：我们就可以求出超时计数器所要设置的时间问题了，但是，但是，但是，新的问题也来了？？？？</p>\n<p>发送一个报文段，设定的重传时间到了，还没有收到确认。于是重传报文段，经过一段时间后：收到了确认报文段。</p>\n<p>现在的问题是：如何判定此报文段是对先发送的报文段的确认，还是对后来重传的报文段的确认？？？由于重传的报文段和原来的报文段完全一样，所以源主机在接受到确认后，无法做出正确的判断，而正确的判断对确定加权平均RTTs的值关系很大。</p>\n<p>1，若收到的是对重传报文段的确认，但却被源主机当作是对原来报文段的确认，则计算出的RTTs和超时重传时间RTO就会偏大。若后面再发送的报文段又是经过重传后才收到的确认报文段，则RTO这个时间会越来越长。直接影响效率</p>\n<p>2，若收到的是对原来的报文段的确认，但被当作是对重传报文段的确认，则由此计算出的RTTs和RTO都会偏小，这样就会导致过多的重传，使的RTO越来越小</p>\n<p>根据以上所说：Karn提出了一个算法：在计算加权平均RTTs时，只要报文段重传了，就不采用其往返时间样本。这样得出的加权平均RTTs和RTO就相对比较准确了。</p>\n<p>但是，但是，要是出现这样的情况呢？？：报文段的时延突然增大了很多。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据Karn算法，不考虑重传的报文段的往返时间样本。这样：超时重传时间就无法更新。</p>\n<p>因此：要对Karn算法进行修正：方法是：报文段每重传一次，就把超时冲传时间RTO增大一些。典型的做法是：取新的重传时间为2倍的旧的重传时间。当不再发生报文段的重传时，才根据上面给出公式计算超时重传时间。。。。</p>\n<p>转自;<a href=\"https://blog.csdn.net/msdnwolaile/article/details/51227491\">https://blog.csdn.net/msdnwolaile/article/details/51227491</a></p>\n","text":"我们都知道，TCP发送方在规定时间内没有收到确认就要重传已发送的报文段（里面有一个超时计数器），这个逻辑很简单，但是这个超时计数器的值每次都是不一样的，也就是说：重传时间的选择是不一样的，它是如何确定的呢？？？ TCP下层是互联网环境，发送的报文段可能只经过一个高速率的局域网，也...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":23,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"计算机网络","slug":"计算机网络","count":2,"path":"api/tags/计算机网络.json"}],"toc":"","author":{"name":"kif","slug":"blog-author","avatar":"https://kifimg.oss-cn-beijing.aliyuncs.com/imgforteachingdemo/20201127203438.png","link":"/","description":"时间再拉长一点，让我有时间收拾一下心情","socials":{"github":"https://github.com/wkif","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_54739682?type=blog","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"标准分类的IP地址","uid":"28d0a4fcfbc7fc3606b73b8705c12a98","slug":"标准分类的IP地址","date":"2021-06-22T06:28:00.000Z","updated":"2022-03-30T15:58:58.944Z","comments":true,"path":"api/articles/标准分类的IP地址.json","keywords":null,"cover":"https://kifimg.oss-cn-beijing.aliyuncs.com/imgforhexo/20201202142630.jpg","text":"一、标准分类的IP地址 每台计算机都要有IP地址，有了IP地址才能互相通信，计算机之间只能互相认识IP地址。IP地址可以理解为计算机的×××号。 （一）二进制和十进制数转换(★记住) 11111111→128＋64＋32＋16＋8＋4＋2＋1＝240＋15＝255 举例： 101...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":23,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"计算机网络","slug":"计算机网络","count":2,"path":"api/tags/计算机网络.json"}],"author":{"name":"kif","slug":"blog-author","avatar":"https://kifimg.oss-cn-beijing.aliyuncs.com/imgforteachingdemo/20201127203438.png","link":"/","description":"时间再拉长一点，让我有时间收拾一下心情","socials":{"github":"https://github.com/wkif","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_54739682?type=blog","juejin":"","customs":{}}}},"next_post":{"title":"后端框架学习-Django","uid":"1c5e4adfa32051d3ce39d99767de062e","slug":"后端框架学习-Django","date":"2021-05-05T14:16:00.000Z","updated":"2022-03-30T16:04:59.245Z","comments":true,"path":"api/articles/后端框架学习-Django.json","keywords":null,"cover":"https://kifimg.oss-cn-beijing.aliyuncs.com/imgforhexo/882690e66cdd6486c7ced449245fe620.jpg","text":"基本介绍Django 是一个由 Python 编写的一个开放源代码的 Web 应用框架。 使用 Django，只要很少的代码，Python 的程序开发人员就可以轻松地完成一个正式网站所需要的大部分内容，并进一步开发出全功能的 Web 服务 Django 本身基于 MVC 模型，即...","link":"","photos":[],"count_time":{"symbolsCount":"31k","symbolsTime":"28 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":23,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"Django","slug":"Django","count":1,"path":"api/tags/Django.json"},{"name":"Python","slug":"Python","count":1,"path":"api/tags/Python.json"}],"author":{"name":"kif","slug":"blog-author","avatar":"https://kifimg.oss-cn-beijing.aliyuncs.com/imgforteachingdemo/20201127203438.png","link":"/","description":"时间再拉长一点，让我有时间收拾一下心情","socials":{"github":"https://github.com/wkif","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_54739682?type=blog","juejin":"","customs":{}}}}}